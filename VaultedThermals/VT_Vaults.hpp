/** 
@file VT_Vaults.hpp

@brief Vaulted Thermals: Vault Definitions

@details

Vaults (Designator):
MagmaChamber
Vault_00
Vault_01
Vault_02
Vault_03
Vault_04
Vault_05
Vault_06
Vault_07
Vault_08
Vault_09
Vault_10


Important: Higher numbered vaults may require a lower level vault to be opened. 
If the vault is not open, it will define the open definition itself implicitly.

Opening the MagmaChamber vault is unique int that it affects all other vaults.
When opened, the definition will change the loader interfaced with for all the implementation
in the other vaults to the loader generated by the MagmaChamber vault.
Define macro: VT_Vault_MagmaChamber_Open if you want this. [Note: Currently not implemented]

Note: Vaults 4 and 8 must be opened before use (see macro definitions for opening). 
This is due to their implementation making use of static or dynamic object allocations. 
If the vaults are not properly opened all that will exist within them is a namespace called: Vault_Closed.

Vault 4 Open Macro: #define VT_Vault_4_Open
Vault 8 Open Macro: #define VT_Vault_8_Open
*/



#pragma once



#ifndef VT_Option__Use_Short_Namespace
	namespace VaultedThermals
#else
	namespace VT
#endif
{
	/** @namespace Attic

		@brief Contains any misc global definitions.
	*/
	inline namespace Attic {}

	/** @namespace Corridors

		@brief Contains shared definitions between the vaults.
	*/
	namespace Corridors {}

	/** @namespace Vault_MagmaChamber

		@todo Look into possibly implementing with the Volk library.

		@brief Meta-Loading Setup.

		@details When the heat at the control gate isn't enough. 
	*/
	namespace Vault_MagmaChamber {}

	/** @namespace Vault_00

		@brief Backend vault for VaultedThermals

		@details For now only abstracts away OS Platform details and basic meta-structure definitions.
	*/
	namespace Vault_00 { using namespace Corridors; }

	/** @namespace Vault_01
	*
	*	@brief 1:1 Wrapping of Vulkan API
	*/
	namespace Vault_01 { using namespace Corridors; }

	/** @namespace Vault_02

		@brief Low cost procedural repetitive functionality wrapping.
	*/
	namespace Vault_02 { using namespace Corridors; }

	/** @namespace Vault_03

		@brief Medium cost procedural, preset implementation wrapping.
	*/
	namespace Vault_03 { using namespace Corridors; }

	/** @namespace Vault_04

		@brief Full setup providing procedure implementation.

		@details (Will have its own device references, queues, layers, etc.)
	*/
	namespace Vault_04 
	{
	#ifndef VT_Vault_4_Open
		namespace Vault_Closed {}
	#endif

	#ifdef VT_Vault_4_Open
		using namespace Corridors; 
	#endif
	}

	/** @namespace Vault_05
		
		@brief 1:1 Object oriented wrapping of Vulkan API
	*/
	namespace Vault_05 { using namespace Corridors; }

	/** @namespace Vault_06

		@brief Low cost Object-oriented repetitive functionality wrapping.
	*/
	namespace Vault_06 { using namespace Corridors; }

	/** @namespace Vault_07

		@brief Medium cost Object-oriented preset implementation wrapping.
	*/
	namespace Vault_07 { using namespace Corridors; }

	/** @namespace Vault_08

		@brief Full setup providing object-oriented implementation.

		@details (Will have its own device references, queues, layers, etc.)
	*/
	namespace Vault_08 
	{ 
	#ifndef VT_Vault_4_Open
		namespace Vault_Closed {}
	#endif

	#ifdef VT_Vault_4_Open
		using namespace Corridors;
	#endif
	}

	/** @namespace Vault_09
		
		@brief Reserved
	*/
	namespace Vault_09 { using namespace Corridors; }

	/** @namespace Vault_10
		
		@brief Reserved
	*/
	namespace Vault_10 { using namespace Corridors; }
}
