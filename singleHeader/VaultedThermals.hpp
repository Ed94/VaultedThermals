/*!
@file VaultedThermals.hpp

@brief VaultedThermals Include Interface

// Optional Features:

The library single include header.

Long namespace: #define VT_Option__Use_Long_Namespace

Inlining:
VT_Option__Use_Inline_Hinting
VT_Option__Use_Forced_Inlining

STL Exceptions (Note: right now the library does not STL exceptions but may in the future...):
VT_Option__Use_STL_Exceptions

Defining your own containers:

#define VT_Option__Use_Custom_Containers

using Deque        = YourContainerHere
using DynamicArray = YourContainerHere

Vault 4 Use:

In a hpp file, include VaultedThermals.hpp with this macro definition defined:
#define VT_Open_Vault_4

This will include all V4 header implementation.

In a cpp file, include VaultedThermals.hpp with this macro definition defined:
#define VT_V4_Setup_Implementation

This will include all V4 object implementation.
*/



#pragma once



/**
@mainpage VaultedThermals

# VaultedThermals
A vulkan wrapper. 

https://github.com/Ed94/VaultedThermals

Documentation can be found here: http://edsdigitalabode.com/VaultedThermals/index.html
(Documentation is updated usually with implementation or if not during refactoring periods)

## Benefits:
- Features a 1:1 wrap implementation of the Vulkan C-API. (See Vault_01 implementation) [Note: Work in progress, the entire API has not be wrapped as of yet.
- Vulkan API Structures auto set thier VkStructureType and have other default member initalization + operators for equality comparison.
- Typesafe bitmasks inspired by Jonathan's typesafe library.
- Ease of use functionality for bootstrapping (See Vaults_02/3/4), but without the extra non-gpu API related clutter (Asset Loading, Camera, Entity, etc)
- Leveled abstraction namespacing and optional implementation wrapped in macros to allow easy discretion of features desired.
- Full doxygen documentation presented nicely in a nice web format thanks to ModernC++Starter.
- Handwritten.

## State
WIP. See milestones / projects tab.

Currently the library can be used to bootstrap a vulkan backend, however a good amount of the C-API has not been wrapped.

My current intentions is to get this going as far as I like in conjunction with following various vulkan guides, and making my engine mvp. 
After that is done, this will be publicly released with some sort of open source license.

## Guides

Head on over to https://github.com/Ed94/VaultedThermals/tree/master/guides to get started.
*/



/**
@page LibraryOutline 

@section GuideSec Guide

The libraries files are organized based on the Khronos Vulkan Specification manual:
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html">Vulkan Specification</a>

While files are organized based on specification they do not strictly follow it entirely.

If its desired to view the content of the library in adherence to the organization of the official specification,
see the module: VulkanAPI_Specification.

Implementation directly related (1:1) to the Vulkan API will have a link to its respective specification.
 
Features that would be nice to have:
@todo Have support for object model enforcement.
*/




/*!
@file VT_Vaults.hpp

@brief Vaulted Thermals: Vault Definitions

@details

Vaults (Designator):
MagmaChamber
V0
V1
V2
V3
V4


Important: Higher numbered vaults may require a lower level vault to be opened. 
If the vault is not open, it will define the open definition itself implicitly.

Opening the MagmaChamber vault is unique in that it affects all other vaults.
When opened, the definition will change the loader interfaced with for all the implementation
in the other vaults to the loader generated by the MagmaChamber vault.
Define macro: VT_Vault_MagmaChamber_Open if you want this. [Note: Currently not implemented
*/



#ifndef VT_Option__Use_Long_Namespace
/**
@defgroup VaultedThermals

@brief Main library namespace for Vaulted Thermals (Vulkan Wrapper

@details For long namespace: #define VT_Option__Use_Long_Namespace
*/
namespace VT
#else
/**
@defgroup VaultedThermals
@{

@brief Main library namespace for Vaulted Thermals (Vulkan Wrapper)

@details VT_Option__Use_Long_Namespace in use.
*/
namespace VaultedThermals
#endif
{
	/** 
	@ingroup VaultedThermals
	@defgroup Corridors
	@{

	@brief Contains shared definitions between the vaults.

	@details Namespace: Corridors
	*/
	namespace Corridors {}
	/** @} */

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_MagmaChamber
	@{

	@brief Meta-Loading Setup.

	@details When the heat at the control gate isn't enough.

	Namespace: Vault_MagmaChamber

	@todo #TODO Look into possibly implementing with the Volk library.
	*/
	namespace Vault_MagmaChamber {}
	/** @} */

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_0
	@{

	@brief Backend vault for VaultedThermals

	@details For now only abstracts away OS Platform details and basic meta-structure definitions.
	*/
	namespace V0 { using namespace Corridors; }
	/** @} */

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_1
	@{

	@brief 1:1 Wrapping of Vulkan API

	@details 
	*/
	namespace V1 { using namespace Corridors; }
	/** @} */

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_2
	@{

	@brief Repetitive functionality wrapping.

	@details 
	*/
	namespace V2 { using namespace Corridors; }
	/** @} */

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_3
	@{

	@brief Object-Oriented wrapping

	@details 
	*/
	namespace V3 { using namespace Corridors; }
	/** @} */

#ifdef VT_Open_Vault_4

	/** 
	@ingroup VaultedThermals
	@defgroup Vault_4
	@{

	@brief Object-Oriented bootstrapped backend

	@details 
	*/
	namespace V4 
	{ using namespace Corridors; }
	/** @} */

#endif
}




/*!
@file VT_APISpecGroups.hpp

@brief Vaulted Thermals: Official API Specification Groups
*/



/**
@defgroup API_Specification

@brief The library organized based on the chapters of the Vulkan official specification.

@details
<a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/index.html">Specification</a>
*/

/**
@defgroup APISpec_Introduction
@ingroup API_Specification

@brief Chapter 1: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap2.html">Specification</a>
*/

/**
@defgroup APISpec_Fundamentals
@ingroup API_Specification

@brief Chapter 2: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap3.html">Specification</a>
*/

/**
@defgroup APISpec_Initialization
@ingroup API_Specification

@brief Chapter 3: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap4.html">Specification</a>
*/

/**
@defgroup APISpec_Devices_and_Queues
@ingroup API_Specification

@brief Chapter 4: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap5.html">Specification</a>
*/

/**
@defgroup APISpec_Command_Buffers
@ingroup API_Specification

@brief Chapter 5: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap6.html">Specification</a>
*/

/**
@defgroup APISpec_Synchronization_and_Cache_Control
@ingroup API_Specification

@brief Chapter 6: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap7.html">Specification</a>
*/

/**
@defgroup APISpec_Render_Pass
@ingroup API_Specification

@brief Chapter 7: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap8.html">Specification</a>
*/

/**
@defgroup APISpec_Shaders
@ingroup API_Specification

@brief Chapter 8: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap9.html">Specification</a>
*/

/**
@defgroup APISpec_Pipelines
@ingroup API_Specification

@brief Chapter 9: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap10.html">Specification</a>
*/

/**
@defgroup APISpec_Memory_Allocation
@ingroup API_Specification

@brief Chapter 10: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap11.html">Specification</a>
*/

/**
@defgroup APISpec_Resource_Creation
@ingroup API_Specification

@brief Chapter 11: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap12.html">Specification</a>
*/

/**
@defgroup APISpec_Samplers
@ingroup API_Specification

@brief Chapter 12: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap13.html">Specification</a>
*/

/**
@defgroup APISpec_Resource_Descriptors
@ingroup API_Specification

@brief Chapter 13: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap14.html">Specification</a>
*/

/**
@defgroup APISpec_Shader_Interfaces
@ingroup API_Specification

@brief Chapter 14: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap15.html">Specification</a>
*/

/**
@defgroup APISpec_Image_Operations
@ingroup API_Specification

@brief Chapter 15: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap16.html">Specification</a>
*/

/**
@defgroup APISpec_Fragment_Density_Map_Operations
@ingroup API_Specification

@brief Chapter 16: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap17.html">Specification</a>
*/

/**
@defgroup APISpec_Queries
@ingroup API_Specification

@brief Chapter 17: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap18.html">Specification</a>
*/

/**
@defgroup APISpec_Clear_Commands
@ingroup API_Specification

@brief Chapter 18: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap19.html">Specification</a>
*/

/**
@defgroup APISpec_Copy_Commands
@ingroup API_Specification

@brief Chapter 19: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap20.html">Specification</a>
*/

/**
@defgroup APISpec_Drawing_Commands
@ingroup API_Specification

@brief Chapter 20: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap21.html">Specification</a>
*/

/**
@defgroup APISpec_Fixed-Function_Vertex_Processing
@ingroup API_Specification

@brief Chapter 21: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap22.html">Specification</a>
*/

/**
@defgroup APISpec_Tessellation
@ingroup API_Specification

@brief Chapter 22: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap23.html">Specification</a>
*/

/**
@defgroup APISpec_Geometry_Shading
@ingroup API_Specification

@brief Chapter 23: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap24.html">Specification</a>
*/

/**
@defgroup APISpec_Mesh_Shading
@ingroup API_Specification

@brief Chapter 24: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap25.html">Specification</a>
*/

/**
@defgroup APISpec_Fixed-Function_Vertex_Post-Processing
@ingroup API_Specification

@brief Chapter 25: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap26.html">Specification</a>
*/

/**
@defgroup APISpec_Rasterization
@ingroup API_Specification

@brief Chapter 26: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap27.html">Specification</a>
*/

/**
@defgroup APISpec_Fragment_Operations
@ingroup API_Specification

@brief Chapter 27: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap28.html">Specification</a>
*/

/**
@ingroup API_Specification
@defgroup APISpec_The_Framebuffer

@brief Chapter 28: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap29.html">Specification</a>
*/

/**
@defgroup APISpec_Dispatching_Commands
@ingroup API_Specification

@brief Chapter 29: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap30.html">Specification</a>
*/

/**
@defgroup APISpec_Device-Generated_Commands
@ingroup API_Specification

@brief Chapter 30: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap31.html">Specification</a>
*/

/**
@defgroup APISpec_Sparse_Resources
@ingroup API_Specification

@brief Chapter 31: <a href="https://vulkan.lunarg.com/doc/sdk/lastest/windows/chunked_spec/chap32.html">Specification</a>
*/

/**
@ingroup API_Specification
@defgroup APISpec_Window_System_Integration_WSI

@brief Chapter 32: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap33.html">Specification</a>
*/

/**
@defgroup APISpec_Deferred_Host_Operations
@ingroup API_Specification

@brief Chapter 33: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap34.html">Specification</a>
*/

/**
@defgroup APISpec_Private_Data
@ingroup API_Specification

@brief Chapter 34: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap35.html">Specification</a>
*/

/**
@defgroup APISpec_Ray_Traversal
@ingroup API_Specification

@brief Chapter 35: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap36.html">Specification</a>
*/

/**
@defgroup APISpec_Ray_Tracing
@ingroup API_Specification

@brief Chapter 36: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap37.html">Specification</a>
*/

/**
@defgroup APISpec_Extending_Vulkan
@ingroup API_Specification

@brief Chapter 37: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap38.html">Specification</a>
*/

/**
@defgroup APISpec_Features
@ingroup API_Specification

@brief Chapter 38: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap39.html">Specification</a>
*/

/**
@defgroup APISpec_Limits
@ingroup API_Specification

@brief Chapter 39: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap40.html">Specification</a>
*/

/**
@defgroup APISpec_Formats
@ingroup API_Specification

@brief Chapter 40: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap41.html">Specification</a>
*/

/**
@defgroup APISpec_Additional_Capabilities
@ingroup API_Specification

@brief Chapter 41: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap42.html">Specification</a>
*/

/**
@defgroup APISpec_Debugging
@ingroup API_Specification

@brief Chapter 42: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap43.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-A__Vulkan-Environment_for_SPIR-V
@ingroup API_Specification

@brief Appendix A: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap44.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-B__Memory_Model
@ingroup API_Specification

@brief Appendix B: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap45.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-C__Compressed_Image_Formats
@ingroup API_Specification

@brief Appendix C: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap46.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-D__Core_Revisions_-Informative-
@ingroup API_Specification

@brief Appendix D: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap47.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-E__Layers_and_Extensions_Informative
@ingroup API_Specification

@brief Appendix E: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap48.html">Specification</a>
*/

/**
@defgroup APISpec__Appendix-F__API_Boilerplate
@ingroup API_Specification

@brief Appendix F: <a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/chunked_spec/chap49.html">Specification</a>
*/




/*!
@file VT_Platform.hpp

@brief Vaulted Thermals: Platform Specification

@details The Vulkan C-API header is included here and platform detection implementation is defined.
*/



#pragma region Includes


#ifdef _WIN32

#ifndef VK_USE_PLATFORM_WIN32_KHR
#define VK_USE_PLATFORM_WIN32_KHR 
#endif

#endif

#ifdef __MACH__

#ifdef  VK_USE_PLATFORM_MACOS_MVK
#define VK_USE_PLATFORM_MACOS_MVK
#endif

#endif

#ifdef __linux__

#ifdef  VK_USE_PLATFORM_WAYLAND_KHR
#define VK_USE_PLATFORM_WAYLAND_KHR
#endif

#endif



/** 
@todo
This guard is necessary to prevent redefinition errors. I am not entirely sure with pragma once
specified, why this is required.
*/
#ifndef VT_VULKAN_INCLUDEGUARD
#define VT_VULKAN_INCLUDEGUARD

#include <vulkan/vulkan.h>

#endif



#pragma endregion Includes



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V0
	{
		/**
		@addtogroup Vault_0
		@{
		*/

		/**
		@brief Enum specifies operating system platform.
		*/
		enum class EOS
		{
			Windows, Mac, Linux
		};

	#ifdef _WIN32

		/**
		@brief Contains the definition of the OS_Platform. (Set to windows)
		*/
		constexpr EOS OS_Platform = EOS::Windows;

	#endif

	#ifdef __MACH__

		/**
		@brief Contains the definition of the OS_Platform. (Set to Mac)
		*/
		constexpr EOS OS = EOS::Mac;

	#endif

	#ifdef __linux__

		/**
		@brief Contains the definition of the OS_Platform. (Set to Linux)
		*/
		constexpr EOS OS = EOS::Linux;

	#endif 

		/**  
		@brief Defines maker of platform struct that defines operating system types.
		*/
		template<EOS>
		struct PlatformTypes_Maker;

		template<>
		struct PlatformTypes_Maker<EOS::Linux>
		{
			using OS_Handle = int;
		};


		/** 
		@brief Defines Windows specific types.
		*/	
		template<>
		struct PlatformTypes_Maker<EOS::Windows>
		{
			using OS_AppHandle    = HINSTANCE;
			using OS_WindowHandle = HWND     ;
			using OS_Handle       = HANDLE   ;
		};

		/** 
		* @brief A structure containing the types for the detected platform.
		*/
		using PlatformTypes = PlatformTypes_Maker<OS_Platform>;

		/** @} */

		template<typename FunctionType, FunctionType*>
		struct CallEnforcer_CallMaker;

		/**
		@brief Generates a wrapped call to the function passed to it.
		*/
		template
			<
			typename    ReturnType    ,
			typename... ParameterTypes,

			ReturnType(*FunctionPtr)(ParameterTypes...)
			>
			struct CallEnforcer_CallMaker<ReturnType(ParameterTypes...), FunctionPtr>
		{
			static VKAPI_ATTR ReturnType VKAPI_CALL Call(ParameterTypes... _parameters)
			{
				return FunctionPtr(std::forward<ParameterTypes>(_parameters)...);
			}
		};

		template<typename FunctionType, FunctionType& _functionRef>
		auto GetVulkanAPI_Call()
		{
			return &(CallEnforcer_CallMaker<FunctionType, &_functionRef>::Call);
		}

		/**
		@brief Used to wrap a function with the vulkan calling convention specifiers.
		Used for vulkan messaging callbacks.

		@details
		This is the only intended macro to be used by the user of this library.
		If the user wishes to avoid using this ease of use macro, the actual function call can be made:

		Enforced_Call<decltype(Function), Function>()
		*/
	#define GetVTAPI_Call(_FUNCTION) \
		GetVulkanAPI_Call<decltype(_FUNCTION), _FUNCTION>()
	}

	namespace Corridors
	{
		using V0::GetVulkanAPI_Call;
		using V0::OS_Platform      ;
	}
}




/*!
@file VT_CPP_STL.hpp

@brief C++ STL related definitions
*/



// C++
#include <array>
#include <cstddef>
#include <cstdint>
#include <set>
#include <stdexcept>
#include <typeinfo>
#include <type_traits>



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace Corridors
	{
		/**
		@addtogroup Corridors
		@{
		*/

		// Integers

		// Flexible

		using uint32 = unsigned int;
		using sint32 = signed   int;

		// Strict

		// Signed

		using sInt8  = signed           char;
		using sInt16 = signed short     int ;
		using sInt32 = signed long      int ;
		using sInt64 = signed long long int ;

		// Unsigned

		using uInt8  = unsigned           char;
		using uInt16 = unsigned short     int ;
		using uInt32 = unsigned long      int ;
		using uInt64 = unsigned long long int ;

		// Floats

		using float32 = float ;
		using float64 = double;

		// Data

		using VoidPtr  = void*  ;
		using PtrArray = void*[];

		// RawStrings

		using CStr              =       char*       ;
		using RoCStr            = const char*       ;
		using CStrArray         =       char*      *;
		using RoCStrArray       = const char*      *;   ///< Readonly c-string array.
		using RoArray_of_RoCStr = const char* const*;   ///< Array of readonly array of readonly c-string.



	/** 
	* @brief Containers used for the library are defined here.
	* 
	* @details
	* 
	* If library user decides to implement their own containers they must define containers
	* that function the same as the STL containers used here with the same names.
	*/
	#ifndef VT_Option__Use_Custom_Containers

	#include <deque>
	#include <vector>

		template<class Type>
		/**
		* @brief Typdef of std::deque.
		*/
		using Deque = std::deque<Type>;

		template<class Type>
		/**
		* @brief Typedef of std::vector.
		*/
		using DynamicArray = std::vector<Type>;

	#endif

		/** @} */
	}
}




/*!
@file VT_Enums.hpp

@brief Vaulted Thermals: Enumerations
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
    namespace Corridors
    {
		/**
		@addtogroup Corridors
		@{
		*/

	#pragma region VT_Enums

		/** 
		@enum Undefined Enum
		@brief Necessary for Bitmasks in the Vulkan specification that are not defined but reserved for future use.
		*/
		enum class EUndefined : uint32 { VT_SpecifyBitmaskable = sizeof(uint32) };

		/**
		 * @enum Handle Enum
		 */
		enum class EHandle
		{
			Null = VK_NULL_HANDLE
		};

	#pragma endregion VT_Enums

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAccessFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EAccessFlag : uint32
		{
			IndirectCommandRead                 = VK_ACCESS_INDIRECT_COMMAND_READ_BIT                ,
			IndexRead                           = VK_ACCESS_INDEX_READ_BIT                           ,
			VertexAttributeRead                 = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                ,
			UniformRead                         = VK_ACCESS_UNIFORM_READ_BIT                         ,
			InputAttachmentRead                 = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                ,
			ShaderRead                          = VK_ACCESS_SHADER_READ_BIT                          ,
			ShaderWrite                         = VK_ACCESS_SHADER_WRITE_BIT                         ,
			ColorAttachmentRead                 = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                ,
			ColorAttachmentWrite                = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT               ,
			DepthStencilAttachmentRead          = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT        ,
			DepthStencilAttachmentWrite         = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT       ,
			TransferRead                        = VK_ACCESS_TRANSFER_READ_BIT                        ,
			TransferWrite                       = VK_ACCESS_TRANSFER_WRITE_BIT                       ,
			HostRead                            = VK_ACCESS_HOST_READ_BIT                            ,
			HostWrite                           = VK_ACCESS_HOST_WRITE_BIT                           ,
			MemoryRead                          = VK_ACCESS_MEMORY_READ_BIT                          ,
			MemoryWrite                         = VK_ACCESS_MEMORY_WRITE_BIT                         ,
			TransformFeedback_Write_EXT         = VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT         ,   // Provided by VK_EXT_transform_feedback
			TransformFeedback_CounterRead_EXT   = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT  ,   // Provided by VK_EXT_transform_feedback
			TransformFeedback_CounterWrite_EXT  = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT ,   // Provided by VK_EXT_transform_feedback
			ConditionalRendering_Read_EXT       = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT       ,   // Provided by VK_EXT_conditional_rendering
			ColorAttachment_ReadNoncoherent_EXT = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,   // Provided by VK_EXT_blend_operation_advanced
			AccelerationStructure_Read_KHR      = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR      ,   // Provided by VK_KHR_ray_tracing
			AccelerationStructure_Write_KHR     = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR     ,   // Provided by VK_KHR_ray_tracing
			ShadingRateImage_Read_NV            = VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV           ,   // Provided by VK_NV_shading_rate_image
			FragmentDensityMap_Read_EXT         = VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT        ,   // Provided by VK_EXT_fragment_density_map
			CommandPreprocess_Read_NV           = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV           ,   // Provided by VK_NV_device_generated_commands
			CommandPreprocess_Write_NV          = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV          ,   // Provided by VK_NV_device_generated_commands
			AccelerationStructure_Read_NV       = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV       ,   // Provided by VK_NV_ray_tracing
			AccelerationStructure_Write_NV      = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV      ,   // Provided by VK_NV_ray_tracing

			VT_SpecifyBitmaskable = VK_ACCESS_FLAG_BITS_MAX_ENUM
		};

		/**
		 * @ingroup APISpec_Extending_Vulkan
		 * @enum API_Version
		 * 
		 * @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers">Specification</a> 
		 */
		enum class EAPI_Version
		{
			_1_0 = VK_API_VERSION_1_0,
			_1_1 = VK_API_VERSION_1_1,
			_1_2 = VK_API_VERSION_1_2
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentDescriptionFlagBits">Specification</a> @ingroup APISpec_Render_Pass */
		enum class EAttachmentDescriptionFlag : uint32
		{
			AttachmentDescription_MAY_ALIAS = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,

			VT_SpecifyBitmaskable = VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentLoadOp">Specification</a> @ingroup APISpec_Render_Pass */
		enum class EAttachmentLoadOperation : uint32
		{
			Load     = VK_ATTACHMENT_LOAD_OP_LOAD     , 
			Clear    = VK_ATTACHMENT_LOAD_OP_CLEAR    ,
			DontCare = VK_ATTACHMENT_LOAD_OP_DONT_CARE 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentStoreOp">Specification</a> @ingroup APISpec_Render_Pass */
		enum class EAttachmentStoreOperation : uint32
		{
			Store    = VK_ATTACHMENT_STORE_OP_STORE    ,
			DontCare = VK_ATTACHMENT_STORE_OP_DONT_CARE
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBlendFactor">Specification</a> @ingroup APISpec_The_Framebuffer */
		enum class EBlendFactor : uint32
		{
			Zero                      = VK_BLEND_FACTOR_ZERO                    ,
			One                       = VK_BLEND_FACTOR_ONE                     ,
			SourceColor               = VK_BLEND_FACTOR_SRC_COLOR               ,
			OneMinusOne_SourceColor   = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR     ,
			DesinationColor           = VK_BLEND_FACTOR_DST_COLOR               ,
			OneMinus_DestinationColor = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR     ,
			AlphaSource               = VK_BLEND_FACTOR_SRC_ALPHA               ,
			OneMinus_AlphaSource      = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA     ,
			AlphaDestination          = VK_BLEND_FACTOR_DST_ALPHA               ,
			OneMinus_AlphaDestination = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA     ,
			ConstantColor             = VK_BLEND_FACTOR_CONSTANT_COLOR          ,
			OneMinus_ConstantColor    = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
			ConstantAlpha             = VK_BLEND_FACTOR_CONSTANT_ALPHA          ,
			OneMinus_ConstantAlpha    = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
			SourceAlphaSaturate       = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE      ,
			SourceOne_Color           = VK_BLEND_FACTOR_SRC1_COLOR              ,
			OneMinus_SourceOneColor   = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR    ,
			SourceOneAlpha            = VK_BLEND_FACTOR_SRC1_ALPHA              ,
			OneMinus_SourceOneAlpha   = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA    
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBlendOp">Specification</a> @ingroup APISpec_The_Framebuffer */
		enum class EBlendOperation : uint32
		{
			Add                  = VK_BLEND_OP_ADD                   ,
			Subtract             = VK_BLEND_OP_SUBTRACT              ,
			ReverseSubtract      = VK_BLEND_OP_REVERSE_SUBTRACT      ,
			Mininum              = VK_BLEND_OP_MIN                   ,
			Maximum              = VK_BLEND_OP_MAX                   ,
			Zero_EXT             = VK_BLEND_OP_ZERO_EXT              ,
			Source_EXT           = VK_BLEND_OP_SRC_EXT               ,
			Destination_EXT      = VK_BLEND_OP_DST_EXT               ,
			SourceOver_EXT       = VK_BLEND_OP_SRC_OVER_EXT          ,
			DestinationOver_EXT  = VK_BLEND_OP_DST_OVER_EXT          ,
			SourceIn_EXT         = VK_BLEND_OP_SRC_IN_EXT            ,
			DestinationIN_ET     = VK_BLEND_OP_DST_IN_EXT            ,
			SourceOut_EXT        = VK_BLEND_OP_SRC_OUT_EXT           ,
			DestinationOut_EXT   = VK_BLEND_OP_DST_OUT_EXT           ,
			SourceAtop_EXT       = VK_BLEND_OP_SRC_ATOP_EXT          ,
			DestinationATop_EXT  = VK_BLEND_OP_DST_ATOP_EXT          ,
			XOR_EXT              = VK_BLEND_OP_XOR_EXT               ,
			Multiply_EXT         = VK_BLEND_OP_MULTIPLY_EXT          ,
			Screen_EXT           = VK_BLEND_OP_SCREEN_EXT            ,
			Overlay_EXT          = VK_BLEND_OP_OVERLAY_EXT           ,
			Darken_EXT           = VK_BLEND_OP_DARKEN_EXT            ,
			Lighten_EXT          = VK_BLEND_OP_LIGHTEN_EXT           ,
			ColorDodge_EXT       = VK_BLEND_OP_COLORDODGE_EXT        ,
			ColorBurn_EXT        = VK_BLEND_OP_COLORBURN_EXT         ,
			HardLight_EXT        = VK_BLEND_OP_HARDLIGHT_EXT         ,
			SoftLight_Ext        = VK_BLEND_OP_SOFTLIGHT_EXT         ,
			Difference_Ext       = VK_BLEND_OP_DIFFERENCE_EXT        ,
			Exclusion_Ext        = VK_BLEND_OP_EXCLUSION_EXT         ,
			Invert_Ext           = VK_BLEND_OP_INVERT_EXT            ,
			Invert_RGB_Ext       = VK_BLEND_OP_INVERT_RGB_EXT        ,
			LinearDodge_Ext      = VK_BLEND_OP_LINEARDODGE_EXT       ,
			LinearBurn_Ext       = VK_BLEND_OP_LINEARBURN_EXT        ,
			VividLight_Ext       = VK_BLEND_OP_VIVIDLIGHT_EXT        ,
			LinearLight_Ext      = VK_BLEND_OP_LINEARLIGHT_EXT       ,
			PinLight_Ext         = VK_BLEND_OP_PINLIGHT_EXT          ,
			Hardmix_Ext          = VK_BLEND_OP_HARDMIX_EXT           ,
			HSL_Hue_Ext          = VK_BLEND_OP_HSL_HUE_EXT           ,
			HSL_Saturation_Ext   = VK_BLEND_OP_HSL_SATURATION_EXT    ,
			HSL_Color_Ext        = VK_BLEND_OP_HSL_COLOR_EXT         ,
			HSL_Luminosity_Ext   = VK_BLEND_OP_HSL_LUMINOSITY_EXT    ,
			Plus_Ext             = VK_BLEND_OP_PLUS_EXT              ,
			PlusClamped_Ext      = VK_BLEND_OP_PLUS_CLAMPED_EXT      ,
			PlusClampedAlpha_Ext = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
			PlusDarker_EXT       = VK_BLEND_OP_PLUS_DARKER_EXT       ,
			Minus_EXT            = VK_BLEND_OP_MINUS_EXT             ,
			MinusClamped_EXT     = VK_BLEND_OP_MINUS_CLAMPED_EXT     ,
			Constrast_EXT        = VK_BLEND_OP_CONTRAST_EXT          ,
			InvertOVG_EXT        = VK_BLEND_OP_INVERT_OVG_EXT        ,
			Red_EXT              = VK_BLEND_OP_RED_EXT               ,
			Green_EXT            = VK_BLEND_OP_GREEN_EXT             ,
			Blue_EXT             = VK_BLEND_OP_BLUE_EXT
		};

		/**
		 * @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-commandsyntax">Specification</a> 
		 * 
		 * @ingroup APISpec_Fundamentals
		 */
		enum EBool
		{
			True  = VK_TRUE ,
			False = VK_FALSE
		};

		/** 
		@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBorderColor">Specification</a>  

		@ingroup APISpec_Samplers
		*/
		enum EBorderColor : uint32
		{
			Float_TransparentBlack = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
			Int_TransparentBlack   = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK  ,
			Float_OpaqueBlack      = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK     , 
			Int_OpaqueBlack        = VK_BORDER_COLOR_INT_OPAQUE_BLACK       , 
			Float_OpaqueWhite      = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE     , 
			Int_OpaqueWhite        = VK_BORDER_COLOR_INT_OPAQUE_WHITE       , 

			// Provided by VK_EXT_custom_border_color
			Float_Custom_EXT = VK_BORDER_COLOR_FLOAT_CUSTOM_EXT,

			// Provided by VK_EXT_custom_border_color
			Int_Custom_EXT = VK_BORDER_COLOR_INT_CUSTOM_EXT,
		};

		/**
		 * @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferCreateFlagBits">Specification</a> 
		 * 
		 * @ingroup APISpec_Resource_Creation
		 */
		enum class EBufferCreateFlag : uint32
		{
			SparseBinding                       = VK_BUFFER_CREATE_SPARSE_BINDING_BIT                   ,
			SparseResidency                     = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT                 ,
			SparseAliased                       = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                   ,
			Protected                           = VK_BUFFER_CREATE_PROTECTED_BIT                        ,
			DeviceAddressCaptureReplay          = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT    ,
			DeviceAddressCaptureReplayExtension = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
			DeviceAddressCaptureReplayKHR       = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,

			VT_SpecifyBitmaskable = VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferUsageFlagBits">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EBufferUsage : uint32
		{
			TransferSource      = VK_BUFFER_USAGE_TRANSFER_SRC_BIT        ,
			TransferDestination = VK_BUFFER_USAGE_TRANSFER_DST_BIT        ,
			UniformTexelBuffer  = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
			StorageTexelBuffer  = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
			UniformBuffer       = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT      ,
			StorageBuffer       = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT      ,
			IndexBuffer         = VK_BUFFER_USAGE_INDEX_BUFFER_BIT        ,
			VertexBuffer        = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT       ,
			IndirectBuffer      = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT     ,

			VT_SpecifyBitmaskable = VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkColorComponentFlagBits">Specification</a> @ingroup APISpec_The_Framebuffer */
		enum class EColorComponentFlag : uint32
		{
			R = VK_COLOR_COMPONENT_R_BIT,
			G = VK_COLOR_COMPONENT_G_BIT,
			B = VK_COLOR_COMPONENT_B_BIT,
			A = VK_COLOR_COMPONENT_A_BIT,

			VT_SpecifyBitmaskable = VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkColorSpaceKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
		enum class EColorSpace : uint32
		{
			SRGB_NonLinear                   = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR         ,
			NonLinear_Display_P3             = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT   ,
			ExtendedSRGB_Linear              = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT   ,
			Display_P3_LInear                = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT      ,
			DCI_P3_NonLinear                 = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT       ,
			BT709_Linear                     = VK_COLOR_SPACE_BT709_LINEAR_EXT           ,
			BT709_NonLinear                  = VK_COLOR_SPACE_BT709_NONLINEAR_EXT        ,
			BT2020_Linear                    = VK_COLOR_SPACE_BT2020_LINEAR_EXT          ,
			Extensions_HDR_ST2084            = VK_COLOR_SPACE_HDR10_ST2084_EXT           ,
			Extension_DoblyVision            = VK_COLOR_SPACE_DOLBYVISION_EXT            ,
			HDR10_HLG                        = VK_COLOR_SPACE_HDR10_HLG_EXT              ,
			AdobeRGB_Linear                  = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT        ,
			AdobeRGB_NonLinear               = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT     ,
			Extension_PassThrough            = VK_COLOR_SPACE_PASS_THROUGH_EXT           ,
			Extension_ExtendedSRGB_NonLinear = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
			AMD_Native                       = VK_COLOR_SPACE_DISPLAY_NATIVE_AMD         ,
			KHR_SRGB_NonLinear               = VK_COLORSPACE_SRGB_NONLINEAR_KHR          ,
			Extension_DCI_P3_Linear          = VK_COLOR_SPACE_DCI_P3_LINEAR_EXT          ,
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferLevel">Specification</a> @ingroup APISpec_Command_Buffers */
		enum class ECommandBufferLevel
		{
			Primary   = VK_COMMAND_BUFFER_LEVEL_PRIMARY  ,
			Secondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferResetFlagBits ">Specification</a> @ingroup APISpec_Command_Buffers */
		enum class ECommandBufferResetFlag : uInt32
		{
			ReleaseResources = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,

			VT_SpecifyBitmaskable = VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferResetFlagBits">Specification</a> @ingroup APISpec_Command_Buffers */
		enum class ECommandBufferUsageFlag : uint32
		{
			OneTimeSubmit      = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT     ,
			RenderPassContinue = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
			SimultaneousUse    = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT    ,

			VT_SpecifyBitmaskable = VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolCreateFlagBits">Specification</a> @ingroup APISpec_Command_Buffers */
		enum class ECommandPoolCreateFlag : uint32
		{
			Transient          = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT           ,
			ResetCommandBuffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
			Protected          = VK_COMMAND_POOL_CREATE_PROTECTED_BIT           ,

			VT_SpecifyBitmaskable = VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolResetFlagBits">Specification</a> @ingroup APISpec_Command_Buffers */
		enum class ECommandPoolResetFlags : uInt32
		{
			ReleaseResources = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,

			VT_SpecifyBitmaskable = VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkComponentSwizzle">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EComponentSwizzle : uint32
		{
			Identitity = VK_COMPONENT_SWIZZLE_IDENTITY,
			Zero       = VK_COMPONENT_SWIZZLE_ZERO    ,
			One        = VK_COMPONENT_SWIZZLE_ONE     ,
			R          = VK_COMPONENT_SWIZZLE_R       ,
			G          = VK_COMPONENT_SWIZZLE_G       ,
			B          = VK_COMPONENT_SWIZZLE_B       ,
			A          = VK_COMPONENT_SWIZZLE_A       ,
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCompositeAlphaFlagBitsKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
		enum class ECompositeAlpha : uint32
		{
			Opaque         = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          ,
			PreMultiplied  = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  ,
			PostMultiplied = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR ,
			Inherit        = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         ,

			VT_SpecifyBitmaskable = VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCompareOp">Specification</a> @ingroup APISpec_Fragment_Operations */
		enum class ECompareOperation : uint32
		{
			Never          = VK_COMPARE_OP_NEVER           ,
			Less           = VK_COMPARE_OP_LESS            ,
			Equal          = VK_COMPARE_OP_EQUAL           ,
			LessOrEqual    = VK_COMPARE_OP_LESS_OR_EQUAL   ,
			Greater        = VK_COMPARE_OP_GREATER         ,
			NotEqual       = VK_COMPARE_OP_NOT_EQUAL       ,
			GreaterOrEqual = VK_COMPARE_OP_GREATER_OR_EQUAL,
			Always         = VK_COMPARE_OP_ALWAYS
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCullModeFlagBits">Specification</a> @ingroup APISpec_Rasterization */
		enum class ECullModeFlag : uint32
		{
			None           = VK_CULL_MODE_NONE          ,
			Front          = VK_CULL_MODE_FRONT_BIT     ,
			Back           = VK_CULL_MODE_BACK_BIT      ,
			Front_And_Back = VK_CULL_MODE_FRONT_AND_BACK,

			VT_SpecifyBitmaskable = VK_CULL_MODE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessageSeverityFlagBitsEXT">Specification</a> @ingroup APISpec_Debugging */
		enum class EDebugUtils_MessageSeverity : uint32
		{
			Verbose = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
			Info    = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT   ,
			Warning = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
			Error   = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT  ,

			VT_SpecifyBitmaskable = VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessageTypeFlagBitsEXT">Specification</a> @ingroup APISpec_Debugging */
		enum class EDebugUtils_MessageType : uint32
		{
			General     = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT    ,
			Validation  = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT ,
			Performance = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,

			VT_SpecifyBitmaskable = VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDependencyFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EDependencyFlag : uint32
		{
			ByRegion = VK_DEPENDENCY_BY_REGION_BIT,

			VT_SpecifyBitmaskable = VK_DEPENDENCY_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorBindingFlagBits">Specification</a> @ingroup APISpec_Resource_Descriptors */
		enum class EDescriptorBindingFlag : uint32
		{
			UpdateAfterBind              = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT              ,
			UpdateUnusedWhilePending     = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT    ,
			PartiallyBound               = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT                ,
			VariableDescriptorCount      = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT      ,
			UpdateAfterBind_EXT          = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT          ,
			UpdateUnusedWhilePending_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
			PartiallyBound_EXT           = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT            ,
			VariableDescriptorCount_EXT  = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT  ,

			VT_SpecifyBitmaskable = VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPoolCreateFlagBits">Specification</a> @ingroup APISpec_Resource_Descriptors */
		enum class EDescriptorPoolCreateFlag : uint32
		{
			FreeDescriptorSet   = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT  ,
			UpdateAfterBind     = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT    ,
			UpdateAfterBind_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,

			VT_SpecifyBitmaskable = VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateFlagBits">Specification</a> @ingroup APISpec_Resource_Descriptors */
		enum class EDescriptorSetLayoutCreateFlag : uint32
		{
			UpdateAfterBindPool           = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT    ,
			PushDescriptor                = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR       ,
			UpdateAfterBindPool_Extension = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,

			VT_SpecifyBitmaskable = VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorType">Specification</a> @ingroup APISpec_Resource_Descriptors */
		enum class EDescriptorType : uint32
		{
			Sampler                      = VK_DESCRIPTOR_TYPE_SAMPLER                   ,
			CombinedImageSampler         = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER    ,
			SampledImage                 = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE             ,
			StorageImage                 = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE             ,
			UniformTexelBuffer           = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER      ,
			StorageTexelBuffer           = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER      ,
			UniformBuffer                = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER            ,
			StorageBuffer                = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER            ,
			UniformBufferDynamic         = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC    ,
			StorageBufferDynamic         = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC    ,
			InputAttachment              = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT          ,
			InlineUniformBlock_Extension = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT  ,
			AccelerationStructure_KHR    = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
			AccelerationStructure_NV     = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceDiagnosticsConfigFlagBitsNV">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EDeviceDiagnosticConfigFlag : uint32
		{
			EnableShaderDebugInfo      = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV    , 
			EnableResourceTracking     = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV    , 
			EnableAutomaticCheckpoints = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV,

			VT_SpecifyBitmaskable = VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueCreateFlagBits">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EDeviceQueueCreateFlag : uint32
		{
			// Provided by VK_VERSION_1_1
			Protected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,

			VT_SpecifyBitmaskable = VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceEventTypeEXT">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EDeviceEventType : uint32
		{
			DisplayHotPlug_ = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDisplayEventTypeEXT">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EDisplayEventType : uint32
		{
			FirstPixelOut_EXT = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT
		};

		/**
		* @details
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDriverId">Specification</a> 
		* 
		* @ingroup APISpec_Devices_and_Queues
		*/
		enum class EDriverID
		{
			Proprietary             = VK_DRIVER_ID_AMD_PROPRIETARY          ,
			OpenSource              = VK_DRIVER_ID_AMD_OPEN_SOURCE          ,
			Mesa_RADV               = VK_DRIVER_ID_MESA_RADV                ,
			NvidiaProprietary       = VK_DRIVER_ID_NVIDIA_PROPRIETARY       ,
			IntelProprietaryWindows = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
			IntelOpenSourceMesa     = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA   ,
			ImaginationProprietary  = VK_DRIVER_ID_IMAGINATION_PROPRIETARY  ,
			QualcommProprietary     = VK_DRIVER_ID_QUALCOMM_PROPRIETARY     ,
			ARM_Proprietary         = VK_DRIVER_ID_ARM_PROPRIETARY          ,
			GoogleSwiftShader       = VK_DRIVER_ID_GOOGLE_SWIFTSHADER       ,
			GGP_Proprietary         = VK_DRIVER_ID_GGP_PROPRIETARY          ,
			BroadcomProprietary     = VK_DRIVER_ID_BROADCOM_PROPRIETARY     ,
			MESA_LLLVM_Pipe         = VK_DRIVER_ID_MESA_LLVMPIPE            ,
			//MoltenVK                = VK_DRIVER_ID_MOLTENVK                 ,

			// Provided by VK_KHR_driver_properties
			AMD_Proprietary_KHR         = VK_DRIVER_ID_AMD_PROPRIETARY_KHR          ,
			AMD_OpenSource_KHR          = VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR          ,
			Mesa_RADV_KHR               = VK_DRIVER_ID_MESA_RADV_KHR                ,
			NvidiaProprietary_KHR       = VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR       ,
			IntelProprietaryWindows_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
			IntelOpenSourceMesa_KHR     = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR   ,
			Imagination_Proprietary_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR  ,
			QualCommProprietary_KHR     = VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR     ,
			ARM_Proprietary_KHR         = VK_DRIVER_ID_ARM_PROPRIETARY_KHR          ,
			GoogleSwiftShader_KHR       = VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR       ,
			GGP_Proprietary_KHR         = VK_DRIVER_ID_GGP_PROPRIETARY_KHR          ,
			BroadcomProprietary_KHR     = VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR     ,
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDynamicState">Specification</a> @ingroup APISpec_Pipelines */
		enum class EDynamicState : uint32
		{
			Viewport                      = VK_DYNAMIC_STATE_VIEWPORT                        ,
			Scissor                       = VK_DYNAMIC_STATE_SCISSOR                         ,
			LineWidth                     = VK_DYNAMIC_STATE_LINE_WIDTH                      ,
			DepthBias                     = VK_DYNAMIC_STATE_DEPTH_BIAS                      ,
			BlendConstants                = VK_DYNAMIC_STATE_BLEND_CONSTANTS                 ,
			DepthBounds                   = VK_DYNAMIC_STATE_DEPTH_BOUNDS                    ,
			StencilCompareMask            = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK            ,
			StencilWriteMask              = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK              ,
			StencilReference              = VK_DYNAMIC_STATE_STENCIL_REFERENCE               ,
			Viewport_W_Scaling_NV         = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV           ,
			DiscardRectangle_Extension    = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT           ,
			SampleLocations_Extension     = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT            ,
			ViewportShadingRatePalette_NV = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
			ViewportCoarseSampleOrder_NV  = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV ,
			ExclusiveScissor_NV           = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV            ,
			LineStipple_Extension         = VK_DYNAMIC_STATE_LINE_STIPPLE_EXT                
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExternalFenceHandleTypeFlagBits">Specification</a> @ingroup APISpec_Additional_Capabilities */
		enum class EExternalFenceHandleTypeFlag : uint32
		{
			OpaqueFD             = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT           ,
			Opaque_Win32         = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT        ,
			Opaque_Win32_KMT     = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT    ,
			SyncFD               = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT             ,
			OpaqueFD_KHR         = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR       ,   // Provided by VK_KHR_external_fence_capabilities
			Opaque_Win32_KHR     = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR    ,   // Provided by VK_KHR_external_fence_capabilities
			Opaque_Win32_KMT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,   // Provided by VK_KHR_external_fence_capabilities
			SyncFD_KHR           = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR         ,   // Provided by VK_KHR_external_fence_capabilities

			VT_SpecifyBitmaskable = VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExternalSemaphoreHandleTypeFlagBits">Specification</a> @ingroup APISpec_Additional_Capabilities */
		enum class EExternalSemaphoreHandleTypeFlag : uint32
		{
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
			// Provided by VK_KHR_external_semaphore_capabilities
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
			// Provided by VK_KHR_external_semaphore_capabilities
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
			// Provided by VK_KHR_external_semaphore_capabilities
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
			// Provided by VK_KHR_external_semaphore_capabilities
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
			// Provided by VK_KHR_external_semaphore_capabilities
			VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,

			VT_SpecifyBitmaskable = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceCreateFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EFenceCreateFlag : uint32
		{
			Signaled = VK_FENCE_CREATE_SIGNALED_BIT,

			VT_SpecifyBitmaskable = VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceImportFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EFenceImportFlag
		{
			Temporary     = VK_FENCE_IMPORT_TEMPORARY_BIT    ,   // Provided by VK_KHR_external_fence
			Temporary_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,

			VT_SpecifyBitmaskable = VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFilter">Specification</a> @ingroup APISpec_Samplers */
		enum class EFilter : uint32
		{
			Nearest   = VK_FILTER_NEAREST  ,
			Linear    = VK_FILTER_LINEAR   ,
			Cubic     = VK_FILTER_CUBIC_IMG,
			Cubic_EXT = VK_FILTER_CUBIC_EXT 
		};

		/**
		 * @brief Supported buffer and image formats.
		 * 
		 * @details
		 * <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#formats">Specification</a> 
		 * 
		 * @ingroup APISpec_Formats
		 */
		enum class EFormat : uint32
		{
			Undefined                                            = VK_FORMAT_UNDEFINED                                     ,
			R4_G4_UNormalized_8Pack                              = VK_FORMAT_R4G4_UNORM_PACK8                              ,
			R4_G4_B4_A4_UNormalized_16Pack                       = VK_FORMAT_R4G4B4A4_UNORM_PACK16                         ,
			B4_G4_R4_A4_UNormalized_16Pack                       = VK_FORMAT_B4G4R4A4_UNORM_PACK16                         ,
			R5_G6_B5_UNormalized_16Pack                          = VK_FORMAT_R5G6B5_UNORM_PACK16                           ,
			B5_G6_R5_UNormalized_16Pack                          = VK_FORMAT_B5G6R5_UNORM_PACK16                           ,
			R5_G5_B5_1A_UNormalized_16Pack                       = VK_FORMAT_R5G5B5A1_UNORM_PACK16                         ,
			B5_G5_R5_A1_UNormalized_16Pack                       = VK_FORMAT_B5G5R5A1_UNORM_PACK16                         ,
			A1_R5_G5_B5_UNormalized_16Pack                       = VK_FORMAT_A1R5G5B5_UNORM_PACK16                         ,
			R8_UNormalized                                       = VK_FORMAT_R8_UNORM                                      ,
			R8_SNormalized                                       = VK_FORMAT_R8_SNORM                                      ,
			R8_UScaled                                           = VK_FORMAT_R8_USCALED                                    ,
			R8_SScaled                                           = VK_FORMAT_R8_SSCALED                                    ,
			R8_UInt                                              = VK_FORMAT_R8_UINT                                       ,
			R8_SInt                                              = VK_FORMAT_R8_SINT                                       ,
			R8_SRGB                                              = VK_FORMAT_R8_SRGB                                       ,
			R8_G8_UNormalized                                    = VK_FORMAT_R8G8_UNORM                                    ,
			R8_G8_SNormalized                                    = VK_FORMAT_R8G8_SNORM                                    ,
			R8_G8_UScaled                                        = VK_FORMAT_R8G8_USCALED                                  ,
			R8_G8_SScaled                                        = VK_FORMAT_R8G8_SSCALED                                  ,
			R8_G8_UInt                                           = VK_FORMAT_R8G8_UINT                                     ,
			R8_G8_SInt                                           = VK_FORMAT_R8G8_SINT                                     ,
			R8_G8_SRGB                                           = VK_FORMAT_R8G8_SRGB                                     ,
			R8_G8_B8_UNormalized                                 = VK_FORMAT_R8G8B8_UNORM                                  ,
			R8_G8_B8_SNormalized                                 = VK_FORMAT_R8G8B8_SNORM                                  ,
			R8_G8_B8_UScaled                                     = VK_FORMAT_R8G8B8_USCALED                                ,
			R8_G8_B8_SScaled                                     = VK_FORMAT_R8G8B8_SSCALED                                ,
			R8_G8_B8_UInt                                        = VK_FORMAT_R8G8B8_UINT                                   ,
			R8_G8_B8_SInt                                        = VK_FORMAT_R8G8B8_SINT                                   ,
			R8_G8_B8_SRGB                                        = VK_FORMAT_R8G8B8_SRGB                                   ,
			B8_G8_R8_UNormalized                                 = VK_FORMAT_B8G8R8_UNORM                                  ,
			B8_G8_R8_SNormalized                                 = VK_FORMAT_B8G8R8_SNORM                                  ,
			B8_G8_R8_UScaled                                     = VK_FORMAT_B8G8R8_USCALED                                ,
			B8_G8_R8_SScaled                                     = VK_FORMAT_B8G8R8_SSCALED                                ,
			B8_G8_R8_UInt                                        = VK_FORMAT_B8G8R8_UINT                                   ,
			B8_G8_R8_SInt                                        = VK_FORMAT_B8G8R8_SINT                                   ,
			B8_G8_R8_SRGB                                        = VK_FORMAT_B8G8R8_SRGB                                   ,
			R8_G8_B8_A8_UNormalized                              = VK_FORMAT_R8G8B8A8_UNORM                                ,
			R8_G8_B8_A8_SNormalized                              = VK_FORMAT_R8G8B8A8_SNORM                                ,
			R8_G8_B8_A8_UScaled                                  = VK_FORMAT_R8G8B8A8_USCALED                              ,
			R8_G8_B8_A8_SScaled                                  = VK_FORMAT_R8G8B8A8_SSCALED                              ,
			R8_G8_B8_A8_UInt                                     = VK_FORMAT_R8G8B8A8_UINT                                 ,
			R8_G8_B8_A8_SInt                                     = VK_FORMAT_R8G8B8A8_SINT                                 ,
			R8_G8_B8_A8_SRGB                                     = VK_FORMAT_R8G8B8A8_SRGB                                 ,
			B8_G8_R8_A8_UNormalized                              = VK_FORMAT_B8G8R8A8_UNORM                                ,
			B8_G8_R8_A8_SNormalized                              = VK_FORMAT_B8G8R8A8_SNORM                                ,
			B8_G8_R8_A8_UScaled                                  = VK_FORMAT_B8G8R8A8_USCALED                              ,
			B8_G8_R8_A8_SScaled                                  = VK_FORMAT_B8G8R8A8_SSCALED                              ,
			B8_G8_R8_A8_Uint                                     = VK_FORMAT_B8G8R8A8_UINT                                 ,
			B8_G8_R8_A8_SInt                                     = VK_FORMAT_B8G8R8A8_SINT                                 ,
			B8_G8_R8_A8_SRGB                                     = VK_FORMAT_B8G8R8A8_SRGB                                 ,
			A8_B8_G8_R8_UNormalized_Pack32                       = VK_FORMAT_A8B8G8R8_UNORM_PACK32                         ,
			A8_B8_G8_R8_SNormalized_Pack32                       = VK_FORMAT_A8B8G8R8_SNORM_PACK32                         ,
			A8_B8_G8_R8_UScaled_Pack32                           = VK_FORMAT_A8B8G8R8_USCALED_PACK32                       ,
			A8_B8_G8_R8_SScaled_Pack32                           = VK_FORMAT_A8B8G8R8_SSCALED_PACK32                       ,
			A8_B8_G8_R8_UInt_Pack32                              = VK_FORMAT_A8B8G8R8_UINT_PACK32                          ,
			A8_B8_G8_R8_SInt_Pack32                              = VK_FORMAT_A8B8G8R8_SINT_PACK32                          ,
			A8_B8_G8_R8_SRGB_Pack32                              = VK_FORMAT_A8B8G8R8_SRGB_PACK32                          ,
			A2_R10_G10_B10_UNormalized_Pack32                    = VK_FORMAT_A2R10G10B10_UNORM_PACK32                      ,
			A2_R10_G10_B10_SNormalized_Pack32                    = VK_FORMAT_A2R10G10B10_SNORM_PACK32                      ,
			A2_R10_G10_B10_UScaled_Pack32                        = VK_FORMAT_A2R10G10B10_USCALED_PACK32                    ,
			A2_R10_G10_B10_SScaled_Pack32                        = VK_FORMAT_A2R10G10B10_SSCALED_PACK32                    ,
			A2_R10_G10_B10_UInt_Pack32                           = VK_FORMAT_A2R10G10B10_UINT_PACK32                       ,
			A2_R10_G10_B10_SInt_Pack32                           = VK_FORMAT_A2R10G10B10_SINT_PACK32                       ,
			A2_B10_G10_R10_UNormalized_Pack32                    = VK_FORMAT_A2B10G10R10_UNORM_PACK32                      ,
			A2_B10_G10_R10_SNormalized_Pack32                    = VK_FORMAT_A2B10G10R10_SNORM_PACK32                      ,
			A2_B10_G10_R10_UScaled_Pack32                        = VK_FORMAT_A2B10G10R10_USCALED_PACK32                    ,
			A2_B10_G10_R10_SScaled_Pack32                        = VK_FORMAT_A2B10G10R10_SSCALED_PACK32                    ,
			A2_B10_G10_R10_UInt_Pack32                           = VK_FORMAT_A2B10G10R10_UINT_PACK32                       ,
			A2_B10_G10_R10_SInt_Pack32                           = VK_FORMAT_A2B10G10R10_SINT_PACK32                       ,
			R16_UNormalized                                      = VK_FORMAT_R16_UNORM                                     ,
			R16_SNormalized                                      = VK_FORMAT_R16_SNORM                                     ,
			R16_UScaled                                          = VK_FORMAT_R16_USCALED                                   ,
			R16_SScaled                                          = VK_FORMAT_R16_SSCALED                                   ,
			R16_UInt                                             = VK_FORMAT_R16_UINT                                      ,
			R16_SInt                                             = VK_FORMAT_R16_SINT                                      ,
			R16_SFloat                                           = VK_FORMAT_R16_SFLOAT                                    ,
			R16_G16_UNormalized                                  = VK_FORMAT_R16G16_UNORM                                  ,
			R16_G16_SNormalized                                  = VK_FORMAT_R16G16_SNORM                                  ,
			R16_G16_UScaled                                      = VK_FORMAT_R16G16_USCALED                                ,
			R16_G16_SScaled                                      = VK_FORMAT_R16G16_SSCALED                                ,
			R16_G16_UInt                                         = VK_FORMAT_R16G16_UINT                                   ,
			R16_G16_SInt                                         = VK_FORMAT_R16G16_SINT                                   ,
			R16_G16_SFloat                                       = VK_FORMAT_R16G16_SFLOAT                                 ,
			R16_G16_B16_UNormalized                              = VK_FORMAT_R16G16B16_UNORM                               ,
			R16_G16_B16_SNormalized                              = VK_FORMAT_R16G16B16_SNORM                               ,
			R16_G16_B16_UScaled                                  = VK_FORMAT_R16G16B16_USCALED                             ,
			R16_G16_B16_SScaled                                  = VK_FORMAT_R16G16B16_SSCALED                             ,
			R16_G16_B16_UInt                                     = VK_FORMAT_R16G16B16_UINT                                ,
			R16_G16_B16_SInt                                     = VK_FORMAT_R16G16B16_SINT                                ,
			R16_G16_B16_SFloat                                   = VK_FORMAT_R16G16B16_SFLOAT                              ,
			R16_G16_B16_A16_UNormalized                          = VK_FORMAT_R16G16B16A16_UNORM                            ,
			R16_G16_B16_A16_SNormalized                          = VK_FORMAT_R16G16B16A16_SNORM                            ,
			R16_G16_B16_A16_UScaled                              = VK_FORMAT_R16G16B16A16_USCALED                          ,
			R16_G16_B16_A16_SScaled                              = VK_FORMAT_R16G16B16A16_SSCALED                          ,
			R16_G16_B16_A16_UInt                                 = VK_FORMAT_R16G16B16A16_UINT                             ,
			R16_G16_B16_A16_SInt                                 = VK_FORMAT_R16G16B16A16_SINT                             ,
			R16_G16_B16_A16_SFloat                               = VK_FORMAT_R16G16B16A16_SFLOAT                           ,
			R32_UInt                                             = VK_FORMAT_R32_UINT                                      ,
			R32_SInt                                             = VK_FORMAT_R32_SINT                                      ,
			R32_SFloat                                           = VK_FORMAT_R32_SFLOAT                                    ,
			R32_G32_UInt                                         = VK_FORMAT_R32G32_UINT                                   ,
			R32_G32_SInt                                         = VK_FORMAT_R32G32_SINT                                   ,
			R32_G32_SFloat                                       = VK_FORMAT_R32G32_SFLOAT                                 ,
			R32_G32_B32_UInt                                     = VK_FORMAT_R32G32B32_UINT                                ,
			R32_G32_B32_Sint                                     = VK_FORMAT_R32G32B32_SINT                                ,
			R32_G32_B32_SFloat                                   = VK_FORMAT_R32G32B32_SFLOAT                              ,
			R32_G32_B32_A32_UInt                                 = VK_FORMAT_R32G32B32A32_UINT                             ,
			R32_G32_B32_A32_SInt                                 = VK_FORMAT_R32G32B32A32_SINT                             ,
			R32_G32_B32_A32_SFloat                               = VK_FORMAT_R32G32B32A32_SFLOAT                           ,
			R64_Uint                                             = VK_FORMAT_R64_UINT                                      ,
			R64_SInt                                             = VK_FORMAT_R64_SINT                                      ,
			R64_SFloat                                           = VK_FORMAT_R64_SFLOAT                                    ,
			R64_G64_UInt                                         = VK_FORMAT_R64G64_UINT                                   ,
			R64_G64_SInt                                         = VK_FORMAT_R64G64_SINT                                   ,
			R64_G64_SFloat                                       = VK_FORMAT_R64G64_SFLOAT                                 ,
			R64_G64_B64_UInt                                     = VK_FORMAT_R64G64B64_UINT                                ,
			R64_G64_B64_SInt                                     = VK_FORMAT_R64G64B64_SINT                                ,
			R64_G64_B64_SFloat                                   = VK_FORMAT_R64G64B64_SFLOAT                              ,
			R64_G64_B64_A64_UInt                                 = VK_FORMAT_R64G64B64A64_UINT                             ,
			R64_G64_B64_A64_SInt                                 = VK_FORMAT_R64G64B64A64_SINT                             ,
			R64_G64_B64_A64_SFloat                               = VK_FORMAT_R64G64B64A64_SFLOAT                           ,
			B10_G11_R11_UFloat_Pack32                            = VK_FORMAT_B10G11R11_UFLOAT_PACK32                       ,
			E5_B9_G9_R9_UFloat_Pack32                            = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                        ,
			D16_UNormalized                                      = VK_FORMAT_D16_UNORM                                     ,
			X8_D24_UNormalized_Pack32                            = VK_FORMAT_X8_D24_UNORM_PACK32                           ,
			D32_SFloat                                           = VK_FORMAT_D32_SFLOAT                                    ,
			S8_UInt                                              = VK_FORMAT_S8_UINT                                       ,
			D16_UNormalized_S8_UInt                              = VK_FORMAT_D16_UNORM_S8_UINT                             ,
			D24_UNormalized_S8_UInt                              = VK_FORMAT_D24_UNORM_S8_UINT                             ,
			D32_SFloat_S8_UInt                                   = VK_FORMAT_D32_SFLOAT_S8_UINT                            ,
			BC1_RGB_UNormalized_Block                            = VK_FORMAT_BC1_RGB_UNORM_BLOCK                           ,
			BC1_RGB_SRGB_Block                                   = VK_FORMAT_BC1_RGB_SRGB_BLOCK                            ,
			BC1_RGBA_Unormalized_Block                           = VK_FORMAT_BC1_RGBA_UNORM_BLOCK                          ,
			BC1_RGBA_SRGB_Block                                  = VK_FORMAT_BC1_RGBA_SRGB_BLOCK                           ,
			BC2_UNormalized_Block                                = VK_FORMAT_BC2_UNORM_BLOCK                               ,
			BC2_SRGB_Block                                       = VK_FORMAT_BC2_SRGB_BLOCK                                ,
			BC3_UNormalized_Block                                = VK_FORMAT_BC3_UNORM_BLOCK                               ,
			BC3_SRGB_Block                                       = VK_FORMAT_BC3_SRGB_BLOCK                                ,
			BC4_UNormalized_Block                                = VK_FORMAT_BC4_UNORM_BLOCK                               ,
			BC4_SNormalized_Block                                = VK_FORMAT_BC4_SNORM_BLOCK                               ,
			BC5_UNormalized_Block                                = VK_FORMAT_BC5_UNORM_BLOCK                               ,
			BC5_SNormalized_Block                                = VK_FORMAT_BC5_SNORM_BLOCK                               ,
			BC6H_UFloat_Block                                    = VK_FORMAT_BC6H_UFLOAT_BLOCK                             ,
			BC6H_SFloat_Block                                    = VK_FORMAT_BC6H_SFLOAT_BLOCK                             ,
			BC7_UNormalized_Block                                = VK_FORMAT_BC7_UNORM_BLOCK                               ,
			BC7_SRGB_Block                                       = VK_FORMAT_BC7_SRGB_BLOCK                                ,
			ETC2_R8_G8_B8_UNormalized_Block                      = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                       ,
			ETC2_R8_G8_B8_SRGB_Block                             = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                        ,
			ETC2_R8_G8_B8_A1_UNormalized_Block                   = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                     ,
			ETC2_R8_G8_B8_A1_Block                               = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                      ,
			ETC_2_R8_G8_B8_A8_UNormalized_Block                  = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                     ,
			ETC2_R8_G8_B8_A8_SRGB_Block                          = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                      ,
			EAC_R11_UNormalized_Block                            = VK_FORMAT_EAC_R11_UNORM_BLOCK                           ,
			EAC_R11_SNormalized_Block                            = VK_FORMAT_EAC_R11_SNORM_BLOCK                           ,
			EAC_R11_G11_UNormalized_Block                        = VK_FORMAT_EAC_R11G11_UNORM_BLOCK                        ,
			EAC_R11_G11_SNormalized_Block                        = VK_FORMAT_EAC_R11G11_SNORM_BLOCK                        ,
			ASTC_4x4_UNormalized_Block                           = VK_FORMAT_ASTC_4x4_UNORM_BLOCK                          ,
			ASTC_4x4_SRGB_Block                                  = VK_FORMAT_ASTC_4x4_SRGB_BLOCK                           ,
			ASTC_5x4_UNormalized_Block                           = VK_FORMAT_ASTC_5x4_UNORM_BLOCK                          ,
			ASTC_5x4_SRGB_Block                                  = VK_FORMAT_ASTC_5x4_SRGB_BLOCK                           ,
			ASTC_5x5_UNormalized_Block                           = VK_FORMAT_ASTC_5x5_UNORM_BLOCK                          ,
			ASTC_5x5_SRGB_Block                                  = VK_FORMAT_ASTC_5x5_SRGB_BLOCK                           ,
			ASTC_6x5_UNormalized_Block                           = VK_FORMAT_ASTC_6x5_UNORM_BLOCK                          ,
			ASTC_6x5_SRGB_Block                                  = VK_FORMAT_ASTC_6x5_SRGB_BLOCK                           ,
			ASTC_6x6_UNormalized_Block                           = VK_FORMAT_ASTC_6x6_UNORM_BLOCK                          ,
			ASTC_6x6_SRGB_Block                                  = VK_FORMAT_ASTC_6x6_SRGB_BLOCK                           ,
			ASTC_8x5_UNormalized_Block                           = VK_FORMAT_ASTC_8x5_UNORM_BLOCK                          ,
			ASTC_8x5_SRGB_Block                                  = VK_FORMAT_ASTC_8x5_SRGB_BLOCK                           ,
			ASTC_8x6_UNormalized_Block                           = VK_FORMAT_ASTC_8x6_UNORM_BLOCK                          ,
			ASTC_8x6_SRGB_Block                                  = VK_FORMAT_ASTC_8x6_SRGB_BLOCK                           ,
			ASTC_8x8_UNormalized_Block                           = VK_FORMAT_ASTC_8x8_UNORM_BLOCK                          ,
			ASTC_8x8_SRGB_Block                                  = VK_FORMAT_ASTC_8x8_SRGB_BLOCK                           ,
			ASTC_10x5_UNormalized_Block                          = VK_FORMAT_ASTC_10x5_UNORM_BLOCK                         ,
			ASTC_10x5_SRGB_Block                                 = VK_FORMAT_ASTC_10x5_SRGB_BLOCK                          ,
			ASTC_10x6_UNormalized_Block                          = VK_FORMAT_ASTC_10x6_UNORM_BLOCK                         ,
			ASTC_10x6_SRGB_Block                                 = VK_FORMAT_ASTC_10x6_SRGB_BLOCK                          ,
			ASTC_10x8_UNormalized_Block                          = VK_FORMAT_ASTC_10x8_UNORM_BLOCK                         ,
			ASTC_10x8_SRGB_Block                                 = VK_FORMAT_ASTC_10x8_SRGB_BLOCK                          ,
			ASTC_10x10_UNormalized_Block                         = VK_FORMAT_ASTC_10x10_UNORM_BLOCK                        ,
			ASTC_10x10_SRGB_Block                                = VK_FORMAT_ASTC_10x10_SRGB_BLOCK                         ,
			ASTC_12x10_UNormalized_Block                         = VK_FORMAT_ASTC_12x10_UNORM_BLOCK                        ,
			ASTC_12x10_SRGB_Block                                = VK_FORMAT_ASTC_12x10_SRGB_BLOCK                         ,
			ASTC_12x12_UNormalize_Block                          = VK_FORMAT_ASTC_12x12_UNORM_BLOCK                        ,
			ASTC_12x12_SRGB_Block                                = VK_FORMAT_ASTC_12x12_SRGB_BLOCK                         ,
			G8_B8_G8_R8_422_UNormalized                          = VK_FORMAT_G8B8G8R8_422_UNORM                            ,
			B8_G8_R8_G8_422_UNormalized                          = VK_FORMAT_B8G8R8G8_422_UNORM                            ,
			G8_B8_R8_3Plane_420_UNormalized                      = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                     ,
			G8_B8_R8_2Plane_420_UNormalized                      = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                      ,
			G8_B8_R8_3Plane_422_UNormalized                      = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                     ,
			G8_B8_R8_2Plane_422_UNormalized                      = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                      ,
			G8_B8_R8_3Plane_444_UNormalized                      = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                     ,
			R10x6_UNormalized_Pack16                             = VK_FORMAT_R10X6_UNORM_PACK16                            ,
			R10x6_G10x6_UNormalized_2Pack16                      = VK_FORMAT_R10X6G10X6_UNORM_2PACK16                      ,
			R10x6_G10x6_B10x6_A10x6_UNormalized_4Pack16          = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16            ,
			G10x6_B10x6_G10x6_R10x6_422_UNormalized_4Pack16      = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16        ,
			B10x6_G10x6_R10x6_G10x6_422_UNormalized_4Pack16      = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16        ,
			G10x6_B10x6_R10x6_3Plane_420_UNormalized_3Pack16     = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16    ,
			G10x6_B10x6_R10x6_2Plane_420_UNormalized_3Pack16     = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16     ,
			G10x6_B10x6_R10x6_3Plane_422_UNormalized_3Pack16     = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16    ,
			G10x6_B10x6_R10x6_2Plane_422_UNormalized_3Pack16     = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16     ,
			G10x6_B10x6_R10x6_3Plane_444_UNormalized_3Pack16     = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16    ,
			R12x4_UNormalized_Pack16                             = VK_FORMAT_R12X4_UNORM_PACK16                            ,
			R12x4_G12x4_UNormalized_2Pack16                      = VK_FORMAT_R12X4G12X4_UNORM_2PACK16                      ,
			R12x4_G12x4_B12x4_A12x4_UNormalized_4Pack16          = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16            ,
			G12x4_B12x4_G12x4_R12x4_422_UNormalized_4Pack16      = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16        ,
			B12x4_G12x4_R12x4_G12x4_422_UNormalized_4Pack16      = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16        ,
			G12x4_B12x4_R12x4_3Plane_420_UNormalized_3Pack16     = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16    ,
			G12x4_B12x4_R12x4_2Plane_420_UNormalized_3Pack16     = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16     ,
			G12x4_B12x4_R12x4_3Plane_422_UNormalized_3Pack16     = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16    ,
			G12x4_B12x4_R12x4_2Plane_422_UNormalized_3Pack16     = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16     ,
			G12x4_B12x4_R12x4_3Plane_444_UNormalized_3Pack16     = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16    ,
			G16_B16_G16_R16_422_UNormalized                      = VK_FORMAT_G16B16G16R16_422_UNORM                        ,
			B16_G16_R16_G16_422_UNormalized                      = VK_FORMAT_B16G16R16G16_422_UNORM                        ,
			G16_B16_R16_3Plane_420_UNormalized                   = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM                  ,
			G16_B16_R16_2Plane_420_UNormalized                   = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                   ,
			G16_B16_3Plane_422_UNormalized                       = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM                  ,
			G16_B16_R16_2Plane_422_UNormalized                   = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                   ,
			G16_B16_R16_3Plane_444_UNormalized                   = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM                  ,
			PVRTC1_2BPP_UNormalized_Block_Image                  = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG                   ,
			PVRTC1_4BPP_UNormalized_Block_Image                  = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG                   ,
			PVRTC2_2BPP_UNormalized_Block_Image                  = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG                   ,
			PVRTC2_4BPP_UNormalized_Block_Image                  = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG                   ,
			PVRTC1_2BPP_SRGB_Block_Image                         = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG                    ,
			PVRTC1_4BPP_SRGB_Block_Image                         = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG                    ,
			PVRTC2_2BPP_SRGB_Block_Image                         = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG                    ,
			PVRTC2_4BPP_SRGB_Block_Image                         = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG                    ,
			ASTC_4x4_SFloat_Block_EXT                            = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT                     ,
			ASTC_5x4_SFloat_Block_EXT                            = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT                     ,
			ASTC_5x5_SFloat_Block_EXT                            = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT                     ,
			ASTC_6x5_SFloat_Block_EXT                            = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT                     ,
			ASTC_6x6_SFloat_Block_EXT                            = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT                     ,
			ASTC_8x5_SFloat_Block_EXT                            = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT                     ,
			ASTC_8x6_SFloat_Block_EXT                            = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT                     ,
			ASTC_8x8_SFloat_Block_EXT                            = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT                     ,
			ASTC_10x5_SFloat_Block_EXT                           = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT                    ,
			ASTC_10x6_SFloat_Block_EXT                           = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT                    ,
			ASTC_10x8_SFloat_Block_EXT                           = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT                    ,
			ASTC_10x10_SFloat_Block_EXT                          = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT                   ,
			ASTC_12x10_SFloat_Block_EXT                          = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT                   ,
			ASTC_12x12_SFloat_Block_EXT                          = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT                   ,
			G8_B8_G8_R8_422_UNormalized_KHR                      = VK_FORMAT_G8B8G8R8_422_UNORM_KHR                        ,
			B8_G8_R8_G8_422_UNormalized_KHR                      = VK_FORMAT_B8G8R8G8_422_UNORM_KHR                        ,
			G8_B8_R8_3Plane_420_UNormalized_KHR                  = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR                 ,
			G8_B8_R8_2Plane_420_UNormalized_KHR                  = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR                  ,
			G8_B8_R8_3Plane_422_UNormalized_KHR                  = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR                 ,
			G8_B8_R8_2Plane_422_Unormalized_KHR                  = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR                  ,
			G8_B8_R8_3Plane_444_UNormalized_KHR                  = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR                 ,
			R10x6_UNormalized_Pack16_KHR                         = VK_FORMAT_R10X6_UNORM_PACK16_KHR                        ,
			R10x6_G10x6_UNormalized_2Pack16_KHR                  = VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR                  ,
			R10x6_G10x6_B10x6_A10x6_UNormalized_4Pack16_KHR      = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR        ,
			G10x6_B10x6_G10x6_R10x6_422_UNormalized_4Pack16_KHR  = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR    ,
			B10x6_G10x6_R10x6_G10x6_422_UNormalized_4Pack16_KHR  = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR    ,
			G10x6_B10x6_3Plane_420_UNormalized_3Pac16_KHR        = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
			G10x6_B10x6_R10x6_2PLane_420_UNormalized_3Pack16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR ,
			G10x6_B10x6_R10x6_3Plane_422_UNormalized_3Pack16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
			G10x6_B10x6_R10x6_2Plane_422_UNormalized_3Pack16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR ,
			G10x6_B10x6_R10x6_3Plane_444_UNormalized_3Pack16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
			R12X4_UNormalized_Pack16_KHR                         = VK_FORMAT_R12X4_UNORM_PACK16_KHR                        ,
			R12x4_G12x4_UNormalized_2Pack16_KHR                  = VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR                  ,
			R12x4_G12x4_B12x4_A12x4_UNormalized_4Pack16_KHR      = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR        ,
			G12x4_B12x4_G12x4_R12x4_422_UNormalized_4Pack16_KHR  = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR    ,
			B12x4_G12x4_R12x4_G12x4_422_UNormalized_4Pack16_KHR  = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR    ,
			G12x4_B12x4_R12x4_3Plane_410_UNormalized_3Pack16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
			G12x4_B12x4_R12x4_2Plane_420_UNormalized_3Pack16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR ,
			G12x4_B12x4_R12x4_3Plane_422_UNormalized_3Pack16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
			G12x4_B12x4_R12x4_2Plane_422_UNormalized_3Pack16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR ,
			G12x4_B12x4_R12x4_3Plane_444_UNormalized_3Pack16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
			G16_B16_G16_R16_422_UNormalized_KHR                  = VK_FORMAT_G16B16G16R16_422_UNORM_KHR                    ,
			B16_G16_R16_G16_422_UNormalized_KHR                  = VK_FORMAT_B16G16R16G16_422_UNORM_KHR                    ,
			G16_B16_R16_3Plane_420_UNormalized_KHR               = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR              ,
			G16_B16_R16_2Plane_420_UNormalized_KHR               = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR               ,
			G16_B16_R16_3Plane_422_UNormalized_KHR               = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR              ,
			G16_B16_R16_2Plane_422_UNormalized_KHR               = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR               ,
			G16_B16_R16_3Plane_444_UNormalized_KHR               = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR                  // Specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of plane 1, and a 16-bit R component in each 16-bit word of plane 2. Each plane has the same dimensions and each R, G and B component contributes to a single texel. The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFormatFeatureFlagBits">Specification</a> @ingroup APISpec_Formats */
		enum class EFormatFeatureFlag : uint32
		{
			SampledImage             = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT              ,
			StorageImage             = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT              ,
			ImageAtomic              = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT       ,
			UniformTexelBuffer       = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT       ,
			StroageTexelBuffer       = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT       ,
			StorageTexelBufferAtomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
			VertexBuffer             = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT              ,
			ColorAttachment          = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT           ,
			ColorAttachmentBlend     = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT     ,
			DepthStencilAttachment   = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT   ,
			BlitSource               = VK_FORMAT_FEATURE_BLIT_SRC_BIT                   ,
			BlitDestination          = VK_FORMAT_FEATURE_BLIT_DST_BIT                   ,
			SampledImageFilterLinear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,

			// Provided by VK_VERSION_1_1
			TransferSource                                                 = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                                                           ,
			TransferDestination                                            = VK_FORMAT_FEATURE_TRANSFER_DST_BIT                                                           ,
			MidpointChromaSamples                                          = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                                ,
			SampledImageYCBCR_ConversionLinearFilter                        = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                           ,
			SampledImageYCBCR_ConversionSeparateReconstructionFilter        = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT          ,
			SampledImageYCBCR_ConversionChromaReconstructionExplicit        = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT          ,
			SampledImageYCBCR_ConversionChromaReconstructionExplictForcable = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
			Disjoint                                                       = VK_FORMAT_FEATURE_DISJOINT_BIT                                                               ,
			CositedChromaSamples                                           = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                                 ,

			SampledImageFilterMinMax              = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT             ,   // Provided by VK_VERSION_1_2
			SampledImageFilterCubic_IMG           = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG          ,   // Provided by VK_IMG_filter_cubic
			AccelerationStructureVertexBuffer_KHR = VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,   // Provided by VK_KHR_ray_tracing
			FragmentDensityMap_EXT                = VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT                ,   // Provided by VK_EXT_fragment_density_map
			TransferSource_KHR                    = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR                        ,   // Provided by VK_KHR_maintenance1
			TransferDestination_KHR               = VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR                        ,   // Provided by VK_KHR_maintenance1
			SampledImageFilterMinMax_EXT          = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT         ,   // Provided by VK_EXT_sampler_filter_minmax

			// Provided by VK_KHR_sampler_ycbcr_conversion
			MidpointChromaSamples_KHR                                             = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                ,
			SampledImageYCBCR_ConversionLinearFilter_KHR                          = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                           ,
			SampledImageYCBCR_ConversionSeparateReconstructionFilter_KHR          = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR          ,
			SampledImageYCBCR_ConversionChromaReconstructionExplicit_KHR          = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR          ,
			SampledImageYCBCR_ConversionChromaReconstructionExplicit_Forcable_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
			Disjoint_KHR                                                          = VK_FORMAT_FEATURE_DISJOINT_BIT_KHR                                                               ,
			CositedChromaSamples_KHR                                              = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR                                                 ,
			SampledImageFilterCubic_EXT                                           = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT                                             ,   // Provided by VK_EXT_filter_cubic

			VT_SpecifyBitmaskable = VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFramebufferCreateFlagBits">Specification</a> @ingroup APISpec_Render_Pass */
		enum class EFrameBufferCreateFlag : uint32 { VT_SpecifyBitmaskable = sizeof(uint32) };

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFrontFace">Specification</a> @ingroup APISpec_Rasterization */
		enum class EFrontFace : uint32
		{
			CounterClockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE,
			Clockwise        = VK_FRONT_FACE_CLOCKWISE
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageAspectFlagBits">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageAspect : uint32
		{
			Color         = VK_IMAGE_ASPECT_COLOR_BIT             ,
			Depth         = VK_IMAGE_ASPECT_DEPTH_BIT             ,
			Stencil       = VK_IMAGE_ASPECT_STENCIL_BIT           ,
			MetaData      = VK_IMAGE_ASPECT_METADATA_BIT          ,
			Plane_0       = VK_IMAGE_ASPECT_PLANE_0_BIT           ,
			Plane_1       = VK_IMAGE_ASPECT_PLANE_1_BIT           ,
			Plane_2       = VK_IMAGE_ASPECT_PLANE_2_BIT           ,
			MemoryPlane_0 = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
			MemoryPlane_1 = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
			MemroyPlane_2 = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
			MemoryPlane_3 = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
			KHR_Plane_0   = VK_IMAGE_ASPECT_PLANE_0_BIT_KHR       ,
			KHR_Plane_1   = VK_IMAGE_ASPECT_PLANE_1_BIT_KHR       ,
			KHR_Plane_2   = VK_IMAGE_ASPECT_PLANE_2_BIT_KHR       ,

			VT_SpecifyBitmaskable = VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageCreateFlagBits">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageCreateFlag : uint32
		{
			SparseBinding                      = VK_IMAGE_CREATE_SPARSE_BINDING_BIT                       ,
			SparseResidency                    = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT                     ,
			SparseAliased                      = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT                       ,
			MutableFormat                      = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT                       ,
			CubeCompatible                     = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT                      ,
			Alias                              = VK_IMAGE_CREATE_ALIAS_BIT                                ,
			SplitInstanceBindRegions           = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT          ,
			_2DArrayCompatible                 = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT                  ,
			BlockTexelViewCompatible           = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT          ,
			ExtendedUsage                      = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT                       ,
			Protected                          = VK_IMAGE_CREATE_PROTECTED_BIT                            ,
			Disjoint                           = VK_IMAGE_CREATE_DISJOINT_BIT                             ,
			CornerSampled                      = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV                    ,
			SampleLocationsCompatibleDepth_Ext = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
			Subsampled_Ext                     = VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT                       ,
			SplitInstanceBindRegions_KHR       = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR      ,
			_2DArrayCompatible_KHR             = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR              ,
			BlockTexelViewCompatible_KHR       = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR      ,
			ExtendedUsage_KHR                  = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR                   ,
			Disjoint_KHR                       = VK_IMAGE_CREATE_DISJOINT_BIT_KHR                         ,
			Alias_KHR                          = VK_IMAGE_CREATE_ALIAS_BIT_KHR                            ,

			VT_SpecifyBitmaskable = VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageLayout">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageLayout : uint32
		{
			Undefined                                    = VK_IMAGE_LAYOUT_UNDEFINED                                     ,
			General                                      = VK_IMAGE_LAYOUT_GENERAL                                       ,
			Color_AttachmentOptimal                      = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                      ,
			DepthStencil_AttachmentOptimal               = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL              ,
			DepthStencil_ReadonlyOptimal                 = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL               ,
			Shader_ReadonlyOptimal                       = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                      ,
			TransferSource_Optimal                       = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                          ,
			TransferDestination_Optimal                  = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                          ,
			Preinitalized                                = VK_IMAGE_LAYOUT_PREINITIALIZED                                ,
			Depth_Readonly_Stencil_AttachemntOptimal     = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL    ,
			Depth_Attachment_Stencil_ReadonlyOptimal     = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL    ,
			Depth_AttachmentOptimal                      = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL                      ,
			Depth_ReadonlyOptimal                        = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL                       ,
			Stencil_AttachmentOptimal                    = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL                    ,
			Stencil_ReadonlyOptimal                      = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL                     ,
			PresentSource_KHR                            = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                               ,
			SharedPresent_KHR                            = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR                            ,
			ShadingRate_Optimal                          = VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV                       ,
			Fragment_DensityMapOptimal_EXT               = VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT              ,
			Depth_Readonly_Stencil_AttachmentOptimal_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
			Depth_Atteachment_StencilReadonlyOptimal_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
			Depth_AttachmentOptimal_KHR                  = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR                  ,
			Depth_ReadonlyOptimal_KHR                    = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR                   ,
			Stencil_AttachmentOptimal_KHR                = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR                ,
			Stencil_ReadonlyOptimal_KHR                  = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR                 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageTiling">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageTiling : uint32
		{
			Optimal                      = VK_IMAGE_TILING_OPTIMAL                ,
			Linear                       = VK_IMAGE_TILING_LINEAR                 ,
			DRM_FormatModifier_Extension = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageType">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageType : uint32
		{
			_1D = VK_IMAGE_TYPE_1D,
			_2D = VK_IMAGE_TYPE_2D,
			_3D = VK_IMAGE_TYPE_3D
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageUsageFlagBits">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageUsage : uint32
		{
			TransferSource          = VK_IMAGE_USAGE_TRANSFER_SRC_BIT            ,
			TransferDestination     = VK_IMAGE_USAGE_TRANSFER_DST_BIT            ,
			Sampled                 = VK_IMAGE_USAGE_SAMPLED_BIT                 ,
			Storage                 = VK_IMAGE_USAGE_STORAGE_BIT                 ,
			Color_Attachment        = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT        ,
			DepthStencil_Attachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
			Transient_Attachment    = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT    ,
			Input_Attachemnt        = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT        ,
			Image_ShadingRate       = VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV   ,
			DensityMap              = VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,

			VT_SpecifyBitmaskable = VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageViewCreateFlagBits">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageViewCreateFlag : uint32
		{
			Fragment_DensityMapDynamiic = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,

			VT_SpecifyBitmaskable = VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageView">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class EImageViewType : uint32
		{
			_1D       = VK_IMAGE_VIEW_TYPE_1D        ,
			_2D       = VK_IMAGE_VIEW_TYPE_2D        ,
			_3D       = VK_IMAGE_VIEW_TYPE_3D        ,
			_Cube     = VK_IMAGE_VIEW_TYPE_CUBE      ,
			_1D_Array = VK_IMAGE_VIEW_TYPE_1D_ARRAY  ,
			_2D_Array = VK_IMAGE_VIEW_TYPE_2D_ARRAY  ,
			CubeArray = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkIndexType">Specification</a> @ingroup APISpec_Drawing_Commands */
		enum class EIndexType : uint32
		{
			uInt16   = VK_INDEX_TYPE_UINT16   ,
			uInt32   = VK_INDEX_TYPE_UINT32   ,
			None_KHR = VK_INDEX_TYPE_NONE_KHR ,
			uInt8    = VK_INDEX_TYPE_UINT8_EXT,
			None_NV  = VK_INDEX_TYPE_NONE_NV 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkInternalAllocationType">Specification</a> @ingroup APISpec_Memory_Allocation */
		enum class EInternalAllocationType
		{
			Executable = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueCreateFlagBits">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class ELogicalDeviceQueueCreateFlag : uint32
		{
			CreateProtected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,

			VT_SpecifyBitmaskable = VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkLogicOp">Specification</a> @ingroup APISpec_The_Framebuffer */
		enum class ELogicOperation : uint32
		{
			Clear         = VK_LOGIC_OP_CLEAR        ,
			And           = VK_LOGIC_OP_AND          ,
			And_Reverse   = VK_LOGIC_OP_AND_REVERSE  ,
			Copy          = VK_LOGIC_OP_COPY         ,
			And_Inverted  = VK_LOGIC_OP_AND_INVERTED ,
			No            = VK_LOGIC_OP_NO_OP        ,
			XOR           = VK_LOGIC_OP_XOR          ,
			Or            = VK_LOGIC_OP_OR           ,
			NOR           = VK_LOGIC_OP_NOR          ,
			Equivalent    = VK_LOGIC_OP_EQUIVALENT   ,
			Int           = VK_LOGIC_OP_INVERT       ,
			OR_Reverse    = VK_LOGIC_OP_OR_REVERSE   ,
			Copy_Inverted = VK_LOGIC_OP_COPY_INVERTED,
			Or_Inverted   = VK_LOGIC_OP_OR_INVERTED  ,
			NAND          = VK_LOGIC_OP_NAND         ,
			Set           = VK_LOGIC_OP_SET          
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryHeapFlagBits">Specification</a> @ingroup APISpec_Memory_Allocation */
		enum class EMemoryHeapFlag : uint32
		{
			DeviceLocal       = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT      ,
			MultiInstance     = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT    ,
			MultiInstance_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,

			VT_SpecifyBitmaskable = VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM
		};

		/**
		@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryOverallocationBehaviorAMD">Specification</a> @ingroup APISpec_Devices_and_Queues
		*/
		enum class EMemoryOverallocationBehaviorAMD : uint32
		{
			Default    = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD   , 
			Allowed    = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD   , 
			Disallowed = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryPropertyFlagBits">Specification</a> @ingroup APISpec_Memory_Allocation */
		enum class EMemoryPropertyFlag : uint32
		{
			DeviceLocal        = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT       ,
			HostVisible        = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT       ,
			HostCoherent       = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT      , 
			HostCached         = VK_MEMORY_PROPERTY_HOST_CACHED_BIT        ,
			LazilyAllocated    = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT   ,
			Protected          = VK_MEMORY_PROPERTY_PROTECTED_BIT          ,
			DeviceCoherent_AMD = VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
			DeviceUncached_AMD = VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,

			VT_SpecifyBitmaskable = VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkObjectType">Specification</a> @ingroup APISpec_Debugging */
		enum class EObjectType : uint32
		{
			Unknown                        = VK_OBJECT_TYPE_UNKNOWN                        ,
			Instance                       = VK_OBJECT_TYPE_INSTANCE                       ,
			PhysicalDevice                 = VK_OBJECT_TYPE_PHYSICAL_DEVICE                ,
			Device                         = VK_OBJECT_TYPE_DEVICE                         ,
			Queue                          = VK_OBJECT_TYPE_QUEUE                          ,
			Semaphore                      = VK_OBJECT_TYPE_SEMAPHORE                      ,
			CommandBuffer                  = VK_OBJECT_TYPE_COMMAND_BUFFER                 ,
			Fence                          = VK_OBJECT_TYPE_FENCE                          ,
			DeviceMemory                   = VK_OBJECT_TYPE_DEVICE_MEMORY                  ,
			Buffer                         = VK_OBJECT_TYPE_BUFFER                         ,
			Image                          = VK_OBJECT_TYPE_IMAGE                          ,
			Event                          = VK_OBJECT_TYPE_EVENT                          ,
			QueryPool                      = VK_OBJECT_TYPE_QUERY_POOL                     ,
			BufferView                     = VK_OBJECT_TYPE_BUFFER_VIEW                    ,
			ImageView                      = VK_OBJECT_TYPE_IMAGE_VIEW                     ,
			ShaderModule                   = VK_OBJECT_TYPE_SHADER_MODULE                  ,
			PipelineCache                  = VK_OBJECT_TYPE_PIPELINE_CACHE                 ,
			PipelineLayout                 = VK_OBJECT_TYPE_PIPELINE_LAYOUT                ,
			RenderPass                     = VK_OBJECT_TYPE_RENDER_PASS                    ,
			Pipeline                       = VK_OBJECT_TYPE_PIPELINE                       ,
			DescriptorSetLayout            = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT          ,
			Sampler                        = VK_OBJECT_TYPE_SAMPLER                        ,
			DescriptorPool                 = VK_OBJECT_TYPE_DESCRIPTOR_POOL                ,
			DescriptorSet                  = VK_OBJECT_TYPE_DESCRIPTOR_SET                 ,
			FrameBuffer                    = VK_OBJECT_TYPE_FRAMEBUFFER                    ,
			CommandPool                    = VK_OBJECT_TYPE_COMMAND_POOL                   ,
			Sampler_YCBCR_Conversion       = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION       ,
			DescriptorUpdateTemplate       = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE     ,
			Surface_KHR                    = VK_OBJECT_TYPE_SURFACE_KHR                    ,
			SwapChain_KHR                  = VK_OBJECT_TYPE_SWAPCHAIN_KHR                  ,
			Display_KHR                    = VK_OBJECT_TYPE_DISPLAY_KHR                    ,
			DisplayMode_KHR                = VK_OBJECT_TYPE_DISPLAY_MODE_KHR               ,
			DebugReportCallback_EXT        = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT      ,
			DebugUtilsMessenger_EXT        = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT      ,
			AccelerationStructure_KHR      = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR     ,
			ValidationCache_EXT            = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT           ,
			Intel_PerformanceConfiguration = VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
			DeferredOperation_KHR          = VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR         ,
			IndirectCommandsLayout         = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV    ,
			//Extension_PrivateDataSlot = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT,   // TODO: is this ok?
			PrivateDataSlot_EXT            = 1000295000,
			DescriptorUpdateTemplate_KHR   = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR ,
			Sampler_YCBCR_Conversion_KHR   = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR   ,
			AccelerationStructure          = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterDescriptionFlagBitsKHR">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EPerformanceCounterDescriptionFlag : uint32
		{
			PerformanceImpacting = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR,
			ConcurrentlyImpacted = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR,

			VT_SpecifyBitmaskable = VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterScopeKHR">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EPerformanceCounterScope : uint32
		{
			Performance_CommandBuffer = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
			Performance_RenderPass    = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR   ,
			Performance_Command       = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR       ,
			Query_Buffer              = VK_QUERY_SCOPE_COMMAND_BUFFER_KHR              ,
			Query_RenderPass          = VK_QUERY_SCOPE_RENDER_PASS_KHR                 ,
			Query_Command             = VK_QUERY_SCOPE_COMMAND_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterStorageKHR">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EPerformanceCounterStorage : uint32
		{
			VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
			VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
			VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
			VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
			VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
			VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterUnitKHR">Specification</a> @ingroup APISpec_Devices_and_Queues */
		enum class EPerformanceCounterUnit : uint32
		{
			Generic        = VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR         ,
			Percentage     = VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR      ,
			Nanoseconds    = VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR     ,
			Bytes          = VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR           ,
			BytesPerSecond = VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
			Kelvin         = VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR          ,
			Watts          = VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR           ,
			Volts          = VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR           ,
			Amps           = VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR            ,
			Hertz          = VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR           ,
			Cycles         = VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR          
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineBindPoint">Specification</a> @ingroup APISpec_Pipelines */
		enum class EPipelineBindPoint : uint32
		{
			Graphics = VK_PIPELINE_BIND_POINT_GRAPHICS,
			Compute  = VK_PIPELINE_BIND_POINT_COMPUTE 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCacheCreateFlagBits">Specification</a> @ingroup APISpec_Pipelines */
		enum class EPipelineCacheCreateFlag : uint32
		{
			Externally_Synchronized = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT,

			VT_SpecifyBitmaskable = VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCreateFlagBits">Specification</a> @ingroup APISpec_Pipelines */
		enum class EPipelineCreateFlag : uint32
		{
			DisableOptimization                    = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT                        ,
			AllowDerivatives                       = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                           ,
			Derivative                             = VK_PIPELINE_CREATE_DERIVATIVE_BIT                                  ,
			ViewIndexFromDeviceIndex               = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT                ,
			DispatchBase                           = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT                               ,
			Raytracing_NoNull_AnyHit_Shaders       = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR     ,
			Raytracing_NoNull_ClosestHit_Shaders   = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR ,
			Raytracing_NoNull_Miss_Shaders         = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR        ,
			Raytracing_NoNull_Intersection_Shaders = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
			Raytracing_SkipTriangles               = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR              ,
			Raytracing_Skip_AABBS                  = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR                  ,
			DeferCompile                           = VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV                            ,
			CaptureStatistics                      = VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR                      ,
			CaptureInternalRepresentations         = VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR        ,
			IndirectBindable                       = VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV                        ,
			Library                                = VK_PIPELINE_CREATE_LIBRARY_BIT_KHR                                 ,
			FailOn_PipelineCompileRequired         = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT       ,
			EarlyReturnOn_Failure                  = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT                 ,
			DispatchBase2                          = VK_PIPELINE_CREATE_DISPATCH_BASE                                   ,
			ViewIndexFromDeviceInex                = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR            ,
			DispatchBase_KHR                       = VK_PIPELINE_CREATE_DISPATCH_BASE_KHR                               ,

			VT_SpecifyBitmaskable = VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineShaderStageCreateFlagBits">Specification</a> @ingroup APISpec_Pipelines */
		enum class EPipelineShaderStageCreateFlag : uint32
		{
			AllowVaryingSubgroupSize = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
			RequireFullSubgroups     = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT     ,

			VT_SpecifyBitmaskable = VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineStageFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class EPipelineStageFlag : uint32
		{
			TopOfPipe                    = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                   ,
			DrawIndirect                 = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                 ,
			VertexInput                  = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                  ,
			VertexShader                 = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                 ,
			TessellationControlShader    = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT   ,
			TessellationEvaluationShader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
			GeometryShader               = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT               ,
			FragementShader              = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT               ,
			EarlyFragmentTests           = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT          ,
			LateFragmentTests            = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT           ,
			ColorAttachmentOutput        = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT       ,
			ComputeShader                = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                ,
			Transfer                     = VK_PIPELINE_STAGE_TRANSFER_BIT                      ,
			BottomOfPipe                 = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                ,
			Host                         = VK_PIPELINE_STAGE_HOST_BIT                          ,
			AllGraphics                  = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                  ,
			AllCommands                  = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                  ,

			VT_SpecifyBitmaskable = VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#primsrast-polygonmode">Specification</a> @ingroup APISpec_Rasterization */
		enum class EPolygonMode : uint32
		{
			Fill              = VK_POLYGON_MODE_FILL             ,
			Line              = VK_POLYGON_MODE_LINE             ,
			Point             = VK_POLYGON_MODE_POINT            ,
			NV_Fill_Rectangle = VK_POLYGON_MODE_FILL_RECTANGLE_NV
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPresentModeKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
		enum class EPresentationMode : uint32
		{
			Immediate               = VK_PRESENT_MODE_IMMEDIATE_KHR                ,
			Mailbox                 = VK_PRESENT_MODE_MAILBOX_KHR                  ,
			FIFO                    = VK_PRESENT_MODE_FIFO_KHR                     ,
			FIFO_Relaxed            = VK_PRESENT_MODE_FIFO_RELAXED_KHR             ,
			SharedDemandRefresh     = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR    ,
			SharedContinuousRefresh = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPrimitiveTopology">Specification</a> @ingroup APISpec_Drawing_Commands */
		enum class EPrimitiveTopology : uint32
		{
			PointList                   = VK_PRIMITIVE_TOPOLOGY_POINT_LIST                   ,
			LineList                    = VK_PRIMITIVE_TOPOLOGY_LINE_LIST                    ,
			LineStrip                   = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                   ,
			TriangleList                = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                ,
			TriangleStrip               = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP               ,
			TriangleFan                 = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                 ,
			LineList_WithAdjacency      = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY     ,
			LineStrip_WithAdjacency     = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY    ,
			TriangleList_WithAdjaceny   = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY ,
			TriangleStrip_WithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
			PatchList                   = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    
		};

		/**
		@brief Supported physical device types.

		@details
		The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. 
		However, the device type may correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.

		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceType.html">Specification</a> 

		@ingroup APISpec_Devices_and_Queues
		*/
		enum class EPhysicalDeviceType : uint32
		{
			Other          = VK_PHYSICAL_DEVICE_TYPE_OTHER         ,
			IntergratedGPU = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
			DiscreteGPU    = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU  ,
			VirtualGPU     = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU   ,
			CPU            = VK_PHYSICAL_DEVICE_TYPE_CPU
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPointClippingBehavior">Specification</a> @ingroup APISpec_Fixed-Function_Vertex_Post-Processing */
		enum class EPointClippingBehavior : uint32
		{
			AllClipPlanes      = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES      , 
			UserClipPlanesOnly = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY, 

			// Provided by VK_KHR_maintenance2
			AllClipPlanes_KHR      = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR      , 
			UserClipPlanesOnly_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueryControlFlagBits">Specification</a> @ingroup APISpec_Queries */
		enum class EQueryControlFlags : uint32
		{
			Precise = VK_QUERY_CONTROL_PRECISE_BIT,

			VT_SpecifyBitmaskable = VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM
		};

		/**
		@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueueFlagBits">Specification</a> @ingroup APISpec_Devices_and_Queues
		*/
		enum class EQueueFlag : uint32
		{
			Graphics      = VK_QUEUE_GRAPHICS_BIT      ,
			Compute       = VK_QUEUE_COMPUTE_BIT       ,
			Transfer      = VK_QUEUE_TRANSFER_BIT      ,
			SparseBinding = VK_QUEUE_SPARSE_BINDING_BIT,
			Protected     = VK_QUEUE_PROTECTED_BIT     ,

			VT_SpecifyBitmaskable = VK_QUEUE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueryPipelineStatisticFlagBits">Specification</a> @ingroup APISpec_Queries */
		enum class EQueryPipelineStatisticFlag : uint32
		{
			AssemblyVertices                        = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                   ,
			AssemblyPrimitives                      = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                 ,
			VertexShaderInovcations                 = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                 ,
			GeometryShaderInvocations               = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT               ,
			GeometryShaderPrimitives                = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                ,
			ClippingInocation                       = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                      ,
			ClippingPrimitives                      = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                       ,
			FragmentShaderInvoations                = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT               ,
			TessellationControlShaderPatches        = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT       ,
			TessellationEvaluationShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
			ComputeShaderInvocations                = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                ,

			VT_SpecifyBitmaskable = VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkResolveModeFlagBits">Specification</a> @ingroup APISpec_Render_Pass */
		enum class EResolveModeFlags : uint32
		{
			None       = VK_RESOLVE_MODE_NONE ,
			SampleZero = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT ,
			Average    = VK_RESOLVE_MODE_AVERAGE_BIT ,
			Min        = VK_RESOLVE_MODE_MIN_BIT ,
			Max        = VK_RESOLVE_MODE_MAX_BIT ,

			// Provided by VK_KHR_depth_stencil_resolve
			None_KHR       = VK_RESOLVE_MODE_NONE_KHR           ,
			SampleZero_KHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
			Average_KHR    = VK_RESOLVE_MODE_AVERAGE_BIT_KHR    ,
			Min_KHR        = VK_RESOLVE_MODE_MIN_BIT_KHR        ,
			Max_KHR        = VK_RESOLVE_MODE_MAX_BIT_KHR        ,

			VT_SpecifyBitmaskable = VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkResult">Specification</a> @ingroup APISpec_Fundamentals */
		enum class EResult : sint32
		{
			Success                                         = VK_SUCCESS                                           ,
			Not_Ready                                       = VK_NOT_READY                                         ,
			Timeout                                         = VK_TIMEOUT                                           ,
			Event_Set                                       = VK_EVENT_SET                                         ,
			Event_Reset                                     = VK_EVENT_RESET                                       ,
			Incomplete                                      = VK_INCOMPLETE                                        ,
			Error_OutOfHostMemory                           = VK_ERROR_OUT_OF_HOST_MEMORY                          ,
			Error_OutOfDeviceMemory                         = VK_ERROR_OUT_OF_DEVICE_MEMORY                        ,
			Error_InitalizationFailed                       = VK_ERROR_INITIALIZATION_FAILED                       ,
			Error_DeviceLost                                = VK_ERROR_DEVICE_LOST                                 ,
			Error_MemoryMap_Failed                          = VK_ERROR_MEMORY_MAP_FAILED                           ,
			Error_LayerNotPresent                           = VK_ERROR_LAYER_NOT_PRESENT                           ,
			Error_ExtensionNotPresent                       = VK_ERROR_EXTENSION_NOT_PRESENT                       ,
			Error_FeatureNotPresent                         = VK_ERROR_FEATURE_NOT_PRESENT                         ,
			Error_IncompatibleDriver                        = VK_ERROR_INCOMPATIBLE_DRIVER                         ,
			Error_TooManyObjects                            = VK_ERROR_TOO_MANY_OBJECTS                            ,
			Error_FormatNotSupported                        = VK_ERROR_FORMAT_NOT_SUPPORTED                        ,
			Error_FragmentedPool                            = VK_ERROR_FRAGMENTED_POOL                             ,
			Error_Unknown                                   = VK_ERROR_UNKNOWN                                     ,
			Error_OutOfPoolMemory                           = VK_ERROR_OUT_OF_POOL_MEMORY                          ,
			Error_InvalidExternalHandle                     = VK_ERROR_INVALID_EXTERNAL_HANDLE                     ,
			Error_Fragmentation                             = VK_ERROR_FRAGMENTATION                               ,
			Error_InvalidOpaqueCaptureAddress               = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS              ,
			Error_SurfaceLost_KHR                           = VK_ERROR_SURFACE_LOST_KHR                            ,
			Error_NativeWindowInUse_KHR                     = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR                    ,
			Suboptimal_KHR                                  = VK_SUBOPTIMAL_KHR                                    ,
			Error_OutOfDate_KHR                             = VK_ERROR_OUT_OF_DATE_KHR                             ,
			Error_IncompatbileDisplay_KHR                   = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR                    ,
			Error_Extension_ValidationFailed                = VK_ERROR_VALIDATION_FAILED_EXT                       ,
			Error_InvalidShader_NV                          = VK_ERROR_INVALID_SHADER_NV                           ,
			Error_IncompatibleVersion_KHR                   = VK_ERROR_INCOMPATIBLE_VERSION_KHR                    ,
			Error_Invalid_DRMFormat_ModifierPlaneLayout_EXT = VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
			Error_NotPermitted_EXT                          = VK_ERROR_NOT_PERMITTED_EXT                           ,
			Error_FullScreenExculsiveMode_Lost_EXT          = VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT         ,
			Thread_Idle_KHR                                 = VK_THREAD_IDLE_KHR                                   ,
			Thread_Done_KHR                                 = VK_THREAD_DONE_KHR                                   ,
			OperationDeferred_KHR                           = VK_OPERATION_DEFERRED_KHR                            ,
			OperationNotDeferred_KHR                        = VK_OPERATION_NOT_DEFERRED_KHR                        ,
			PipelineCompileRequired_EXT                     = VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT               ,
			Error_OutOfPoolMemory_KHR                       = VK_ERROR_OUT_OF_POOL_MEMORY_KHR                      ,
			Error_InvalidExternalHandle_KHR                 = VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR                 ,
			Error_Fragmentation_EXT                         = VK_ERROR_FRAGMENTATION_EXT                           ,
			Error_InvalidDeviceAddress_EXT                  = VK_ERROR_INVALID_DEVICE_ADDRESS_EXT                  ,
			Error_InvalidOpaqueCaptureAddress_KHR           = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR          ,
			Error_PipelineCompileRequired_EXT               = VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSampleCountFlagBits">Specification</a> @ingroup APISpec_Limits */
		enum class ESampleCount : uint32
		{
			_1  = VK_SAMPLE_COUNT_1_BIT ,
			_2  = VK_SAMPLE_COUNT_2_BIT ,
			_4  = VK_SAMPLE_COUNT_4_BIT ,
			_8  = VK_SAMPLE_COUNT_8_BIT ,
			_16 = VK_SAMPLE_COUNT_16_BIT,
			_32 = VK_SAMPLE_COUNT_32_BIT,
			_64 = VK_SAMPLE_COUNT_64_BIT,

			VT_SpecifyBitmaskable = VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSamplerAddressMode">Specification</a> @ingroup VkSamplerAddressMode */
		enum class ESamplerAddressMode : uint32
		{
			Repeat         = VK_SAMPLER_ADDRESS_MODE_REPEAT         ,
			MirroredRepeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
			ClampToEdge    = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE  ,
			ClampToBorder  = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
			
			// Provided by VK_VERSION_1_2, VK_KHR_sampler_mirror_clamp_to_edge
			MirrorClampToEdge     = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE    ,
			MirrorClampToEdge_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSamplerCreateFlagBits">Specification</a> @ingroup VkSamplerCreateFlagBits */
		enum class ESamplerCreateFlag : uint32
		{
			Subsampled_EXT                     = VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT                      ,
			SubsampledCoarseReconstruction_EXT = VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,

			VT_SpecifyBitmaskable = VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSamplerMipmapMode">Specification</a> @ingroup APISpec_Samplers */
		enum class ESamplerMipmapMode : uint32
		{
			Nearest = VK_SAMPLER_MIPMAP_MODE_NEAREST,
			Linear  = VK_SAMPLER_MIPMAP_MODE_LINEAR 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreImportFlagBits">Specification</a> @ingroup VkSemaphoreImportFlagBits */
		enum class ESemaphoreImportFlag
		{
			Temporary     = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT    ,
			Temporary_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,

			VT_SpecifyBitmaskable = VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreType">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class ESemaphoreType : uint32
		{
			Binary       = VK_SEMAPHORE_TYPE_BINARY      ,
			Timeline     = VK_SEMAPHORE_TYPE_TIMELINE    ,
			Binary_KHR   = VK_SEMAPHORE_TYPE_BINARY_KHR  ,
			Timeline_KHR = VK_SEMAPHORE_TYPE_TIMELINE_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreWaitFlagBits">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
		enum class ESemaphoreWaitFlag : uint32
		{
			Any     = VK_SEMAPHORE_WAIT_ANY_BIT    ,
			Any_KHR = VK_SEMAPHORE_WAIT_ANY_BIT_KHR,

			VT_SpecifyBitmaskable = VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderFloatControlsIndependence">Specification</a> @ingroup APISpec_Limits */
		enum class EShaderFloatControlIndependence : uint32
		{
			_32Bit_Only = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
			All         = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL        ,
			None        = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE       ,

			// Provided by VK_KHR_shader_float_controls
			_32Bit_Only_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
			All_KHR         = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR        ,
			None_KHR        = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR       ,
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderStageFlagBits">Specification</a> @ingroup APISpec_Pipelines */
		enum class EShaderStageFlag : uint32
		{
			Vertex                 = VK_SHADER_STAGE_VERTEX_BIT                 ,
			TessellationControl    = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT   ,
			TessellationEvaluation = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
			Geometry               = VK_SHADER_STAGE_GEOMETRY_BIT               ,
			Fragment               = VK_SHADER_STAGE_FRAGMENT_BIT               ,
			Compute                = VK_SHADER_STAGE_COMPUTE_BIT                ,
			Graphics               = VK_SHADER_STAGE_ALL_GRAPHICS               ,
			All                    = VK_SHADER_STAGE_ALL                        ,
			Raygen_KHR             = VK_SHADER_STAGE_RAYGEN_BIT_KHR             ,
			AnyHit_KHR             = VK_SHADER_STAGE_ANY_HIT_BIT_KHR            ,
			ClosestHit_KHR         = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR        ,
			Miss_KHR               = VK_SHADER_STAGE_MISS_BIT_KHR               ,
			Intersection_KHR       = VK_SHADER_STAGE_INTERSECTION_BIT_KHR       ,
			Callable_KHR           = VK_SHADER_STAGE_CALLABLE_BIT_KHR           ,
			Task_NV                = VK_SHADER_STAGE_TASK_BIT_NV                ,
			Mesh_NV                = VK_SHADER_STAGE_MESH_BIT_NV                ,
			Raygen_NV              = VK_SHADER_STAGE_RAYGEN_BIT_NV              ,
			AnyHit_NV              = VK_SHADER_STAGE_ANY_HIT_BIT_NV             ,
			ClosestHit_NV          = VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV         ,
			Miss_NV                = VK_SHADER_STAGE_MISS_BIT_NV                ,
			Intersection_NV        = VK_SHADER_STAGE_INTERSECTION_BIT_NV        ,
			Callable_NV            = VK_SHADER_STAGE_CALLABLE_BIT_NV            ,

			VT_SpecifyBitmaskable = VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSharingMode">Specification</a> @ingroup APISpec_Resource_Creation */
		enum class ESharingMode : uint32
		{
			Exclusive  = VK_SHARING_MODE_EXCLUSIVE ,
			Concurrent = VK_SHARING_MODE_CONCURRENT
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkStencilOp">Specification</a> @ingroup APISpec_Fragment_Operations */
		enum class EStencilOperation : uint32
		{
			Keep              = VK_STENCIL_OP_KEEP               ,
			Zero              = VK_STENCIL_OP_ZERO               ,
			Replace           = VK_STENCIL_OP_REPLACE            ,
			IncrementAndClamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
			DecrementAndClamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
			Invert            = VK_STENCIL_OP_INVERT             ,
			IncrementAndWrap  = VK_STENCIL_OP_INCREMENT_AND_WRAP ,
			DecrementAndWrap  = VK_STENCIL_OP_DECREMENT_AND_WRAP 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkStructureType">Specification</a> @ingroup APISpec_Fundamentals */
		enum class EStructureType : uint32
		{
			ApplicationInformation                                      = VK_STRUCTURE_TYPE_APPLICATION_INFO                                               ,
			Instance_CreateInfo                                         = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                                           ,
			DeviceQueue_CreateInfo                                      = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                                       ,
			Device_CreateInfo                                           = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                                             ,
			SubmitInfo                                                  = VK_STRUCTURE_TYPE_SUBMIT_INFO                                                    ,
			MemoryAllocateInfo                                          = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                                           ,
			MappedMemoryRange                                           = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                                            ,
			BindSparseInfo                                              = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                                               ,
			Fence_CreateInfo                                            = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                                              ,
			Semaphore_CreateInfo                                        = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                                          ,
			Event_CreateInfo                                            = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                                              ,
			QueryPool_CreateInfo                                        = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                                         ,
			Buffer_CreateInfo                                           = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                                             ,
			BufferView_CreateInfo                                       = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                                        ,
			Image_CreateInfo                                            = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                                              ,
			ImageView_CreateInfo                                        = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                                         ,
			ShaderModule_CreateInfo                                     = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                                      ,
			Pipeline_Cache_CreateInfo                                   = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                                     ,
			Pipeline_ShaderStage_CreateInfo                             = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO                              ,
			Pipeline_VertexInputState_CreateInfo                        = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                        ,
			Pipeline_InputAssemblyState_CreateInfo                      = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO                      ,
			Pipeline_TessellationState_CreateInfo                       = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO                        ,
			Pipeline_ViewportState_CreateInfo                           = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO                            ,
			Pipeline_RasterizationState_CreateInfo                      = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO                       ,
			Pipeline_MultisampleState_CreateInfo                        = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                         ,
			Pipeline_DepthStencilState_CreateInfo                       = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                       ,
			Pipeline_ColorBlendState_CreateInfo                         = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                         ,
			Pipeline_DynamicState_CreateInfo                            = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO                             ,
			GraphicsPipeline_CreateInfo                                 = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO                                  ,
			ComputePipeline_CreateInfo                                  = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO                                   ,
			Pipeline_Layout_CreateInfo                                  = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                                    ,
			Sampler_CreateInfo                                          = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                                            ,
			Descriptor_SetLayout_CreateInfo                             = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO                              ,
			Descriptor_Pool_CreateInfo                                  = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                                    ,
			Descriptor_SetAllocateInfo                                  = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO                                   ,
			WriteDescriptor_Set                                         = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                                           ,
			CopyDescriptor_Set                                          = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                                            ,
			Framebuffer_CreateInfo                                      = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                                        ,
			RenderPass_CreateInfo                                       = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                                        ,
			CommandPool_CreateInfo                                      = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                                       ,
			CommandBuffer_AllocateInfo                                  = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO                                   ,
			CommandBuffer_InheritanceInfo                               = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO                                ,
			CommandBuffer_BeginInfo                                     = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                                      ,
			RenderPass_BeginInfo                                        = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                                         ,
			BufferMemory_Barrier                                        = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                                          ,
			ImageMemory_Barrier                                         = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                                           ,
			Memory_Barrier                                              = VK_STRUCTURE_TYPE_MEMORY_BARRIER                                                 ,
			LoaderInstance_CreateInfo                                   = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                                    ,
			LoaderDevice_CreateInfo                                     = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                                      ,
			PhysicalDevice_SubgroupProperties                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                            ,
			BindBuffer_MemoryInfo                                       = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                                        ,
			BindImage_MemoryInfo                                        = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                                         ,
			PhysicalDevice_16Bit_StorageFeatures                        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                         ,
			MemoryDedicatedRequirements                                 = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS                                  ,
			MemoryDedicated_AllocateInfo                                = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO                                 ,
			Memory_AllocateFlagsInfo                                    = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                                     ,
			DeviceGroup_RenderPass_BeginInfo                            = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                            ,
			DeviceGroup_CommandBuffer_BeginInfo                         = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                         ,
			DeviceGroup_SubmitInfo                                      = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                                       ,
			DeviceGroup_BindSparseInfo                                  = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO                                  ,
			BindBuffer_MemoryDevice_GroupInfo                           = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                           ,
			BindImage_MemoryDevice_GroupInfo                            = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                            ,
			PhysicalDevice_GroupProperties                              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES                               ,
			Device_GroupDevice_CreateInfo                               = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO                                ,
			BufferMemory_RequirementsInfo_2                             = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2                              ,
			ImageMemory_RequirementsInfo_2                              = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2                               ,
			ImageSparseMemory_RequirementsInfo_2                        = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                        ,
			MemoryRequirements_2                                        = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                                          ,
			SparseImage_MemoryRequirements_2                            = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                             ,
			PhysicalDevice_Features_2                                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                                     ,
			PhysicalDevice_Properties_2                                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2                                   ,
			Format_Properties_2                                         = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2                                            ,
			ImageFormat_Properties_2                                    = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                                      ,
			PhysicalDevice_ImageFormatInfo_2                            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                            ,
			QueueFamily_Properties_2                                    = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                                      ,
			PhysicalDevice_MemoryProperties_2                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                            ,
			SpareImageFormat_Properites2                                = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2                               ,
			PhysicalDevice_SparceImageFormatInfo_2                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2                     ,
			PhysicalDevice_PointClippingProperites                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES                      ,
			RenderPass_InputAttachmentAspectCreateInfo                  = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO                ,
			ImageViewUsage_CreateInfo                                   = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                                   ,
			Pipeline_TessellationDomainOriginState_CreateInfo           = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO          ,
			RenderPassMulitivew_CreateInfo                              = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                              ,
			PhysicalDevice_MultiviewFeatures                            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                             ,
			PhysicalDevice_MultivewProperties                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                           ,
			PhysicalDevice_PointersFeatures                             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES                     ,
			ProtectedSubmitInfo                                         = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                                          ,
			PhysicalDevice_ProtectedMemoryFeatures                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES                      ,
			PhysicalDevice_ProtectedMemoryProperties                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES                    ,
			DeviceQueueInfo2                                            = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                                            ,
			SamplerYCBCR_Conversion_CreateInfo                          = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO                           ,
			SamplerYCBCR_Conversion_Info                                = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                                  ,
			BindImagePlane_MemoryInfo                                   = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                                   ,
			ImagePlaneMemory_RequirementsInfo                           = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                           ,
			PhysicalDevice_SamplerYCBCR_ConversionFeatures              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES              ,
			SamplerYCBCR_Conversion_ImageFormatProperties               = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES               ,
			DescriptorUpdateTemplate_CreateInfo                         = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                         ,
			PhysicalDevice_ExternalImageFormat_Info                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO                     ,
			ExternalImageFormat_Properties                              = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                               ,
			PhysicalDevice_ExternalBuffer_Info                          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                           ,
			ExternalBuffer_Properites                                   = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                                     ,
			PhysicalDevice_ID_Properties                                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                                  ,
			ExternalMemoryBuffer_CreateInfo                             = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                             ,
			ExtenralMemoryImage_CreateInfo                              = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                              ,
			ExternalMemoryAllocate_Info                                 = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                                    ,
			PhysicalDevice_ExternalFence_Info                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                            ,
			ExternalFence_Properties                                    = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                                      ,
			ExportFence_CreateInfo                                      = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                                       ,
			ExportSemaphore_CreateInfo                                  = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                                   ,
			PhysicalDevice_ExternalSemaphore_Info                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                        ,
			ExternalSemaphore_Properties                                = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                                  ,
			PhysicalDevice_Maintence_3_Properties                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                       ,
			Descriptor_SetLayoutSupport                                 = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                                  ,
			PhysicalDevice_ShaderDrawParameters_Features                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES                ,
			PhysicalDevice_Vulkan_1_1_Features                          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES                            ,
			PhysicalDevice_Vulkan_1_1_Properties                        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES                          ,
			PhysicalDevice_Vulkan_1_2_Features                          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES                            ,
			PhysicalDevice_Vulkan_1_2_Properties                        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES                          ,
			ImageFormatList_CreateInfo                                  = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO                                  ,
			AttachmentDescription_2                                     = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2                                       ,
			AttachmentReference_2                                       = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2                                         ,
			SubpassDescription_2                                        = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2                                          ,
			SubpassDependency_2                                         = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2                                           ,
			RenderPass_CreateInfo_2                                     = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2                                      ,
			Subpass_BeginInfo                                           = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO                                             ,
			Subpass_EndInfo                                             = VK_STRUCTURE_TYPE_SUBPASS_END_INFO                                               ,
			PhysicalDevice_8BitStorageFeatures                          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES                          ,
			PhysicalDevice_DriverProperites                             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES                              ,
			Physicaldevice_ShaderAtomic_Int64Features                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES                   ,
			PhysicalDevice_ShaderFloat16_Int8Features                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES                   ,
			PhysicalDevice_FloatControlsProperties                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES                      ,
			Descriptor_SetLayoutBindingFlags_CreateInfo                 = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO                ,
			PhysicalDevice_Descriptor_IndexingFeatures                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES                   ,
			PhysicalDevice_Descriptor_IndexingProperties                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES                 ,
			Descriptor_SetVariable_DescriptorCount_AllocateInfo         = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO         ,
			Descriptor_SetVariable_Descriptor_CountLayoutSupport        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT        ,
			PhysicalDevice_DepthStencil_ResolveProperties               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES               ,
			SubpassDescription_DepthStencilResolve                      = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE                      ,
			PhysicalDevice_ScalarBlockLayoutFeatures                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES                   ,
			ImageStencilUsage_CreateInfo                                = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO                                ,
			PhysicalDevice_SamplerFilterMinMax_Properties               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES               ,
			Sampler_ReductionMode_CreateInfo                            = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO                             ,
			PhysicalDevice_VulkanMemoryModelFeatures                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES                   ,
			PhysicalDevice_ImagelessFramebufferFeatures                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES                 ,
			FramebufferAttachments_CreateInfo                           = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO                            ,
			FramebufferAttachment_ImageInfo                             = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO                              ,
			RenderPassAttachment_BeginInfo                              = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO                              ,
			PhysicalDevice_UniformBuffer_StandardLayoutFeatures         = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES        ,
			PhysicalDevice_ShaderSubgroup_ExtendedTypesFeatures         = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES        ,
			PhysicalDevice_SeparateDepthStencilLayout_Features          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES        ,
			AttachmentReference_StencilLayout                           = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT                            ,
			AttachmentDescription_StencilLayout                         = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT                          ,
			PhysicalDevice_HostQueryReset_Features                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES                      ,
			PhysicalDevice_TimelineSemaphore_Features                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES                    ,
			PhysicalDevice_TimelineSemaphore_Properties                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES                  ,
			SemaphoreType_CreateInfo                                    = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO                                     ,
			TimelineSemaphore_SubmitInfo                                = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO                                 ,
			Semaphore_WaitInfo                                          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO                                            ,
			Semaphore_SignalInfo                                        = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO                                          ,
			PhysicalDevice_BufferDeviceAddress_Features                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES                 ,
			BufferDeviceAddress_Info                                    = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO                                     ,
			Buffer_OpaqueCaptureAddress_CreateInfo                      = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO                      ,
			Memory_OpaqueCaptureAddress_AllocateInfo                    = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO                    ,
			DeviceMemory_OpaqueCaptureAddress_Info                      = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO                      ,
			SwapChain_CreateInfo_KHR                                    = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                                      ,
			PresentInfo_KHR                                             = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                                               ,
			DeviceGroup_PrsentCapabilitties_KHR                         = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                          ,
			ImageSwapChain_CreateInfo_KHR                               = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR                                ,
			BindImageMemory_SwapChain_Info_KHR                          = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                           ,
			Acquire_NextImage_Info_KHR                                  = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR                                    ,
			DeviceGroup_PrsentInfo_KHR                                  = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR                                  ,
			DeviceGroup_SwapChain_CreateInfo_KHR                        = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                         ,
			DisplayMode_CreateInfo_KHR                                  = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR                                   ,
			DisplaySurface_CreateInfo_KHR                               = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR                                ,
			DispalyPrsent_Info_KHR                                      = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                                       ,
			XLIB_Surface_CreateInfo_KHR                                 = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR                                   ,
			XCB_Surface_CreateInfo_KHR                                  = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR                                    ,
			Wayland_Surface_CreateInfo_KHR                              = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR                                ,
			Andriod_Surface_CreateInfo_KHR                              = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR                                ,
			Win32_Surface_CreateInfo_KHR                                = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR                                  ,
			DebugReport_Callback_CreateInfo_EXT                         = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT                          ,
			PipelineRasterizationState_RasterizationOrder_AMD           = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD           ,
			DebugMarkerObject_NameInfo_EXT                              = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT                              ,
			DebugMarkerObject_TagInfo_EXT                               = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT                               ,
			DebugMarker_MarkerInfo_EXT                                  = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT                                   ,
			DedicatedAllocationImage_CreateInfo_NV                      = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV                      ,
			DedicatedAllocationBuffer_CreateInfo_NV                     = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV                     ,
			DedicatedAllocationMemory_AllocateInfo_NV                   = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV                   ,
			PhysicalDevice_TransformFeedback_Features_EXT               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT                ,
			PhysicalDevice_TransformFeedback_Properties_EXT             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT              ,
			PipelineRasterizationStateStream_CrateInfo_EXT              = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT            ,
			ImageView_HandleInfo_NVX                                    = VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX                                     ,
			Texture_LOD_GatherFormat_Properties_AMD                     = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD                       ,
			StreamDescriptorSurface_CreateInfo_GGP                      = VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP                      ,
			PhysicalDevice_CornerSampledImage_Features_NV               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV               ,
			ExternalMemoryImage_CreateInfo_NV                           = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV                           ,
			ExportMemory_AllocateInfo_NV                                = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV                                 ,
			ImportMemory_Win32_HandleInfo_NV                            = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV                             ,
			ExportMemory_Win32_HandleInfo_NV                            = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV                             ,
			Win32_KeyedMutex_AquireRelease_Info_NV                      = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV                      ,
			ValidationFlags_EXT                                         = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT                                           ,
			VI_Surface_CreateInfo_NN                                    = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN                                      ,
			PhysicalDevice_TextureCompression_ASTC_HDR_Features_EXT     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT      ,
			ImageView_ASTC_DecodeMode_EXT                               = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT                                ,
			PhysicalDevice_ASTC_Decode_Features_EXT                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT                       ,
			ImportMemory_Win32Handle_Info_KHR                           = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR                            ,
			ExportMemory_Win32Handle_Info_KHR                           = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR                            ,
			Memory_Win32Handle_Properties_KHR                           = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR                             ,
			Memory_Get_Win32Handle_Info_KHR                             = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR                               ,
			Import_Memory_FD_INFO_KHR                                   = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR                                      ,
			Memory_FD_Properites_KHR                                    = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR                                       ,
			Memory_GET_FD_Info_KHR                                      = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR                                         ,
			Win32_MutexAquireRelease_Info_KHR                           = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR                     ,
			ImportSemaphore_Win32Handle_Info_KHR                        = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                         ,
			ExportSemaphore_Win32Handle_Info_KHR                        = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                         ,
			D3D12_Fence_SubmitInfo_KHR                                  = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR                                    ,
			Semaphore_GetWin32Handle_Info_KHR                           = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR                            ,
			ImportSemaphore_FD_Info_KHR                                 = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR                                   ,
			Semaphore_Get_FD_Info_KHR                                   = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR                                      ,
			PhysicalDevice_PushDescriptor_Properties_KHR                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR                 ,
			CommandBuffer_Inheritance_ConditionalRendering_Info_EXT     = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT      ,
			PhysicalDevice_ConditionalRendering_Features_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT             ,
			ConditionalRendering_BeginInfo_EXT                          = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT                           ,
			PresentationRegions_KHR                                     = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR                                            ,
			Pipeline_Viewport_W_ScalingState_CreateInfo_NV              = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV               ,
			SurfaceCapabilitties_2_EXT                                  = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT                                     ,
			DisplayPower_Info_EXT                                       = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT                                         ,
			Device_EventInfo_EXT                                        = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT                                          ,
			Display_EventInfo_EXT                                       = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT                                         ,
			Swapchain_Counter_CreateInfo_EXT                            = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT                              ,
			PresentTimes_Info_Google                                    = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE                                      ,
			PhysicalDevice_MultiviewPerViewAttributes_Properties_NVX    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX   ,
			Pipeline_viewportSwizzleState_CreateInfo_NV                 = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV                 ,
			PhysicalDevice_DiscardRectangle_Properties_EXT              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT               ,
			Pipeline_Discard_RectangleState_CreateInfo_EXT              = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT               ,
			PhysicalDevice_ConservativeRasterization_Properties_EXT     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT      ,
			Pipeline_RasterizationConservativeState_CreateInfo_EXT      = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT      ,
			PhysicalDevice_DepthClipEnable_Features_EXT                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT                 ,
			Pipeline_Rasterization_DepthClipState_CreateInfo_EXT        = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT        ,
			HDR_MetaData_EXT                                            = VK_STRUCTURE_TYPE_HDR_METADATA_EXT                                               ,
			SharedPresentSurfaceCapabilities_KHR                        = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR                        ,
			ImportFence_Win32Handle_Info_KHR                            = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR                             ,
			ExportFence_Win32Handle_Info_KHR                            = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR                             ,
			Fence_GetWin32Handle_Info_KHR                               = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR                                ,
			ImportFence_FD_Info_KHR                                     = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR                                       ,
			Fence_Get_FD_Info_KHR                                       = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR                                          ,
			PhysicalDevice_PerformanceQuery_Features_KHR                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR                 ,
			PhysicalDevice_PerformanceQuery_Properties_KHR              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR               ,
			QueryPool_Performance_CreateInfo_KHR                        = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR                         ,
			PerformanceQuery_SubmitInfo_KHR                             = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR                              ,
			AcquireProfilingLock_Info_KHR                               = VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR                                ,
			PerformacneCounter_KHR                                      = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR                                        ,
			PerformanceCounter_Description_KHR                          = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR                            ,
			PhysicalDevice_Surface_Info_2_KHR                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                             ,
			SurfaceCapabilitties_2_KHR                                  = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                                     ,
			SurfaceFormat_2_KHR                                         = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                                           ,
			DisplayProperties_2_KHR                                     = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR                                       ,
			DisplayPlaneProperties_2_KHR                                = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR                                 ,
			DisplayModeProperties_2_KHR                                 = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR                                  ,
			DisplayPlane_Info_2_KHR                                     = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR                                       ,
			DisplayPlaneCapabilitties_2_KHR                             = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR                               ,
			Surface_CreateInfo_MVK                                      = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK                                    ,
			MacOS_Surface_CreateInfo_MVK                                = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK                                  ,
			DebugUtils_ObjectName_Info_EXT                              = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT                               ,
			DebugUtils_ObjectTag_Info_EXT                               = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT                                ,
			DebugUtils_Label_EXT                                        = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT                                          ,
			DebugUtils_MessengerCallback_Data_EXT                       = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT                        ,
			DebugUtils_Messenger_CreateInfo_EXT                         = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT                          ,
			Android_HardwareBufferUsage_Andriod                         = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID                          ,
			Android_HardwareBuffer_Properties_Andrioid                  = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID                     ,
			Android_HardwareBufferFormat_Properties_Android             = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID              ,
			ImportAndroidHardwareBuffer_Info_Android                    = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                    ,
			Memory_GetAndoridHardwareBuffer_Info_Android                = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                ,
			ExternalFormat_Android                                      = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID                                        ,
			PhysicalDevice_InlineUniformBlock_Features_EXT              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT              ,
			PhysicalDevice_InlineUniformBlock_Properties_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT            ,
			WriteDescriptor_SetInlineUniformBlock_EXT                   = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT                  ,
			DescriptorPool_InlineUniformBlock_CreateInfo_EXT            = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT           ,
			SampleLocations_Info_EXT                                    = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT                                      ,
			RenderPass_SampleLocations_BeginInfo_EXT                    = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT                    ,
			Pipeline_SampleLocationsState_CreateInfo_EXT                = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT                ,
			PhysicalDevice_SampleLocations_Properties_EXT               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT                ,
			Multisample_Properties_EXT                                  = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT                                     ,
			PhyscialDevice_BlendOperation_AdvancedFeatures_EXT          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT          ,
			PhysicalDevice_BlendOperationAdvanced_Properties_EXT        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT        ,
			Pipeline_ColorBlendAdvancedState_CreateInfo_EXT             = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT            ,
			Pipeline_CoverageToColorState_CreateInof_NV                 = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV                ,
			Bind_AccelerationStructureMemory_Info_KHR                   = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_KHR                    ,
			WriteDescriptorSet_AccelerationStruture_KHR                 = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR                ,
			AcclerationStructure_BuildGeometry_Info_KHR                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR                 ,
			AccelerationStructure_CreateGeometryType_Info_KHR           = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR           ,
			AccelrationStructure_DeviceAddress_Info_KHR                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR                 ,
			AccelerationStructure_GeometryAABBS_Data_KHR                = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR                 ,
			AccelerationStructure_Geometry_Instance_Data_KHR            = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR             ,
			AccelerationStructure_GeometryTriangles_Data_KHR            = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR             ,
			AccelerationStructure_Geometry_KHR                          = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR                            ,
			//AccelerationStructure_Info_KHR                              = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_KHR                                ,
			AccelerationStructure_MemoryRequirements_Info_KHR           = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_KHR            ,
			AccelerationStructure_Version_KHR                           = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_KHR                             ,
			Copy_AccelerationStructure_Info_KHR                         = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR                           ,
			CopyAccelerationStructureTOMemory_Info_KHR                  = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR                 ,
			Copy_MemopryToAccelerationStructure_Info_KHR                = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR                 ,
			PhysicalDevice_Raytracing_Features_KHR                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_FEATURES_KHR                       ,
			PhysicalDevice_Raytracing_Properties_KHR                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_KHR                     ,
			Raytracing_Pipeline_CreateInfo_KHR                          = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR                           ,
			Raytracing_ShaderGroup_CreateInfo_KHR                       = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR                       ,
			AccelerationStructure_CreateInfo_KHR                        = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR                         ,
			Raytracing_PipelineInterface_CreateInfo_KHR                 = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR                 ,
			Pipeline_CoverageModulationState_CreateInfo_NV              = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV              ,
			PhysicalDevice_ShaderSM_Builtins_Features_NV                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV                 ,
			PhyscialDevice_ShaderSM_Builtins_Properties_NV              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV               ,
			DRM_FormatModifier_PropertiesList_EXT                       = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT                        ,
			DRM_FormatModifier_Properties_EXT                           = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT                             ,
			PhysicalDevice_ImageDRM_FormatModifier_Info_EXT             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT             ,
			ImageDRM_FomratModifierList_CreateInfo_EXT                  = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT                 ,
			ImageDRM_FormatModifierExplicit_CreateInfo_EXT              = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT             ,
			ImageDRM_FormatModifierProperties_EXT                       = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT                       ,
			ValidationCache_CreateInfo_EXT                              = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT                               ,
			ShaderModule_ValidationCache_CreateInfo_EXT                 = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT                 ,
			Pipeline_viewportShadingRateImageState_CreateInfo_NV        = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV      ,
			PhysicalDevice_ShadingRateImage_Features_NV                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV                 ,
			PhysicalDevice_ShaderRateImage_Properties_NV                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV               ,
			Pipeline_ViewportCoarseSampleOrder_State_CreateInfo_NV      = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV     ,
			Raytracing_Pipeline_CreateInfo_NV                           = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV                            ,
			AccelerationStructure_CreateInfo_NV                         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV                          ,
			Geometry_NV                                                 = VK_STRUCTURE_TYPE_GEOMETRY_NV                                                    ,
			GeometryTriangles_NV                                        = VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV                                          ,
			Geometry_AABB_NV                                            = VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV                                               ,
			AccelerationStructure_MemoryRequirements_Info_NV            = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV             ,
			PhysicalDevice_DeviceRaytracing_Properties_NV               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV                      ,
			Ratracing_ShaderGroup_CreateInfo_NV                         = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV                        ,
			AccelerationStructure_Info_NV                               = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV                                 ,
			PhysicalDevice_RepresentativeFragmentTest_Features_NV       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV       ,
			Pipeline_Representative_FragmentTestState_CreateInfo_NV     = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV     ,
			PhysicalDevice_ImageView_ImgeFormat_Info_EXT                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT               ,
			FilterCubic_ImageView_ImageFormat_Properties_EXT            = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT            ,
			DeviceQueue_GlobalPriority_CreateInfo_EXT                   = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT                   ,
			ImportMemory_HostPointer_Info_EXT                           = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT                            ,
			MemoryHost_PointerProperties_EXT                            = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT                             ,
			PhysicalDevice_ExternalMemoryHost_Properites_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT            ,
			PhysicalDevice_ShaderClock_Features_KHR                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR                      ,
			Pipeline_CompilerControl_CreateInfo_AMD                     = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD                      ,
			Calibrated_Timestamp_Info_EXT                               = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT                                  ,
			PhysicalDevice_ShaderCore_Properties_AMD                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD                     ,
			DeviceMemory_Overallocation_CreateInfo_AMD                  = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD                   ,
			PhysicalDevice_VertexAttributeDivisor_Properties_EXT        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT        ,
			Pipeline_VertexInput_DivisorState_CreateInfo_EXT            = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT            ,
			PhysicalDevice_VertexAttributeDevisor_Features_EXT          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT          ,
			PresentFrameToken_GGP                                       = VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP                                        ,
			Pipeline_CreationFeedback_CreateInfo_EXT                    = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT                     ,
			PhysicalDevice_ComputeShaderDerivatives_Features_NV         = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV         ,
			PhysicalDevice_MeshShader_Features_NV                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV                        ,
			PhysicalDevice_MeshShader_Properties_NV                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV                      ,
			PhysicalDevice_FragmentShaderBarycentric_Features_NV        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV        ,
			PhysicalDevice_ShaderImageFootprint_Features_NV             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV             ,
			Pipeline_ViewportExclusiveScissorState_CreateInfo_NV        = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV       ,
			PhysicalDevice_ExclusiveScissor_features_NV                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV                  ,
			CheckpointData_NV                                           = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV                                             ,
			QueueFamilyCheckpoint_Properties_NV                         = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV                          ,
			PhysicalDevice_ShaderIntegerFunctions_2_Features_Intel      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL      ,
			QueryPool_CreateInfo_Intel                                  = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL                                   ,
			InitializePerformanceAPI_Info_Intel                         = VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL                          ,
			PerformanceMarker_Info_Intel                                = VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL                                  ,
			PerformanceStreamMarker_info_Intel                          = VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL                           ,
			PerformanceOverride_Info_Intel                              = VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL                                ,
			PerformanceConfiguration_Aquire_Info_Intel                  = VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL                   ,
			PhysicalDevice_PCI_BUS_Info_Properties_EXT                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT                    ,
			Display_NativeHDR_SurfaceCapabbilitties_AMD                 = VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD                    ,
			SwapChain_DisplayNativeHDR_CreateInfo_AMD                   = VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD                   ,
			ImagepipeSurface_CreateInfo_FUCHSIA                         = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA                          ,
			Metal_Surface_CreateInfo_EXT                                = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT                                  ,
			PhysicalDevice_FragmentDensity_MapFeatures_EXT              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT              ,
			PhysicalDevice_FragmentDensityMap_Properties_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT            ,
			RenderPass_FragmentDensityMap_CreateInfo_EXT                = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT               ,
			PhysicalDevice_SubgroupSizeControl_Properties_EXT           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT           ,
			Pipeline_ShaderStage_RequiredSubgroupSize_CreateInfo_EXT    = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT   ,
			PhysicalDevice_SubgroupSizeControl_Features_EXT             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT             ,
			PhysicalDevice_ShaderCore_Properties_2_AMD                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD                   ,
			PhysicalDeice_CoherentMemory_Features_AMD                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD                   ,
			PhysicalDevice_MemoryBudget_Properties_EXT                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT                   ,
			PhysicalDevice_MemoryPriority_Features_EXT                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT                   ,
			MemoryPriority_AllocateInfo_EXT                             = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT                              ,
			Surface_ProtectedCapabilitties_KHR                          = VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR                             ,
			PhysicalDevice_DedicatedAllocationImageAliasing_Features_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
			PhysicalDevice_BufferDeviceAddress_Features_EXT             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT             ,
			BufferDeviceAddress_CreateInfo_EXT                          = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT                          ,
			PhysicalDevice_ToolProperties_EXT                           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT                            ,
			ValidationFeatures_EXT                                      = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT                                        ,
			PhysicalDevice_CooperativeMatrix_Features_NV                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV                 ,
			CooperativeMatrix_Properties_NV                             = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV                               ,
			PhysicalDevice_CooperativeMatrix_Proeprties_NV              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV               ,
			PhysicalDevice_CoverageReductionMode_Features_NV            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV            ,
			Pipeline_CoverageReductionState_CreateInfo_NV               = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV               ,
			Framebufer_MixedSamplesCombination_NV                       = VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV                       ,
			PhyscialDevice_FragmentShader_Interlock_Features_EXT        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT         ,
			PhysicalDevice_YCBCR_ImageArrays_Features_EXT               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT                ,
			Surface_FullscreenExclusive_Info_EXT                        = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT                         ,
			Surface_Capabilities_FullscreenExclusive_EXT                = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT                 ,
			Surface_FullscreenExclusive_Win32_Info_EXT                  = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT                   ,
			HeadlessSurface_CreateInfo_EXT                              = VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT                               ,
			PhysicalDevice_LineRasterization_Features_EXT               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT                ,
			Pipeline_RasterizationLineState_CreateInfo_EXT              = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT              ,
			PhysicalDevice_LineRasterization_Properties_EXT             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT              ,
			PhysicalDevice_IndexType_Uint8_Features_EXT                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT                  ,
			DeferredOperation_Info_KHR                                  = VK_STRUCTURE_TYPE_DEFERRED_OPERATION_INFO_KHR                                    ,
			PhysicalDevice_PipelineExecutableProperties_Features_KHR    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR    ,
			Pipeline_Info_KHR                                           = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR                                              ,
			Pipeline_ExecutableProperties_KHR                           = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR                             ,
			Pipeline_ExecutableInfo_KHR                                 = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR                                   ,
			Pipeline_ExecutableStatistic_KHR                            = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR                              ,
			Pipeline_Executable_InternalRepresentation_KHR              = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR                ,
			PhysicalDevice_ShaderDemoteToHelperInvocationFeatures_EXT   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
			PhysicalDevice_DeviceGeneratedCommand_Properties_NV         = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV        ,
			GraphicsShaderGroup_CreateInfo_NV                           = VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV                           ,
			GraphicsPipeline_ShaderGroups_CreateInfo_NV                 = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV                 ,
			IndirectCommands_LayoutToken_NV                             = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV                              ,
			IndirectCommands_Layout_CreateInfo_NV                       = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV                        ,
			GeneratedCommands_Info_NV                                   = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV                                     ,
			GeneratedCommands_MemoryRequirements_Info_NV                = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV                 ,
			PhysicalDevice_DeviceGeneratedCommand_Features_NV           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV          ,
			PhysicalDevice_TexelBufferAlignment_Features_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT            ,
			PhysicalDevice_TEXELBuffer_AlignmentProperties_EXT          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT          ,
			CommandBufferInheritance_RenderPassTransform_Info_QCOM      = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM     ,
			RenderPass_Transform_BeginInfo_QCOM                         = VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM                          ,
			PipelineLibrary_CreateInfo_KHR                              = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR                               ,
			PhysicalDevice_PipelineCreationCacheControl_Features_EXT    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT   ,
			PhysicalDevice_DiagnosticsConfig_Features_NV                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV                 ,
			DeviceDiagnosticsConfig_CreateInfo_NV                       = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV                       ,
			PhysicalDevice_VariablePointer_Features                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES                      ,
			PhysicalDevice_ShaderDrawParameter_Features                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES                 ,
			DebugReport_CreateInfo_EXT                                  = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT                                   ,
			RenderPass_Multiview_CreateInfo_KHR                         = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR                          ,
			PhysicalDevice_Multiview_Features_KHR                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR                         ,
			PhysicalDevice_multiview_Properties_KHR                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR                       ,
			PhysicalDevice_Features_2_KHR                               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR                                 ,
			PhysicalDevice_Properties_2_KHR                             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR                               ,
			FormatProperties_2_KHR                                      = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                                        ,
			ImageFormat_Properties_2_KHR                                = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR                                  ,
			PhysicalDevice_ImageFormat_Info_2_KHR                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR                        ,
			QueueFamily_Properties_2_KHR                                = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR                                  ,
			PhysicalDevice_MemoryProperties_2_KHR                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR                        ,
			SpraseImageFormat_Properties_2_KHR                          = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR                           ,
			PhysicalDevice_SparseImageFormat_Info_2_KHR                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR                 ,
			MemoryAllocateFlags_Info_KHR                                = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR                                 ,
			DeviceGroup_RenderPass_BeginInfo_KHR                        = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR                        ,
			DeviceGroup_CommandBuffer_BeginInfo_KHR                     = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR                     ,
			DeviceGroup_SubmitInfo_KHR                                  = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR                                   ,
			DeviceGroup_BindSparse_Info_KHR                             = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR                              ,
			BindBuffer_MemoryDeviceGroup_Info_KHR                       = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR                       ,
			BindImage_MemoryDeviceGroup_Info_KHR                        = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR                        ,
			PhysicalDeviceGroup_Properties_KHR                          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR                           ,
			DeviceGroup_Device_CreateInfo_KHR                           = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR                            ,
			PhysicalDevice_ExternalImageFormat_Inf_KHR                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR                 ,
			ExternalImageFormat_Properties_KHR                          = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR                           ,
			PhysicalDevice_ExternalBuffer_Info_KHR                      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR                       ,
			ExternalBuffer_Propertis_KHR                                = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR                                 ,
			PhysicalDevice_ID_Properties_KHR                            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR                              ,
			ExternalMemory_Buffer_CreateInfo_KHR                        = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR                         ,
			ExternalMemoryImage_CreateInfo_KHR                          = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR                          ,
			Export_MemoryAllocate_Info_KHR                              = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR                                ,
			PhysicalDevice_ExternalSemaphore_Info_KHR                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR                    ,
			External_Semaphore_Properties_KHR                           = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR                              ,
			Export_Semaphore_CreateInfo_KHR                             = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR                               ,
			PhysicalDevice_Shader_Float16_Int8_Features_KHR             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR               ,
			PhysicalDevice_Float16_Int8_Features_KHR                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR                      ,
			PhysicalDevice_16BitStorage_Features_KHR                    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR                     ,
			Descriptor_UpdateTemplate_CreateInfo_KHR                    = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR                     ,
			Surface_Capabilities_2_EXT                                  = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT                                      ,
			PhysicalDevice_Imageless_Framebuffer_Features_KHR           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR             ,
			Framebuffer_Attachments_CreateInfo_KHR                      = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR                        ,
			Framebuffer_Attachment_ImageInfo_KHR                        = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR                          ,
			RenderPass_Attachment_BeginInfo_KHR                         = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR                          ,
			Attachment_Description_2_KHR                                = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR                                   ,
			Attachment_Reference_2_KHR                                  = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR                                     ,
			Subpass_Description_2_KHR                                   = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR                                      ,
			Subpass_Dependency_2_KHR                                    = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR                                       ,
			RenderPass_CreateInfo_2_KHR                                 = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR                                  ,
			Subpass_BeginInfo_HR                                        = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR                                         ,
			Subpass_EndInfo_KHR                                         = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR                                           ,
			PhysicalDevice_ExternalFence_Info_KHR                       = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR                        ,
			ExternalFence_Properties_KHR                                = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR                                  ,
			ExportFence_CreateInfo_KHR                                  = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR                                   ,
			PhysicalDevice_PointClipping_Properties_KHR                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR                  ,
			RenderPass_InputAttachmentAspect_CreateInfo_KHR             = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR            ,
			ImageViewUsage_CreateInfo_KHR                               = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR                               ,
			Pipeline_TessellationDomain_OriginState_CreateInfo_KHR      = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR      ,
			PhysicalDevice_VariablePointer_Features_KHR                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR                  ,
			PhysicalDevice_VariablePointers_Features_KHR                = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR                 ,
			MemoryDedicated_Requirements_KHR                            = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR                              ,
			MemoryDedicated_AllocateInfo_KHR                            = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR                             ,
			PhysicalDevice_SamplerFilter_MinMax_Properties_EXT          = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT           ,
			Sampler_ReductionMode_CreateInfo_EXT                        = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT                         ,
			Buffer_MemoryRequirements_Inof_2_KHR                        = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR                          ,
			Image_MemoryRequirements_Info_2_KHR                         = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR                           ,
			ImageSparse_MemoryRequirements_Info_2_KHR                   = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR                    ,
			MemoryRequirements_2_KHR                                    = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR                                      ,
			SparseImage_MemoryRequirements_2_KHR                        = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR                         ,
			ImageFormatList_CreateInfo_KHR                              = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR                              ,
			SamplerYCBCR_Conversion_CreateInfo_KHR                      = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR                       ,
			Sampler_YCBCR_ConversionInfo_KHR                            = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR                              ,
			BindImagePlane_MemoryInfo_KHR                               = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR                               ,
			ImagePlane_MemoryRequirements_Info_KHR                      = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR                       ,
			PhysicalDevice_Sampler_YCBCR_Conversion_Features_KHR        = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR          ,
			SamplerYCBCR_Conversion_ImageFormat_Properties_KHR          = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR           ,
			Buffer_MemoryInfo_KHR                                       = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR                                    ,
			BindImage_MemoryInfo_KHR                                    = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR                                     ,
			Descriptor_SetLayoutBindingFlags_CreateInfo_EXT             = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT            ,
			PhysicalDevice_DescriptorIndexing_Features_EXT              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT               ,
			PhysicalDevice_Descriptor_IndexingProperties_EXT            = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT             ,
			DescriptorSet_VariableDescriptorCount_AllocateInfo_EXT      = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT     ,
			DescriptorSet_VaraibleDescriptorCount_LayoutSupport_EXT     = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT    ,
			Bind_AccelerationStructure_MemoryInfo_NV                    = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV                     ,
			WriteDescriptorSet_AccelerationStructure_NV                 = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV                 ,
			PhysicalDevice_Maintenance_3_Properties_KHR                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR                   ,
			DescriptorSet_LayoutSupport_KHR                             = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR                              ,
			PhysicalDevice_ShaderSubgroup_ExtendedTypes_Features_KHR    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR    ,
			PhysicalDevice_8BitStorage_Features_KHR                     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR                      ,
			PhysicalDevice_Shader_AtomicInt64_Features_KHR              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR               ,
			PhysicalDevice_DriverProperties_KHR                         = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR                          ,
			PhysicalDevice_FloatControls_Properties_KHR                 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR                  ,
			PhysicalDevice_DepthStencilResolve_Properties_KHR           = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR           ,
			Subpass_Description_DepthStencilResolve_KHR                 = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR                  ,
			PhysicalDevice_TimelineSemaphore_Features_KHR               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR                ,
			PhysicalDevice_TimelineSemaphoreProperties_KHR              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR              ,
			SemaphoreType_CreateInfo_KHR                                = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR                                 ,
			TimelineSemaphore_SubmitInfo_KHR                            = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR                             ,
			Semaphore_WaitInfo_KHR                                      = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR                                        ,
			Sempaphore_SignalInfo_KHR                                   = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR                                      ,
			PhysicalDevice_Vulakn_MemoryModel_Features_KHR              = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR               ,
			PhysicalDevice_ScalarBlock_LayoutFeatures_EXT               = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT               ,
			PhysicalDevice_SeparateDepth_StencilLayouts_Features_KHR    = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR    ,
			AttachmentReference_StencilLayout_KHR                       = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR                        ,
			AttachmentDescription_StencilLayout_KHR                     = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR                      ,
			PhysicalDevice_BufferAddress_Features_EXT                   = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT                    ,
			BufferDevice_AddressInfo_EXT                                = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT                                 ,
			Extesnion_ImageStencilUsage_CreateInfo                      = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT                            ,
			PhysicalDevice_UniformBufferStandardLayout_Features_KHR     = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR    ,
			PhysicalDevice_BufferDevice_AddressFeatures_KHR             = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR             ,
			BufferDevice_Address_Info                                   = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR                                 ,
			BufferOpaque_CaptureAddress_Createinfo                      = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR                  ,
			MemoryOpaque_CaptureAddressAllocate_Info_KHR                = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR                ,
			DeviceMemory_OpaqueCaptureAddress_Info_KHR                  = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR                  ,
			PhysicalDevice_HostQuery_ResetFeatures_EXT                  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT                  ,

			// Not found... (1.2.141)
			Device_PrivateData_CreateInfo_EXT = 1000295001,   // VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT,

			Max_Enum                                                    = VK_STRUCTURE_TYPE_MAX_ENUM
		};
		

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubgroupFeatureFlagBits">Specification</a> @ingroup APISpec_Limits */
		enum class ESubgroupFeaturesFlag : uint32
		{
			Basic           = VK_SUBGROUP_FEATURE_BASIC_BIT           ,
			Vote            = VK_SUBGROUP_FEATURE_VOTE_BIT            ,
			Arithemtic      = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT      ,
			Ballot          = VK_SUBGROUP_FEATURE_BALLOT_BIT          ,
			Shuffle         = VK_SUBGROUP_FEATURE_SHUFFLE_BIT         ,
			ShuffleRealtive = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
			Clustered       = VK_SUBGROUP_FEATURE_CLUSTERED_BIT       ,
			Quad            = VK_SUBGROUP_FEATURE_QUAD_BIT            ,

			// Provided by VK_NV_shader_subgroup_partitioned
			Partitioned_NV  =  VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV ,

			VT_SpecifyBitmaskable = VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubpassContents">Specification</a> @ingroup APISpec_Render_Pass */
		enum class ESubpassContents : uint32
		{
			Inline                  = VK_SUBPASS_CONTENTS_INLINE                   ,
			SecondaryCommandBuffers = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubpassDescriptionFlagBits">Specification</a> @ingroup APISpec_Render_Pass */
		enum class ESubpassDescriptionFlag : uint32 { VT_SpecifyBitmaskable = sizeof(uint32) };

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSurfaceTransformFlagBitsKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
		enum class ESurfaceTransformFlag : uint32
		{
			Identity                     = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                    ,
			Rotate_90                    = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                   ,
			Rotate_180                   = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                  ,
			Rotate_270                   = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                  ,
			Horizontal_Mirror            = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR           ,
			Horizontal_Mirror_Rotate_90  = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR ,
			Horizontal_Mirror_Rotate_180 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
			Horizontal_Mirror_Rotate_270 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
			Inherit                      = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                     ,

			VT_SpecifyBitmaskable = VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSwapchainCreateFlagBitsKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
		enum class ESwapchainCreateFlag : uint32
		{
			SplitInstanceBindRegions = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR ,
			CreateProtected          = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                   ,
			CreateMutableFormat      = VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR              ,

			VT_SpecifyBitmaskable = VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSystemAllocationScope">Specification</a> @ingroup APISpec_Memory_Allocation */
		enum class ESystemAllocationScope : uint32
		{
			Command  = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND ,
			Object   = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT  ,
			Cache    = VK_SYSTEM_ALLOCATION_SCOPE_CACHE   ,
			Device   = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE  ,
			Instance = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkValidationCheckEXT">Specification</a> @ingroup VkValidationCheckEXT */
		enum class EValidationCheck : uint32
		{
			All     = VK_VALIDATION_CHECK_ALL_EXT    ,
			Shaders = VK_VALIDATION_CHECK_SHADERS_EXT 
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkValidationFeatureEnableEXT">Specification</a> @ingroup APISpec_Initialization  */
		enum class EValidationFeatureEnable : uint32
		{
			GPU_Assisted                   = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT                     ,
			GPU_AssistedReserveBindingSlot = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
			BestPractices                  = VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT                   ,
			DebugPrintF                    = VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT 
		};

		/**
		* @details
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVendorId.html">Specification</a> @ingroup APISpec_Devices_and_Queues
		*/
		enum class EVendorID : uint32
		{
			VIV      = VK_VENDOR_ID_VIV     ,
			VSI      = VK_VENDOR_ID_VSI     ,
			KAZAN    = VK_VENDOR_ID_KAZAN   ,
			CODEPLAY = VK_VENDOR_ID_CODEPLAY,
			MESA     = VK_VENDOR_ID_MESA    
		};

		/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkVertexInputRate">Specification</a> @ingroup APISpec_Fixed-Function_Vertex_Processing */
		enum class EVertexInputRate : uint32
		{
			Vertex   = VK_VERTEX_INPUT_RATE_VERTEX,
			Instance = VK_VERTEX_INPUT_RATE_INSTANCE
		};
    }

	/** @} */
}




/*!
@file VT_Backend.hpp

@brief Vaulted Thermals: Backend

@details Contains implementation related to library backend.
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V0
	{
		/** 
		@addtogroup Vault_0
		@{
		*/

	#ifdef VT_Option__Use_STL_Exceptions
		/**
		@brief STL Exceptions (Note: right now the library does not STL exceptions but may in the future...):
		*/
		constexpr bool UseSTL_Exceptions = true;
	#else
		/**
		@brief STL Exceptions (Note: right now the library does not STL exceptions but may in the future...):
		*/
		constexpr bool UseSTL_Exceptions = false;
	#endif

		/**
		@brief Note: I do not use these as no optimization via inlining has been looked into as of yet...
		*/
	#ifdef VT_Option__Use_Inline_Hinting

		/** @brief Inline specification set to standard inline. */
	#define VT_InlineSpecifier inline

	#elif VT_Option__Use_Forced_Inlining

	#ifdef _WIN32

		/** @brief Inline specification set to _forceinline. (Will force compiler to inline) */
	#define VT_InlineSpecifier __forceinline

	#else

		/** @brief Inline specification set to none. (Does not do influence compiler) */
	#define VT_InlineSpecifier 

	#endif
	#else

		/** @brief Inline specification set to none. (Does not do influence compiler) */
	#define VT_InlineSpecifier 

	#endif

		/** @brief Determines whether to return an result code for a function based on if STL exceptions are enabled. */
		using ShouldUse_EResult = typename std::conditional<V0::UseSTL_Exceptions, void, EResult>::type;

		/**
		@brief Used when creating fake VulkanAPI structures for platform abstraction uses.
		*/
		struct DummyBase
		{};

		/** @struct VKStruct_Base

		@brief Base struct for wrapping Vulkan native C API Structs.

		@details 
		*/
		template<typename VulkanType, EStructureType TemplateSpecifiedStype = EStructureType::Max_Enum>
		struct VKStruct_Base
		{
			/**
			* @typedef EType
			* 
			* @brief Defines the EType enum to the default vkStructureType enum for now.
			*/
			using EType = EStructureType;

			/** @brief Keeps track of the structure type enum for a native vulkan struct (If an enum does not exist Max_Enum is used instead) */
			static constexpr EType STypeEnum = TemplateSpecifiedStype;

			/** 
			@typdef VkType 

			@brief Keeps record of the struct's inherent vulkan equivalent.
			*/
			using VkType = VulkanType;   

			/**
			@brief Does a pointer r-cast to the desired struct type. 
			(Since any wrapped vulkan struct have the same members this is possible)
			*/
			operator VulkanType()
			{
				return *reinterpret_cast<VulkanType*>(this);
			}

			/**
			@brief Does a pointer r-cast to the desired struct type. 
			(Since any wrapped vulkan struct have the same members this is possible)
			*/
			operator const VulkanType& () const
			{
				return *reinterpret_cast<const VulkanType*>(this);
			}

			/**
			@brief Does a pointer r-cast to the desired struct type. 
			(Since any wrapped vulkan struct have the same members this is possible)
			*/
			operator VulkanType*()
			{
				return reinterpret_cast<VulkanType*>(this);
			}

			/**
			@brief Does a pointer r-cast to the desired struct type. 
			(Since any wrapped vulkan struct have the same members this is possible)
			*/
			operator const VulkanType*() const
			{
				return reinterpret_cast<const VulkanType*>(this);
			}
		};

		template<typename Enum, typename = void>
		/**
		@brief Used when the enum does not meet the criteria for bitmaskable.
		*/
		struct IsBitmaskable : std::false_type
		{};

		template<typename Enum>
		/**
		@brief Will be defined with a true_type when enum has the VT_SpecifyBitmaskable enum value.
		*/
		struct IsBitmaskable<Enum, decltype(static_cast<void>(Enum::VT_SpecifyBitmaskable))> : std::is_enum<Enum>
		{};

		template <typename Enum>
		/**
		@brief Returns true if IsBitmaskable is false.
		*/
		constexpr typename std::enable_if<IsBitmaskable<Enum>::value, bool>::
			type Bitmaskable() noexcept
		{
			return static_cast<std::size_t>(Enum::VT_SpecifyBitmaskable) > std::size_t(0) ? true : false;
		}

		template <typename Enum> 
		/**
		@brief Returns false if bitmaskable is false (Default case).
		*/
		constexpr typename std::enable_if<!IsBitmaskable<Enum>::value, bool>::
			type Bitmaskable() noexcept
		{
			return false;
		}

		template<typename EnumType, typename BitmaskRepresentation>
		/**
		A wrapper object for bitmasks that allows for typesafe bitmask operations.
		*/
		class Bitmask
		{
		private:
			static_assert(Bitmaskable<EnumType>(), "EnumType must be of Bitmaskable type.");

			using _ThisType = Bitmask<EnumType, BitmaskRepresentation>;

		public:

			using Enum           = EnumType             ;
			using Representation = BitmaskRepresentation;

			Bitmask() : mask(0) {}

			Bitmask(Representation _mask) : mask(_mask)
			{}

			template<typename... BitTypes>
			Bitmask(const BitTypes... _bits) : mask(0)
			{
				mask = (Representation(_bits) | ...);
			}

			template<typename... BitType>
			void Add(const BitType... _bits)
			{
				mask |= (Representation(_bits) | ...);
			}

			template<typename... BitType>
			bool CheckForEither(const BitType... _bits) const
			{
				return (mask & (Representation(_bits) | ...)) != 0;
			}

			template<typename... BitType>
			void Clear(const BitType... _bits)
			{
				if (mask <= 0) return;

				mask &= ~(Representation(_bits) | ...);
			}

			bool HasFlag(const Enum _bit) const
			{
				return (mask & Representation(_bit)) == Representation(_bit);
			}

			template<typename... BitType>
			bool HasExactly(const BitType... _bits) const
			{
				return (mask & (Representation(_bits) | ...)) == mask;
			}

			bool HasAnyFlag() const { return mask != 0 ? true : false; }
			bool IsZero    () const { return mask == 0 ? true : false; }	

			void Reset() { mask = 0; }

			template<typename... BitType>
			void Set(const BitType... _bits)
			{
				mask = (Representation(_bits) | ...);
			}

			template<typename... BitType>
			void Toggle(const BitType... _bits)
			{
				mask ^= (Representation(_bits) | ...);
			}

			operator Representation() const { return mask; }

			_ThisType& operator= (const Representation _mask ) { mask = _mask      ; return *this; }
			_ThisType& operator= (const _ThisType      _other) { mask = _other.mask; return *this; }

			_ThisType& operator&= (const Representation _mask ) { mask &= mask       ; return *this; }
			_ThisType& operator&= (const _ThisType      _other) { mask &= _other.mask; return *this; }

			_ThisType& operator|= (const Representation _mask ) { mask |= mask       ; return *this; }
			_ThisType& operator|= (const _ThisType      _other) { mask |= _other.mask; return *this; }	

			_ThisType& operator^= (const Representation _mask ) { mask ^= mask       ; return *this; }
			_ThisType& operator^= (const _ThisType      _other) { mask ^= _other.mask; return *this; }	

			_ThisType& operator<<= (const Representation _mask ) { mask <<= mask       ; return *this; }
			_ThisType& operator>>= (const _ThisType      _other) { mask >>= _other.mask; return *this; }	

			_ThisType operator~ () const { return ~mask; }

			Representation operator& (const Representation _other) const { return mask & _other     ; }
			_ThisType      operator& (const _ThisType      _other) const { return mask & _other.mask; }

			Representation operator| (const Representation _other) const { return mask | _other     ; }
			_ThisType      operator| (const _ThisType      _other) const { return mask | _other.mask; }

			Representation operator^ (const Representation _other) const { return mask ^ _other     ; }
			_ThisType      operator^ (const _ThisType      _other) const { return mask ^ _other.mask; }

			Representation operator<< (const Representation _other) const { return mask << _other     ; }
			_ThisType      operator>> (const _ThisType      _other) const { return mask >> _other.mask; }

			bool operator== (const Representation _other) const { return mask == _other     ; }
			bool operator== (const _ThisType      _other) const { return mask == _other.mask; }

			bool operator!= (const Representation _other) const { return mask != _other     ; }
			bool operator!= (const _ThisType      _other) const { return mask != _other.mask; }

		protected:

			Representation mask;
		};

		/** @} */
	}
}




/*!
@file VT_Types.hpp

@brief Vaulted Thermals: Types

@details
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
#pragma region Common Object Types

	/** 
	@defgroup Common_Object_Types

	<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-common-objects">Common Object Types Specification</a>
	*/

	namespace Corridors
	{
		using V0::Bitmask;

		/** 
		@addtogroup Corridors
		@{
		*/

		/** 
		@addtogroup Common_Object_Types
		@ingroup Corridors
		@{
		*/

		/**
		@ingroup APISpec_Fundamentals
		@brief Vulkan's boolean type.
		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBool32">Specification</a> 
		*/
		using Bool = VkBool32;

		/** @ingroup APISpec_Fundamentals @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-commandsyntax">Specification</a>  */
		using DeviceAddress = VkDeviceAddress;

		/** @ingroup APISpec_Fundamentals @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceSize">Specification</a>  */
		using DeviceSize = VkDeviceSize;

		/**
		* @ingroup APISpec_Fundamentals
		* @brief Can be used to facilitate iterating through a read-only structure pointer chain.
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBaseInStructure">Specification</a> 
		*/
		struct Base_InStructure : V0::VKStruct_Base<VkBaseInStructure>
		{
			EType             SType;
			const Base_InStructure* Next ;
		};

		/**
		* @ingroup APISpec_Fundamentals
		* @brief Can be used to facilitate iterating through a structure pointer chain that returns data back to the application.
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBaseOutStructure">Specification</a> 
		*/
		struct Base_OutStructure : V0::VKStruct_Base<VkBaseOutStructure>
		{
			EType              SType;
			const Base_OutStructure* Next ;
		};

		/** 
		@ingroup APISpec_Fundamentals
		@brief Structure specifying a two-dimensional offset.

		@details
		Offsets are used to describe a pixel location within an image or framebuffer, 
		as an (x,y) location for two-dimensional images, or an (x,y,z) location for three-dimensional images.
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_offsets">Offsets Specification</a>
		*/
		struct Offset2D : V0::VKStruct_Base<VkOffset2D>
		{
			sint32 X, Y;

			bool operator==(const Offset2D _other) {  return X == _other.X && Y == _other.Y ? true : false; }
			bool operator!=(const Offset2D _other) {  return X != _other.X || Y != _other.Y ? true : false; }
		};

		/** 
		@ingroup APISpec_Fundamentals
		@brief Structure specifying a three-dimensional offset.
		@details
		Offsets are used to describe a pixel location within an image or framebuffer, 
		as an (x,y) location for two-dimensional images, or an (x,y,z) location for three-dimensional images.
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_offsets">Offsets Specification</a>
		*/
		struct Offset3D : V0::VKStruct_Base<VkOffset3D>
		{
			sint32 X, Y, Z;

			bool operator==(const Offset3D& _other) { return X == _other.X && Y == _other.Y && Z == _other.Z ? true : false; }
			bool operator!=(const Offset3D& _other) { return X != _other.X || Y != _other.Y || Z != _other.Z ? true : false; }
		};

		/** 
		@ingroup APISpec_Fundamentals
		@brief Structure specifying a two-dimensional extent.
		@details
		Extents are used to describe the size of a rectangular region of pixels within an image or framebuffer, 
		as (width,height) for two-dimensional images, or as (width,height,depth) for three-dimensional images.
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExtent2D.html">Extent-2D Specification</a>
		*/
		struct Extent2D : V0::VKStruct_Base<VkExtent2D>
		{
			uint32 Width, Height;

			bool operator==(const Extent2D _other) { return Width == _other.Width && Height == _other.Height ? true : false; }
			bool operator!=(const Extent2D _other) { return Width != _other.Width || Height != _other.Height ? true : false; }
		};

		/** 
		@ingroup APISpec_Fundamentals
		@brief Structure specifying a three-dimensional extent.
		@details
		Extents are used to describe the size of a rectangular region of pixels within an image or framebuffer, 
		as (width,height) for two-dimensional images, or as (width,height,depth) for three-dimensional images.
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExtent3D.html">Extent-3D Specification</a>
		*/
		struct Extent3D : V0::VKStruct_Base<VkExtent3D>
		{
			uint32 Width, Height, Depth;

			bool operator==(const Extent3D& _other) { return Width == _other.Width && Height == _other.Height && Depth == _other.Depth ? true : false; }
			bool operator!=(const Extent3D& _other) { return Width != _other.Width || Height != _other.Height || Depth == _other.Depth ? true : false; }
		};

		/** 
		@ingroup APISpec_Fundamentals
		@brief Structure specifying a two-dimensional subregion.
		@details
		Rectangles are used to describe a specified rectangular region of pixels within an image or framebuffer. 
		Rectangles include both an offset and an extent of the same dimensionality, as described above. 
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_rectangles">Specification</a> 
		*/
		struct Rect2D : V0::VKStruct_Base<VkRect2D>
		{
			Offset2D Offset;
			Extent2D Extent;

			bool operator==(const Rect2D& _other) { Offset == _other.Offset && Extent == _other.Extent ? true : false; }
			bool operator!=(const Rect2D& _other) { Offset != _other.Offset || Extent != _other.Extent ? true : false; }
		};

		/**
		* @}
		*/

	#pragma endregion Common Object Types

		/**
		@defgroup CommonStrings
		*/

		/**
		@addtogroup CommonStrings
		@ingroup Corridors
		@{
		*/

		constexpr DeviceSize Description_MaxSize   = VK_MAX_DESCRIPTION_SIZE   ;   ///< Used for DescriptionStr definition.
		constexpr DeviceSize ExtensionName_MaxSize = VK_MAX_EXTENSION_NAME_SIZE;   ///< Used for ExtensionNameStr definition.

		using ExtensionNameStr = char[ExtensionName_MaxSize];   ///< Can hold an extension name.
		using DescrptionStr    = char[Description_MaxSize  ];   ///< Can hold a description string.

																/**
																@}
																*/


																/**
																@defgroup Flags_and_Bitmasks
																*/

																/**
																@addtogroup Flags_and_Bitmasks
																@ingroup Corridors
																@{
																*/

																/**
																@ingroup APISpec_Fundamentals
																@brief Used to represent bitmasks for Vulkan flag types.

																@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFlags">Specification</a> 
																*/
		using Flags = VkFlags;

		/**
		* @ingroup APISpec_Synchronization_and_Cache_Control @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAccessFlags">Specification</a> 
		*/
		using AccessFlags = Bitmask<EAccessFlag, VkAccessFlags>;

		/**
		* @ingroup APISpec_The_Framebuffer @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkColorComponentFlags">Specification</a>
		*/
		using ColorComponentFlags = Bitmask<EColorComponentFlag, VkColorComponentFlags>;

		/**
		* @ingroup APISpec_Synchronization_and_Cache_Control @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAccessFlags">Specification</a> 
		*/
		using DependencyFlags = Bitmask<EDependencyFlag, VkDependencyFlags>;

		/**
		* @ingroup APISpec_Synchronization_and_Cache_Control @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceImportFlags">Specification</a> 
		*/
		using FenceImportFlags = Bitmask<EFenceImportFlag, VkFenceImportFlags>;

		/**
		* @ingroup APISpec_Formats @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFormatFeatureFlags">Specification</a> 
		*/
		using FormatFeatureFlags = Bitmask<EFormatFeatureFlag, VkFormatFeatureFlags>;

		/**
		* @ingroup APISpec_Render_Pass @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkResolveModeFlags">Specification</a>
		*/
		using ResolveModeFlags = Bitmask<EResolveModeFlags, VkResolveModeFlags>;

		/**
		* @ingroup APISpec_Limits @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSampleCountFlags">Specification</a> 
		*/
		using SampleCountFlags = Bitmask<ESampleCount, VkSampleCountFlags>;

		/**
		@}
		*/

		/**
		@defgroup Pointers
		*/

		/**
		@addtogroup Pointers
		@ingroup Corridors
		@{
		*/

		/** 
		@brief Vulkan Function Pointer
		*/
		template<typename ReturnType, typename... ParameterTypes>
		using VK_FPtr = ReturnType(VKAPI_PTR*)(ParameterTypes...);

		/** 
		@ingroup APISpec_Initialization
		@brief Equivalent to VK_FPtr<void, void>.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkVoidFunction">Specification</a> 
		*/
		using FPtr_Void = PFN_vkVoidFunction;

		/**
		@}
		*/

		// Misc

		/** @ingroup APISpec_Clear_Commands @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkClearValue">Specification</a>  */
		struct ClearValue
		{
			/** @ingroup APISpec_Clear_Commands @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkClearColorValue">Specification</a>  */
			union UColor
			{
				float32 InFloat[4];
				sint32  InSInt [4];
				uint32  InUInt [4];
			};

			/** @ingroup APISpec_Clear_Commands @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkClearDepthStencilValue">Specification</a>  */
			struct UDepthStencil
			{
				float32 Depth  ;
				uint32  Stencil;
			};

			union
			{
				UColor        Color       ;
				UDepthStencil DepthStencil;
			};
		};

		/** 
		@ingroup APISpec_Resource_Creation
		@brief Structure specifying a color component mapping.

		@details
		The VkComponentMapping components member describes a remapping from components of the image to components of the vector 
		returned by shader image instructions. This remapping must be the identity swizzle for storage image descriptors, 
		input attachment descriptors, framebuffer attachments, and any VkImageView used with a combined image sampler that 
		enables sampler Y�CBCR conversion.

		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkComponentMapping.html">Component Mapping Specification</a> 
		*/
		struct ComponentMapping : V0::VKStruct_Base<VkComponentMapping>
		{
			EComponentSwizzle R = EComponentSwizzle::R;
			EComponentSwizzle G = EComponentSwizzle::G;
			EComponentSwizzle B = EComponentSwizzle::B;
			EComponentSwizzle A = EComponentSwizzle::A;

			bool operator==(const ComponentMapping& _other) { return R == _other.R && G == _other.G && B == _other.B && A == _other.A ? true : false; }
			bool operator!=(const ComponentMapping& _other) { return R != _other.R || G != _other.G || B != _other.B || A != _other.A ? true : false; }
		};

		/** 
		@ingroup APISpec_Extending_Vulkan
		@brief Structure specifying an extension properties.

		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExtensionProperties">Extension Properties Specification</a> 
		*/
		struct ExtensionProperties : V0::VKStruct_Base<VkExtensionProperties>
		{
			ExtensionNameStr Name       ;
			uint32           SpecVersion;
		};

		/** @ingroup APISpec_Formats @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFormatProperties">Specification</a>  */
		struct FormatProperties : V0::VKStruct_Base<VkFormatProperties>
		{
			FormatFeatureFlags    LinearTilingFeatures ;
			FormatFeatureFlags    OptimalTilingFeatures;
			FormatFeatureFlags    BufferFeatures       ;

			bool operator== (const FormatProperties& _other)
			{ 
				return 
					LinearTilingFeatures  == _other.LinearTilingFeatures  && 
					OptimalTilingFeatures == _other.OptimalTilingFeatures && 
					BufferFeatures        == _other.BufferFeatures 
					? true : false; 
			}

			bool operator!= (const FormatProperties& _other)
			{ 
				return 
					LinearTilingFeatures  != _other.LinearTilingFeatures  || 
					OptimalTilingFeatures != _other.OptimalTilingFeatures ||
					BufferFeatures        != _other.BufferFeatures 
					? true : false; 
			}
		};

		/** @ingroup APISpec_Extending_Vulkan @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkLayerProperties">Specification</a>  */
		struct LayerProperties : V0::VKStruct_Base<VkLayerProperties>
		{
			ExtensionNameStr Name                 ;
			uint32           SpecVersion          ;
			uint32           ImplementationVersion;
			DescrptionStr    Descrption           ;
		};

		/** @ingroup APISpec_Fragment_Operations @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkStencilOpState">Specification</a>  */
		struct StencilOperationState : V0::VKStruct_Base<VkStencilOpState>
		{
			EStencilOperation FailOp     ;
			EStencilOperation PassOp     ;
			EStencilOperation DepthFailOp;
			ECompareOperation CompareOp  ;
			uint32            CompareMask;
			uint32            WriteMask  ;
			uint32            Reference  ;

			bool operator== (const StencilOperationState& _other)
			{
				return
					FailOp      == _other.FailOp      &&
					PassOp      == _other.PassOp      &&
					DepthFailOp == _other.DepthFailOp &&
					CompareOp   == _other.CompareOp   &&
					CompareMask == _other.CompareMask &&
					WriteMask   == _other.WriteMask   &&
					Reference   == _other.Reference 
					? true : false;
			}

			bool operator!= (const StencilOperationState& _other)
			{
				return
					FailOp      != _other.FailOp      ||
					PassOp      != _other.PassOp      ||
					DepthFailOp != _other.DepthFailOp ||
					CompareOp   != _other.CompareOp   ||
					CompareMask != _other.CompareMask ||
					WriteMask   != _other.WriteMask   ||
					Reference   != _other.Reference 
					? true : false;
			}
		};

		/**
		@ingroup APISpec_Fixed-Function_Vertex_Post-Processing
		@brief Surface viewing region.
		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkViewport">Specification</a> 
		*/
		struct Viewport : V0::VKStruct_Base<VkViewport>
		{
			float32 X       , Y       ;
			float32 Width   , Height  ;
			float32 MinDepth, MaxDepth;

			bool operator== (const Viewport& _other) 
			{
				return
					X        == _other.X        && Y        == _other.Y        &&
					Width    == _other.Width    && Height   == _other.Height   &&
					MinDepth == _other.MinDepth && MaxDepth == _other.MaxDepth
					? true : false;
			}

			bool operator!= (const Viewport& _other) 
			{
				return
					X        != _other.X        || Y        != _other.Y        ||
					Width    != _other.Width    || Height   != _other.Height   ||
					MinDepth != _other.MinDepth || MaxDepth != _other.MaxDepth
					? true : false;
			}
		};

		constexpr DeviceSize UUID_Size = VK_UUID_SIZE;

		using UUID = unsigned int[UUID_Size];   ///< Universally unique identifier.


												// TODO: Move these later...

		struct Display
		{
			using Handle = VkDisplayKHR;
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		* @brief Currently hard coded to use STL vector for extensions.
		*/
		struct LayerAndExtensionProperties
		{
			LayerProperties                   Layer     ;
			DynamicArray<ExtensionProperties> Extensions;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		using V2::LayerAndExtensionProperties;

		/** @} */
	}

	namespace SPIR_V
	{
		using Bytecode = Corridors::uint32;   ///< Word size of a SPIR-V instruction.
	}
}




/*!
@file VT_Constants.hpp

@brief Vaulted Thermals: Constants
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace Corridors
	{
		/**
		@addtogroup Corridors
		@{
		*/

		template<typename HandleType>
		/**
		@brief A template version of the VK_NULL_Handle specifier.
		(The handle type must be provided)

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_NULL_HANDLE">Specification</a> 

		@ingroup APISpec__Appendix-F__API_Boilerplate
		*/
		constexpr HandleType Null = VK_NULL_HANDLE;

		/**
		@brief Maximum number of heap elements in a physical device's memory properties.
		*/
		constexpr DeviceSize MaxMemoryHeaps = VK_MAX_MEMORY_HEAPS;

		/**
		@brief Maximum number of memory type elements in a physical device's memory properties.
		*/
		constexpr DeviceSize MaxMemoryTypes = VK_MAX_MEMORY_TYPES;

		/**
		@brief Used in resource synchronization and render pass commands. 

		@todo #TODO: Make a better brief/detailed elaboration.
		*/
		constexpr DeviceSize QueueFamily_Ignored = VK_QUEUE_FAMILY_IGNORED;

		/**
		@brief Used in render pass subpass related functionality.

		@todo #TODO : Make a better brief/detailed elaboration.
		*/
		constexpr uint32 Subpass_External = VK_SUBPASS_EXTERNAL;



		struct InstanceExt
		{
			/**
			@brief  
			This extension provides the following capabilities:
			The ability to create a debug messenger which will pass along debug messages to an application supplied callback.
			The ability to identify specific Vulkan objects using a name or tag to improve tracking.
			The ability to identify specific sections within a VkQueue or VkCommandBuffer using labels to aid organization and offline analysis in external tools.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_EXT_debug_utils">Specification</a> 

			@ingroup APISpec__Appendix-E__Layers_and_Extensions_Informative
			*/
			static constexpr RoCStr DebugUtility = VK_EXT_DEBUG_UTILS_EXTENSION_NAME  ;

			/**
			@brief It introduces VkSurfaceKHR objects, which abstract native platform surface or window objects for use with Vulkan. 
			It also provides a way to determine whether a queue family in a physical device supports presenting to particular surface. 

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_surface">Specification</a> 

			@ingroup APISpec__Appendix-E__Layers_and_Extensions_Informative
			*/
			static constexpr RoCStr Surface      = VK_KHR_SURFACE_EXTENSION_NAME      ;

			/**
			@brief It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) that refers to a Win32 HWND, 
			as well as a query to determine support for rendering to the windows desktop.

			@details https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_win32_surface

			@ingroup APISpec__Appendix-E__Layers_and_Extensions_Informative
			*/
			static constexpr RoCStr Win32Surface = VK_KHR_WIN32_SURFACE_EXTENSION_NAME;
		};

		struct DeviceExt
		{
			/**
			@brief Introduces VkSwapchainKHR objects, which provide the ability to present rendering results to a surface.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_swapchain">Specification</a> 

			@ingroup  APISpec__Appendix-E__Layers_and_Extensions_Informative
			*/
			static constexpr RoCStr Swapchain = VK_KHR_SWAPCHAIN_EXTENSION_NAME;	
		};

		struct Layer
		{
			// Utility

			/**
			@brief Prints API calls, parameters, and values to the identified output stream. 
			It has several settings that can be adjusted by either environment variables or by using the vk_layer_settings.txt file.

			@details <a href="https://vulkan.lunarg.com/doc/view/1.1.114.0/windows/api_dump_layer.html">Specification</a> 
			*/
			static constexpr RoCStr LunarG_API_Dump   = "VK_LAYER_LUNARG_api_dump"  ;

			/**
			@brief Prints the real-time frames-per-second value to the application's title bar. (Only works on the most recently opened window)

			@details <a href="https://vulkan.lunarg.com/doc/view/1.2.131.1/windows/monitor_layer.html">Specification</a> 
			*/
			static constexpr RoCStr LunarG_Monitor    = "VK_LAYER_LUNARG_monitor"   ;   // Shows FPS on the most recently created window.

																						/**
																						@brief Records frames to image files.

																						@details <a href="https://vulkan.lunarg.com/doc/view/latest/linux/screenshot_layer.html">Specification</a> 
																						*/
			static constexpr RoCStr LunarG_Screenshot = "VK_LAYER_LUNARG_screenshot";

			// Validation

			// Deprecated (Fallback 3)

			/**
			@brief 
			The VK_LAYER_LUNARG_core_validation layer validates the status of descriptor sets, command buffers, shader modules, pipeline states, renderpass usage, synchronization, 
			dynamic states and is the workhorse layer for many other types of valid usage.

			@details https://vulkan.lunarg.com/doc/view/1.1.85.0/linux/core_validation_layer.html
			*/
			static constexpr RoCStr LunarG_CoreValidation = "VK_LAYER_LUNARG_core_validation";

			// Deprecated (Fallback 2)

			/**
			@brief Checks the input parameters to API calls for validity.

			@details <a href="https://chromium.googlesource.com/external/github.com/KhronosGroup/Vulkan-ValidationLayers/+/refs/tags/v1.1.97/docs/parameter_validation_layer.md">Specification</a> 
			*/
			static constexpr RoCStr LunarG_ParameterValidation = "VK_LAYER_LUNARG_parameter_validation";
			/**
			@brief Tracks all Vulkan objects. Object lifetimes are validated along with issues related to unknown objects and object destruction and cleanup.

			@details <a href="https://vulkan.lunarg.com/doc/view/1.1.85.0/linux/object_tracker_layer.html">Specification</a> 
			*/
			static constexpr RoCStr LunarG_ObjectTracker       = "VK_LAYER_LUNARG_object_tracker"      ;
			/**
			@brief Checks multi-threading of API calls for validity. 
			Checks performed by this layer include ensuring that only one thread at a time uses an object in free-threaded API calls.

			@details <a href="https://vulkan.lunarg.com/doc/view/1.1.108.0/mac/threading_layer.html">Specification</a> 
			*/
			static constexpr RoCStr Google_Threading           = "VK_LAYER_GOOGLE_threading"           ;
			/**
			@brief Wrap all Vulkan objects in a unique pointer at create time and unwrap them at use time

			@details <a href="https://vulkan.lunarg.com/doc/view/1.1.85.0/linux/unique_objects_layer.html">Specification</a> 
			*/
			static constexpr RoCStr Google_UniqueObjedcts      = "VK_LAYER_GOOGLE_unique_objects"      ;

			// Meta Validation - Deprecated (Fallback 1)

			/**
			@brief This is a meta-layer managed by the loader. 
			On desktop systems, specifying this layer name will cause the loader to load the all of the standard validation layers.

			@details <a href="https://chromium.googlesource.com/android_ndk/+/refs/heads/unmodified/sources/third_party/vulkan/src/layers/vk_validation_layer_details.md#VK_LAYER_LUNARG_standard_validation">Specification</a> 
			*/
			static constexpr RoCStr LunarG_StandardValidation = "VK_LAYER_LUNARG_standard_validation";

			// Default

			/**
			@brief Encompasses the complete functionality that had previously been provided.

			@details <a href="https://vulkan.lunarg.com/doc/view/1.1.114.0/windows/khronos_validation_layer.html">Specification</a> 
			*/
			static constexpr RoCStr Khronos_Validation = "VK_LAYER_KHRONOS_validation";

			/** @} */
		};
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief Ease of identification masks for identifying a type of queue family.
		*/
		struct QueueMask
		{
			/**
			@brief Ease of identification mask for identifying a asynchronous compute queue family.
			*/
			static constexpr uint32 ComputeAsync = 
				uint32(EQueueFlag::Compute      ) |
				uint32(EQueueFlag::Transfer     ) |
				uint32(EQueueFlag::SparseBinding)  ;

			/**
			@brief Ease of identification mask for identifying a transfer only queue family.
			*/
			static constexpr uint32 TransferOnly = uint32(EQueueFlag::Transfer) | uint32(EQueueFlag::SparseBinding);
		};

		/** @} */
	}

	namespace V3
	{
		using V2::QueueMask;
	}
}




/*!
@file VT_Memory_Backend.hpp

@brief Vaulted Thermals: Memory: Preliminary Definitions

@details
Had to make this as there are definitions used by both application instance and physical device before full definitions done with the logical device.

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V0
	{
		using V1::AccessFlags;
		using V1::DeviceSize ;

		/**
		@addtogroup Vault_0
		@{
		*/

		/**
		* @brief General memory definitions.
		* 
		* @details 
		* 
		* @ingroup APISpec_Memory_Allocation
		*/
		struct Memory
		{
			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryHeapFlags">Specification</a>
			*/
			using HeapFlags = Bitmask<EMemoryHeapFlag, VkMemoryHeapFlags>;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryMapFlags">Specification</a>
			*/
			using MapFlags = Bitmask<EUndefined, VkMemoryMapFlags>;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryPropertyFlags">Specification</a> 
			*/
			using PropertyFlags = Bitmask<EMemoryPropertyFlag, VkMemoryPropertyFlags>;

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkAllocationFunction">Specification</a>  
			@ingroup APISpec_Memory_Allocation
			*/
			using FPtr_Allocation                     = PFN_vkAllocationFunction            ;
			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkReallocationFunction">Specification</a>
			@ingroup APISpec_Memory_Allocation
			*/
			using FPtr_Reallocation                   = PFN_vkReallocationFunction          ;
			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkFreeFunction">Specification</a> 
			@ingroup APISpec_Memory_Allocation
			*/
			using FPtr_Free                           = PFN_vkFreeFunction                  ;
			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkInternalAllocationNotification">Specification</a> 	
			@ingroup APISpec_Memory_Allocation
			*/
			using FPtr_InternalAllocationNotification = PFN_vkInternalAllocationNotification;
			/**
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkInternalFreeNotification">Specification</a> 
			@ingroup APISpec_Memory_Allocation
			*/
			using FPtr_InternalFreeNotification       = PFN_vkInternalFreeNotification      ;


			/** 
			@brief Structure describing parameters of the allocation.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryAllocateInfo">Specification</a>  

			@ingroup APISpec_Memory_Allocation
			*/
			struct AllocateInfo : V0::VKStruct_Base<VkMemoryAllocateInfo, EStructureType::MemoryAllocateInfo>
			{
				EType      SType           = STypeEnum;
				const void*      Next            = nullptr  ;
				DeviceSize AllocationSize ;
				uint32     MemoryTypeIndex;
			};

			/** 
			@brief 
			Vulkan provides applications the opportunity to perform host memory allocations on behalf of the Vulkan implementation. 
			If this feature is not used, the implementation will perform its own memory allocations.

			@details 
			Since most memory allocations are off the critical path, this is not meant as a performance feature. Rather, 
			this can be useful for certain embedded systems, for debugging purposes (e.g. putting a guard page after all host allocations), 
			or for memory allocation logging.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAllocationCallbacks">Specification</a> 

			@ingroup APISpec_Memory_Allocation
			*/
			struct AllocationCallbacks : V0::VKStruct_Base<VkAllocationCallbacks>
			{
				void*                               UserData          ;
				FPtr_Allocation                     Allocation        ;
				FPtr_Reallocation                   Reallocation      ;
				FPtr_Free                           Free              ;
				FPtr_InternalAllocationNotification InternalAllocation;
				FPtr_InternalFreeNotification       InternalFree      ;
			};

			static constexpr AllocationCallbacks* DefaultAllocator = nullptr;

			/**
			* @brief Global memory barriers apply to memory accesses involving all memory objects that exist at the time of its execution..
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryBarrier">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct Barrier : V0::VKStruct_Base<VkMemoryBarrier, EStructureType::Memory_Barrier>
			{
				EType       SType         = STypeEnum;
				const void*       Next          = nullptr  ;
				AccessFlags SrcAccessMask;
				AccessFlags DstAccessMask;
			};

			/**
			* @biref Structure describing the memory heap from which memory can be allocated.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryHeap">Specification</a> 
			* 
			* @ingroup APISpec_Memory_Allocation
			*/
			struct Heap : V0::VKStruct_Base<VkMemoryHeap>
			{
				DeviceSize Size ;
				HeapFlags  Flags;
			};

			/**
			* @brief Structure describing the memory requirements for a buffer or an image.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryRequirements">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			*/
			struct Requirements : V0::VKStruct_Base<VkMemoryRequirements>
			{
				DeviceSize Size          ;
				DeviceSize Alignment     ;
				uint32     MemoryTypeBits;
			};

			/**
			* @brief Structures describing the memory types that can be used to access memory allocated from the heaps specified by memoryHeaps.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkMemoryType ">Specification</a> 
			* 
			* @ingroup APISpec_Memory_Allocation
			*/
			struct Type : V0::VKStruct_Base<VkMemoryType>
			{
				PropertyFlags PropertyFlags;
				uint32        HeapIndex    ;
			};
		};

		/** @} */
	}
}



/*!
@file VT_PhysicalDevice.hpp

@brief Vaulted Thermals: Physical Device

@details
A physical device usually represents a single complete implementation of Vulkan 
(excluding instance-level functionality) available to the host, of which there are a finite number. 


<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#devsandqueues-physical-device-enumeration">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@brief Represents a physical device.
		@details
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#devsandqueues-physical-device-enumeration">Specification</a>
		@ingroup APISpec_Devices_and_Queues
		*/
		struct PhysicalDevice
		{
			using Memory = V0::Memory;

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDevice">Specification</a>
			@ingroup APISpec_Devices_and_Queues
			*/
			using Handle = VkPhysicalDevice;

			static constexpr DeviceSize MaxNameSize        = VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;   ///< @brief Maximum size of a name string.
			static constexpr DeviceSize MaxDeviceGroupSize = VK_MAX_DEVICE_GROUP_SIZE        ;   ///< @brief Maximum size of a device group.
			static constexpr DeviceSize MaxDriverNameSize  = VK_MAX_DRIVER_NAME_SIZE         ;   ///< @brief maximum size of a driver name string.
			static constexpr DeviceSize MaxDriverInfoSize  = VK_MAX_DRIVER_INFO_SIZE         ;   ///< @brief Maximum size of a driver info string.

			using NameStr = char[MaxNameSize];   ///< @brief Used in various structures to define a name.

			using DriverNameStr = char[MaxDriverNameSize];   ///< @brief Driver name string.
			using DriverInfoStr = char[MaxDriverInfoSize];   ///< @brief Driver info string.

			using EDeviceType = EPhysicalDeviceType;

			/**
			* @brief Conformance test suite version an implementation is compliant with is described with this.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkConformanceVersion">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct ConformanceVersion : V0::VKStruct_Base<VkConformanceVersion>
			{
				uInt8 Major   ;
				uInt8 Minor   ;
				uInt8 Subminor;
				uInt8 Patch   ;

				bool operator==(const ConformanceVersion _other) 
				{ return Major == _other.Major && Minor == _other.Minor && Subminor == _other.Subminor && Patch == _other.Patch ? true : false; }
				bool operator!=(const ConformanceVersion _other) 
				{ return Major != _other.Major && Minor != _other.Minor && Subminor != _other.Subminor && Patch != _other.Patch ? true : false; }
			};

			/**
			@brief Structure describing the fine-grained features that can be supported by an implementation.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceFeatures">Specification</a>

			@ingroup APISpec_Features
			*/
			struct Features : V0::VKStruct_Base<VkPhysicalDeviceFeatures>
			{
				Bool RobustBufferAccess                     ;   ///< Out of bounds buffer accesses are well defined.
				Bool FullDrawIndexUint32                    ;   ///< full 32-bit range of indices are supported for indexed draw calls using VK_INDEX_TYPE_UINT32.
				Bool ImageCubeArray                         ;
				Bool IndependentBlend                       ;
				Bool GeometryShader                         ;
				Bool TessellationShader                     ;
				Bool SampleRateShading                      ;
				Bool DualSrcBlend                           ;
				Bool LogicOperations                        ;
				Bool MultiDrawIndirect                      ;
				Bool drawIndirectFirstInstance              ;
				Bool DepthClamping                          ;
				Bool DepthBiasClamping                      ;
				Bool NonSolidFillModes                      ;   ///< Point and wireframe fill modes are supported.
				Bool DepthBounds                            ;   ///< Depth bounds test supported.
				Bool WideLines                              ;
				Bool LargePoints                            ;
				Bool AlphaToOne                             ;   ///< The implementation can replace the alpha value of the color fragment output to the maximum representable alpha value for fixed - point colors or 1.0 for floating - point colors.
				Bool MultiViewport                          ;   ///< Multiple viewports are supported. (VR)
				Bool SamplerAnisotropy                      ;
				Bool TextureCompressionETC2                 ;
				Bool TextureCompressionASTC_LDR             ;
				Bool TextureCompressionBC                   ;
				Bool OcclusionQueryPrecise                  ;
				Bool PipelineStatisticsQuery                ;
				Bool VertexPipelineStoresAndAtomics         ;
				Bool FragmentStoresAndAtomics               ;
				Bool ShaderTessellationAndGeometryPointSize ;
				Bool ShaderImageGatherExtended              ;
				Bool ShaderStorageImageExtendedFormats      ;
				Bool ShaderStorageImageMultisample          ;
				Bool ShaderStorageImageReadWithoutFormat    ;
				Bool ShaderStorageImageWriteWithoutFormat   ;
				Bool ShaderUniformBufferArrayDynamicIndexing;
				Bool ShaderSampledImageArrayDynamicIndexing ;
				Bool ShaderStorageBufferArrayDynamicIndexing;
				Bool ShaderStorageImageArrayDynamicIndexing ;
				Bool ShaderClipDistance                     ;
				Bool ShaderCullDistance                     ;
				Bool ShaderFloat64                          ;
				Bool ShaderInt64                            ;
				Bool ShaderInt16                            ;
				Bool ShaderResourceResidency                ;
				Bool ShaderResourceMinLod                   ;
				Bool SparseBinding                          ;
				Bool SparseResidencyBuffer                  ;
				Bool SparseResidencyImage2D                 ;
				Bool SparseResidencyImage3D                 ;
				Bool SparseResidency2Samples                ;
				Bool SparseResidency4Samples                ;
				Bool SparseResidency8Samples                ;
				Bool SparseResidency16Samples               ;
				Bool SparseResidencyAliased                 ;
				Bool VariableMultisampleRate                ;
				Bool InheritedQueries                       ;
			};

			/**
			* @brief
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceGroupProperties ">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct Group : V0::VKStruct_Base<VkPhysicalDeviceGroupProperties, EStructureType::PhysicalDevice_GroupProperties>
			{
				using DeviceListing = Handle[MaxDeviceGroupSize];

				EType         SType               = STypeEnum;
				void*         Next                = nullptr  ;
				uint32        PhysicalDeviceCount;
				DeviceListing PhysicalDevices    ;
				Bool          SubsetAllocation   ;
			};

			/**
			@brief Structure reporting implementation-dependent physical device limits.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceLimits">Specification</a> 

			@ingroup APISpec_Limits
			*/
			struct Limits : V0::VKStruct_Base<VkPhysicalDeviceLimits>
			{
				uint32           MaxImageDimension1D                            ;
				uint32           MaxImageDimension2D                            ;
				uint32           MaxImageDimension3D                            ;
				uint32           MaxImageDimensionCube                          ;
				uint32           MaxImageArrayLayers                            ;
				uint32           MaxTexelBufferElements                         ;
				uint32           MaxUniformBufferRange                          ;
				uint32           MaxStorageBufferRange                          ;
				uint32           MaxPushConstantsSize                           ;
				uint32           MaxMemoryAllocationCount                       ;
				uint32           MaxSamplerAllocationCount                      ;
				DeviceSize       BufferImageGranularity                         ;
				DeviceSize       SparseAddressSpaceSize                         ;
				uint32           MaxBoundDescriptorSets                         ;
				uint32           MaxPerStageDescriptorSamplers                  ;
				uint32           MaxPerStageDescriptorUniformBuffers            ;
				uint32           MaxPerStageDescriptorStorageBuffers            ;
				uint32           MaxPerStageDescriptorSampledImages             ;
				uint32           MaxPerStageDescriptorStorageImages             ;
				uint32           MaxPerStageDescriptorInputAttachments          ;
				uint32           MaxPerStageResources                           ;
				uint32           MaxDescriptorSetSamplers                       ;
				uint32           MaxDescriptorSetUniformBuffers                 ;
				uint32           MaxDescriptorSetUniformBuffersDynamic          ;
				uint32           MaxDescriptorSetStorageBuffers                 ;
				uint32           MaxDescriptorSetStorageBuffersDynamic          ;
				uint32           MaxDescriptorSetSampledImages                  ;
				uint32           MaxDescriptorSetStorageImages                  ;
				uint32           MaxDescriptorSetInputAttachments               ;
				uint32           MaxVertexInputAttributes                       ;
				uint32           MaxVertexInputBindings                         ;
				uint32           MaxVertexInputAttributeOffset                  ;
				uint32           MaxVertexInputBindingStride                    ;
				uint32           MaxVertexOutputComponents                      ;
				uint32           MaxTessellationGenerationLevel                 ;
				uint32           MaxTessellationPatchSize                       ;
				uint32           MaxTessellationControlPerVertexInputComponents ;
				uint32           MaxTessellationControlPerVertexOutputComponents;
				uint32           MaxTessellationControlPerPatchOutputComponents ;
				uint32           MaxTessellationControlTotalOutputComponents    ;
				uint32           MaxTessellationEvaluationInputComponents       ;
				uint32           MaxTessellationEvaluationOutputComponents      ;
				uint32           MaxGeometryShaderInvocations                   ;
				uint32           MaxGeometryInputComponents                     ;
				uint32           MaxGeometryOutputComponents                    ;
				uint32           MaxGeometryOutputVertices                      ;
				uint32           MaxGeometryTotalOutputComponents               ;
				uint32           MaxFragmentInputComponents                     ;
				uint32           MaxFragmentOutputAttachments                   ;
				uint32           MaxFragmentDualSrcAttachments                  ;
				uint32           MaxFragmentCombinedOutputResources             ;
				uint32           MaxComputeSharedMemorySize                     ;
				uint32           MaxComputeWorkGroupCount[3]                    ;
				uint32           MaxComputeWorkGroupInvocations                 ;
				uint32           MaxComputeWorkGroupSize[3]                     ;
				uint32           SubPixelPrecisionBits                          ;
				uint32           SubTexelPrecisionBits                          ;
				uint32           MipmapPrecisionBits                            ;
				uint32           MaxDrawIndexedIndexValue                       ;
				uint32           MaxDrawIndirectCount                           ;
				float32          MaxSamplerLodBias                              ;
				float32          MaxSamplerAnisotropy                           ;
				uint32           MaxViewports                                   ;
				uint32           MaxViewportDimensions[2]                       ;
				float32          ViewportBoundsRange[2]                         ;
				uint32           ViewportSubPixelBits                           ;
				size_t           MinMemoryMapAlignment                          ;
				DeviceSize       MinTexelBufferOffsetAlignment                  ;
				DeviceSize       MinUniformBufferOffsetAlignment                ;
				DeviceSize       MinStorageBufferOffsetAlignment                ;
				sint32           MinTexelOffset                                 ;
				uint32           MaxTexelOffset                                 ;
				sint32           MinTexelGatherOffset                           ;
				uint32           MaxTexelGatherOffset                           ;
				float32          MinInterpolationOffset                         ;
				float32          MaxInterpolationOffset                         ;
				uint32           SubPixelInterpolationOffsetBits                ;
				uint32           MaxFramebufferWidth                            ;
				uint32           MaxFramebufferHeight                           ;
				uint32           MaxFramebufferLayers                           ;
				SampleCountFlags FramebufferColorSampleCounts                   ;
				SampleCountFlags FramebufferDepthSampleCounts                   ;
				SampleCountFlags FramebufferStencilSampleCounts                 ;
				SampleCountFlags FramebufferNoAttachmentsSampleCounts           ;
				uint32           MaxColorAttachments                            ;
				SampleCountFlags SampledImageColorSampleCounts                  ;
				SampleCountFlags SampledImageIntegerSampleCounts                ;
				SampleCountFlags SampledImageDepthSampleCounts                  ;
				SampleCountFlags SampledImageStencilSampleCounts                ;
				SampleCountFlags StorageImageSampleCounts                       ;
				uint32           MaxSampleMaskWords                             ;
				Bool             TimestampComputeAndGraphics                    ;
				float32          TimestampPeriod                                ;
				uint32           MaxClipDistances                               ;
				uint32           MaxCullDistances                               ;
				uint32           MaxCombinedClipAndCullDistances                ;
				uint32           DiscreteQueuePriorities                        ;
				float32          PointSizeRange[2]                              ;
				float32          LineWidthRange[2]                              ;
				float32          PointSizeGranularity                           ;
				float32          LineWidthGranularity                           ;
				Bool             StrictLines                                    ;
				Bool             StandardSampleLocations                        ;
				DeviceSize       OptimalBufferCopyOffsetAlignment               ;
				DeviceSize       OptimalBufferCopyRowPitchAlignment             ;
				DeviceSize       NonCoherentAtomSize                            ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceMemoryProperties">Specification</
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct MemoryProperties : V0::VKStruct_Base<VkPhysicalDeviceMemoryProperties>
			{
				uint32       TypeCount            ;
				Memory::Type Types[MaxMemoryTypes];
				uint32       HeapCount            ;
				Memory::Heap Heaps[MaxMemoryHeaps];
			};

			/**
			* @brief
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterKHR">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct PerformanceCounter : V0::VKStruct_Base<VkPerformanceCounterKHR, EStructureType::PerformacneCounter_KHR>
			{
				EType                      SType       = STypeEnum;
				const void*                      Next        = nullptr  ;
				EPerformanceCounterUnit    Unit       ;
				EPerformanceCounterScope   Scope      ;
				EPerformanceCounterStorage Storage    ;
				UUID                       CounterUUID;


				using DescriptionFlags = Bitmask<EPerformanceCounterDescriptionFlag, VkPerformanceCounterDescriptionFlagsKHR>;

				/**
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceCounterDescriptionKHR">Specification</a> 
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct Description : V0::VKStruct_Base<VkPerformanceCounterDescriptionKHR>
				{
					EType            SType       = STypeEnum;
					const void*            Next        = nullptr  ;
					DescriptionFlags Flags      ;
					DescrptionStr    Name       ;
					DescrptionStr    Category   ;
					DescrptionStr    Description;
				};
			};

			/**
			@brief Structure specifying various sparse related properties of the physical device.

			@details
			Some features of the implementation are not possible to disable, and are reported to allow applications 
			to alter their sparse resource usage accordingly. These read-only capabilities are reported in the 
			VkPhysicalDeviceProperties::sparseProperties member, which is a structure of type VkPhysicalDeviceSparseProperties.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#sparsememory-physicalprops">Specification</a> 

			@ingroup APISpec_Sparse_Resources
			*/
			struct SparseMemoryProperties : V0::VKStruct_Base<VkPhysicalDeviceSparseProperties>
			{
				Bool ResidencyStandard2DBlockShape           ;
				Bool ResidencyStandard2DMultisampleBlockShape;
				Bool ResidencyStandard3DBlockShape           ;
				Bool ResidencyAlignedMipSize                 ;
				Bool ResidencyNonResidentStrict              ;
			};

			/**
			@brief Container of query general properties of physical devices once enumerated.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceProperties">Specification</a> 

			@ingroup APISpec_Devices_and_Queues
			*/
			struct Properties : V0::VKStruct_Base<VkPhysicalDeviceProperties>
			{
				uint32                 API_Version      ;
				uint32                 DriverVersion    ;
				uint32                 VenderID         ;
				uint32                 ID               ;
				EDeviceType            Type             ;
				NameStr                Name             ;
				UUID                   PipelineCacheUUID;
				Limits                 LimitsSpec       ;
				SparseMemoryProperties SpareProperties  ;

				/**
				* @brief To query the UUID and LUID of a device, add a VkPhysicalDeviceIDProperties structure to the pNext chain of the VkPhysicalDeviceProperties2 structure.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceProperties">Specification</a>
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct DeviceID : V0::VKStruct_Base<VkPhysicalDeviceIDProperties >
				{
					EType  SType           = STypeEnum;
					void*  Next            = nullptr  ;
					UUID   DeviceUUID     ;
					UUID   DriverUUID     ;
					UUID   DeviceLUID     ;
					uint32 DeviceNodeMask ;
					Bool   DeviceLUIDValid;
				};	

				/**
				* @brief To query the PCI bus information of a physical device, add a VkPhysicalDevicePCIBusInfoPropertiesEXT 
				* structure to the pNext chain of the VkPhysicalDeviceProperties2 structure.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDevicePCIBusInfoPropertiesEXT">Specification</a> 
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct PCIBusInfo : V0::VKStruct_Base<VkPhysicalDevicePCIBusInfoPropertiesEXT, EStructureType::PhysicalDevice_PCI_BUS_Info_Properties_EXT>
				{
					EType  SType    = STypeEnum;
					void*  Next     = nullptr  ;
					uint32 Domain  ;
					uint32 Bus     ;
					uint32 Device  ;
					uint32 Function;
				};

				/**
				* @brief To query the properties of the driver corresponding to Vulkan 1.1 functionality, 
				* add VkPhysicalDeviceVulkan11Properties to the pNext chain of the VkPhysicalDeviceProperties2 structure.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceVulkan11Properties">Specification</a> 
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct Vulkan11 : V0::VKStruct_Base<VkPhysicalDeviceVulkan11Properties, EStructureType::PhysicalDevice_Vulkan_1_1_Properties>
				{
					using ShaderStageFlags = Bitmask<EShaderStageFlag, VkShaderStageFlags>;

					EType                  SType                             = STypeEnum;
					void*                  Next                              = nullptr  ;
					UUID                   DeviceUUID                       ;
					UUID                   DriverUUID                       ;
					UUID                   DeviceLUID                       ;
					uint32                 DeviceNodeMask                   ;
					Bool                   DeviceLUIDValid                  ;
					uint32                 SubgroupSize                     ;
					ShaderStageFlags       SubgroupSupportedStages          ;
					ESubgroupFeaturesFlag  SubgroupSupportedOperations      ;
					Bool                   SubgroupQuadOperationsInAllStages;
					EPointClippingBehavior PointClippingBehavior            ;
					uint32                 MaxMultiviewViewCount            ;
					uint32                 MaxMultiviewInstanceIndex        ;
					Bool                   ProtectedNoFault                 ;
					uint32                 MaxPerSetDescriptors             ;
					DeviceSize             MaxMemoryAllocationSize          ;
				};

				/**
				* @brief To query the properties of the driver corresponding to Vulkan 1.2 functionality, 
				* add VkPhysicalDeviceVulkan12Properties to the pNext chain of the VkPhysicalDeviceProperties2 structure.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceVulkan12Properties">Specification</a> 
				*  
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct Vulkan12 : V0::VKStruct_Base<VkPhysicalDeviceVulkan12Properties, EStructureType::PhysicalDevice_Vulkan_1_2_Properties>
				{
					EType                           SType                                               = STypeEnum;
					void*                           Next                                                = nullptr  ;
					EDriverID                       DriverID                                            ;
					DriverNameStr                   DriverName                                          ;
					DriverInfoStr                   DriverInfo                                          ;
					ConformanceVersion              ConformanceVersion                                  ;
					EShaderFloatControlIndependence DenormBehaviorIndependence                          ;
					EShaderFloatControlIndependence RoundingModeIndependence                            ;
					Bool                            ShaderSignedZeroInfNanPreserveFloat16               ;
					Bool                            ShaderSignedZeroInfNanPreserveFloat32               ;
					Bool                            ShaderSignedZeroInfNanPreserveFloat64               ;
					Bool                            ShaderDenormPreserveFloat16                         ;
					Bool                            ShaderDenormPreserveFloat32                         ;
					Bool                            ShaderDenormPreserveFloat64                         ;
					Bool                            ShaderDenormFlushToZeroFloat16                      ;
					Bool                            ShaderDenormFlushToZeroFloat32                      ;
					Bool                            ShaderDenormFlushToZeroFloat64                      ;
					Bool                            ShaderRoundingModeRTEFloat16                        ;
					Bool                            ShaderRoundingModeRTEFloat32                        ;
					Bool                            ShaderRoundingModeRTEFloat64                        ;
					Bool                            ShaderRoundingModeRTZFloat16                        ;
					Bool                            ShaderRoundingModeRTZFloat32                        ;
					Bool                            ShaderRoundingModeRTZFloat64                        ;
					uint32                          MaxUpdateAfterBindDescriptorsInAllPools             ;
					Bool                            ShaderUniformBufferArrayNonUniformIndexingNative    ;
					Bool                            ShaderSampledImageArrayNonUniformIndexingNative     ;
					Bool                            ShaderStorageBufferArrayNonUniformIndexingNative    ;
					Bool                            ShaderStorageImageArrayNonUniformIndexingNative     ;
					Bool                            ShaderInputAttachmentArrayNonUniformIndexingNative  ;
					Bool                            RobustBufferAccessUpdateAfterBind                   ;
					Bool                            QuadDivergentImplicitLod                            ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindSamplers        ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindUniformBuffers  ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindStorageBuffers  ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindSampledImages   ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindStorageImages   ;
					uint32                          MaxPerStageDescriptorUpdateAfterBindInputAttachments;
					uint32                          MaxPerStageUpdateAfterBindResources                 ;
					uint32                          MaxDescriptorSetUpdateAfterBindSamplers             ;
					uint32                          MaxDescriptorSetUpdateAfterBindUniformBuffers       ;
					uint32                          MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
					uint32                          MaxDescriptorSetUpdateAfterBindStorageBuffers       ;
					uint32                          MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
					uint32                          MaxDescriptorSetUpdateAfterBindSampledImages        ;
					uint32                          MaxDescriptorSetUpdateAfterBindStorageImages        ;
					uint32                          MaxDescriptorSetUpdateAfterBindInputAttachments     ;
					ResolveModeFlags                SupportedDepthResolveModes                          ;
					ResolveModeFlags                SupportedStencilResolveModes                        ;
					Bool                            IndependentResolveNone                              ;
					Bool                            IndependentResolve                                  ;
					Bool                            FilterMinmaxSingleComponentFormats                  ;
					Bool                            FilterMinmaxImageComponentMapping                   ;
					uInt64                          MaxTimelineSemaphoreValueDifference                 ;
					SampleCountFlags                FramebufferIntegerColorSampleCounts                 ;
				};
			};

			/**
			* @brief Each structure in Properties and its pNext chain contain members corresponding to properties or implementation-dependent limits. 
			*  
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPhysicalDeviceProperties2">Specification</a>
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct Properties2 : V0::VKStruct_Base<VkPhysicalDeviceProperties2, EStructureType::PhysicalDevice_Properties_2>
			{
				EType      SType      = STypeEnum;
				void*      Next       = nullptr  ;
				Properties Properties;
			};

			/**
			@brief A set of queues that have common properties and support the same functionality.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueueFamilyProperties">Specification</a> 

			@ingroup APISpec_Devices_and_Queues
			*/
			struct QueueFamilyProperties : V0::VKStruct_Base<VkQueueFamilyProperties>
			{
				/**
				* @brief Bitmask specifying capabilities of queues in a queue family.     
				* 
				* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueueFlags">Specification</a> 
				*/
				using Flags = Bitmask<EQueueFlag , VkQueueFlags>;

				Flags    QueueFlags                 ;
				uint32   QueueCount                 ;
				uint32   TimestampValidBits         ;
				Extent3D MinImageTransferGranularity;
			};

			/**
			* @brief Return extended information in a pNext chain of output structures.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueueFamilyProperties2">Specification</a>
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct QueueFamilyProperties2 : V0::VKStruct_Base<VkQueueFamilyProperties2, EStructureType::QueueFamily_Properties_2>
			{
				EType                 SType      = STypeEnum;
				void*                 Next       = nullptr  ;
				QueueFamilyProperties Properties;

				/**
				* @brief Additional queue family information can be queried by setting QueueFamilyProperties2::Next to 
				* point to a Checkpoint structure.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueueFamilyCheckpointPropertiesNV">Specification</a>
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				struct Checkpoint : V0::VKStruct_Base<VkQueueFamilyCheckpointPropertiesNV, EStructureType::QueueFamilyCheckpoint_Properties_NV>
				{
					using Pipeline_StageFlags = Bitmask<EPipelineStageFlag, VkPipelineStageFlags>;   ///< Not defined yet. (See VT_Pipelines.hpp)

					EType               SType                        = STypeEnum;
					void*               Next                         = nullptr  ;
					Pipeline_StageFlags CheckpointExecutionStageMask;
				};
			};

			/**
			@brief Query supported features. Reports capabilities of a physical device.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceFeatures">Specification</a>

			@ingroup APISpec_Features
			*/
			static void GetFeatures(Handle _handle, Features& _features)
			{
				vkGetPhysicalDeviceFeatures(_handle, _features);
			}

			/**
			* @brief Query supported format features which are properties of the physical device.
			*
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceFormatProperties">Specification</a>
			* 
			* @ingroup APISpec_Formats
			* 
			* \param _physicalDevice
			* \param _format
			* \param _properties
			*/
			static void GetFormatProperties(Handle _handle, EFormat _format, FormatProperties& _properties)
			{
				vkGetPhysicalDeviceFormatProperties(_handle, VkFormat(_format), _properties);
			}

			/**
			* @brief Query memory properties.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceMemoryProperties">Specification</a>
			* 
			* @ingroup APISpec_Memory_Allocation
			* 
			* \param _physicalDevice
			* \param _properties
			*/
			static void GetMemoryProperties(Handle _handle, MemoryProperties& _properties)
			{
				vkGetPhysicalDeviceMemoryProperties(_handle, _properties);
			}

			/**
			@brief Query general properties of physical devices once enumerated.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceProperties">Specification</a>

			@ingroup APISpec_Devices_and_Queues
			*/
			static void GetProperties(Handle _handle, Properties& _properties)
			{
				vkGetPhysicalDeviceProperties(_handle, _properties);
			}

			/**
			* @brief Query general properties of physical devices once enumerated (Second Ver).
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceProperties2">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			static void GetProperties2
			(
				Handle       _handle    ,
				Properties2& _properties
			)
			{
				vkGetPhysicalDeviceProperties2(_handle, _properties);
			}

			/**
			@brief Device extensions add new device-level functionality to the API, outside of the core specification.

			@details
			Query the extensions available to a given physical device.

			When pLayerName parameter is NULL, only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. 
			When pLayerName is the name of a layer, the device extensions provided by that layer are returned.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_device_extensions">Specification</a> 

			@ingroup APISpec_Extending_Vulkan
			*/
			static EResult QueryExtensionProperties(Handle _handle, RoCStr _layerName, uint32* _numExtensions, ExtensionProperties* _extensionPropertiesContainer)
			{
				return EResult(vkEnumerateDeviceExtensionProperties(_handle, _layerName, _numExtensions, *_extensionPropertiesContainer));
			}

			/**
			@brief Query properties of queues available on a physical device. Reports properties of the queues of the specified physical device.

			@details
			If pQueueFamilyProperties is NULL, then the number of queue families available is returned in pQueueFamilyPropertyCount. 
			Implementations must support at least one queue family. Otherwise, pQueueFamilyPropertyCount must point to a variable set 
			by the user to the number of elements in the pQueueFamilyProperties array, and on return the variable is overwritten 
			with the number of structures actually written to pQueueFamilyProperties.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties">Specification</a> 

			@ingroup APISpec_Devices_and_Queues
			*/
			static void QueryQueueFamilyProperties(Handle _handle, uint32* _numQueueFamilies, QueueFamilyProperties* _queueFamilies)
			{
				vkGetPhysicalDeviceQueueFamilyProperties(_handle, _numQueueFamilies, *_queueFamilies);
			}	

			/**
			* @brief Query properties of queues available on a physical device.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties2">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			static void QueryQueueFamilyProperties2
			(
				Handle                  _handle       ,
				uint32*                 _numProperties,
				QueueFamilyProperties2* _properties
			)
			{
				vkGetPhysicalDeviceQueueFamilyProperties2(_handle, _numProperties, *_properties);
			}

			/**
			* @brief Enumerate the performance query counters available on a queue family of a physical device.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			static EResult QueryPerfomranceQueryCounters
			(
				Handle                           _handle             ,
				uint32                           _queueFamilyIndex   ,
				uint32*                          _numCounters        ,
				PerformanceCounter*              _counters           ,
				PerformanceCounter::Description* _counterDescriptions
			)
			{
				return EResult(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
				(
							   _handle              ,
							   _queueFamilyIndex    ,
							   _numCounters         ,
							   *_counters           ,
							   *_counterDescriptions
				));
			}
		};

		using QueueFamilyProperties = PhysicalDevice::QueueFamilyProperties;

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		using V1::ExtensionProperties;

		/**
		@brief Represents a physical device.

		@ingroup
		*/
		struct PhysicalDevice : V1::PhysicalDevice
		{
			using Parent = V1::PhysicalDevice;

			/**
			* @brief Checks to see if the specified extensions are supported by the physical device.
			*/
			static bool CheckExtensionSupport(Handle _handle, RoCStr _extensionSpecified)
			{
				DynamicArray<ExtensionProperties> availableExtensions;

				GetAvailableLayerExtensions(_handle, nullptr, availableExtensions);

				bool isSupported = false;

				for (const auto& extension : availableExtensions)
				{
					if (strcmp(extension.Name, _extensionSpecified) == 0)
					{
						isSupported = true;
					}
				}

				return isSupported;
			}

			/**
			* @brief Checks to see if the specified extensions are supported by the physical device.
			*/
			static bool CheckExtensionSupport(Handle _handle, DynamicArray<RoCStr> _extensionsSpecified)
			{
				DynamicArray<ExtensionProperties> availableExtensions;

				GetAvailableLayerExtensions(_handle, nullptr, availableExtensions);

				using ExtensionNameSet = std::set<std::string>;

				ExtensionNameSet requiredExtensions(_extensionsSpecified.begin(), _extensionsSpecified.end());

				for (const auto& extension : availableExtensions)
				{
					requiredExtensions.erase(extension.Name);
				}

				bool isSupported = requiredExtensions.empty();

				return isSupported;
			}

			/**
			@brief Checks to see if the formats in _canidates are available for the specified physical device, if the format is found, 
			it will be returned with the format container reference.	
			*/
			static EResult FindSupportedFormat(Handle _handle, const DynamicArray<EFormat>& _canidates, EImageTiling _tiling, FormatFeatureFlags _features, EFormat& _format)
			{
				for (EFormat possibleFormat : _canidates)
				{
					FormatProperties formatProperties;

					Parent::GetFormatProperties(_handle, possibleFormat, formatProperties);

					switch (_tiling)
					{
						case EImageTiling::Linear:
						{
							if (formatProperties.LinearTilingFeatures.CheckForEither(_features))
							{
								_format = possibleFormat;

								return EResult::Success;
							}

							break;
						}
						case EImageTiling::Optimal:
						{
							if (formatProperties.OptimalTilingFeatures.CheckForEither(_features))
							{
								_format = possibleFormat;

								return EResult::Success;
							}

							break;
						}
					}
				}

				return EResult::Error_FormatNotSupported;
			}

			/**
			@brief Finds the memory type index based on the type filter and properties desired. (Returns the max value of uint32 otherwise)
			*/
			static uint32 FindMemoryType(Handle _handle, uint32 _typeFilter, Memory::PropertyFlags _properties)
			{
				MemoryProperties memProperties;

				GetMemoryProperties(_handle, memProperties);

				for (uint32 index = 0; index < memProperties.TypeCount; index++)
				{
					if
						(
						_typeFilter & (1 << index) &&
						(memProperties.Types[index].PropertyFlags & _properties) == _properties
						)
					{
						return index;
					}
				}

			#ifdef VT_Option__Use_STL_Exceptions
				throw std::runtime_error("Failed to find suitable memory type!");
			#else
				return 4294967295;
			#endif
			}

			/**
			@brief Provides the available layer extensions for the specified layer name into the _extensionListing container.
			*/
			static EResult GetAvailableLayerExtensions(Handle _handle, RoCStr _layerName, DynamicArray<ExtensionProperties>& _extensionListing)
			{
				uint32 count;

				EResult returnCode = QueryExtensionProperties(_handle, _layerName, &count, nullptr);

				if (returnCode != EResult::Success) return returnCode;

				_extensionListing.resize(count);

				returnCode = QueryExtensionProperties(_handle, _layerName, &count, _extensionListing.data());

				return returnCode;
			}

			/**
			* @brief Gets all extensions for the known layers that the physical device supports.
			* 
			* @details 
			* Note: The layers and extensions container must have the layer properties member of each element populated
			* by the application instance.
			* 
			* \param _layersAndExtensions
			* \return 
			*/
			static EResult GetAvailableLayersAndExtensions(Handle _handle, DynamicArray<LayerAndExtensionProperties>& _layersAndExtensions)
			{
				EResult result;

				for (uint32 index = 0; index < _layersAndExtensions.size(); index++)
				{
					result = GetAvailableLayerExtensions(_handle, _layersAndExtensions[index].Layer.Name, _layersAndExtensions[index].Extensions);

					if (result != EResult::Success) return result;
				}

				return result;
			}

			/**
			* @brief Provides the queue families for the respective device.
			* 
			* \param _device
			* \return 
			*/
			static DynamicArray<QueueFamilyProperties> GetAvailableQueueFamilies(Handle _handle)
			{
				DynamicArray<QueueFamilyProperties> queryResult; uint32 count;

				QueryQueueFamilyProperties(_handle, &count, nullptr);

				queryResult.resize(count);

				QueryQueueFamilyProperties(_handle, &count, queryResult.data());

				return queryResult;
			}

			/**
			@brief Gets the maximum sample count allowed for color and depth.
			*/
			static ESampleCount GetMaxSampleCount_ColorAndDepth(Handle _handle)
			{
				Properties properties;

				GetProperties(_handle, properties);

				SampleCountFlags counts
				(
					properties.LimitsSpec.FramebufferColorSampleCounts, 
					properties.LimitsSpec.FramebufferDepthSampleCounts
				);

				if (counts.HasFlag(ESampleCount::_64)) return ESampleCount::_64;
				if (counts.HasFlag(ESampleCount::_32)) return ESampleCount::_32;
				if (counts.HasFlag(ESampleCount::_16)) return ESampleCount::_16;
				if (counts.HasFlag(ESampleCount::_8 )) return ESampleCount::_8 ;
				if (counts.HasFlag(ESampleCount::_4 )) return ESampleCount::_4 ;
				if (counts.HasFlag(ESampleCount::_2 )) return ESampleCount::_2 ;

				return ESampleCount::_1;
			}
		};

		using QueueFamilyProperties = PhysicalDevice::QueueFamilyProperties;

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief Represents a physical device.

		@details This object only acts as a host interface to a given device object's handle. 
		*/
		class PhysicalDevice : public V2::PhysicalDevice
		{
		public:

			using Parent = V2::PhysicalDevice;

			/**
			@brief Default constructor.
			*/
			PhysicalDevice() : handle(Null<Handle>)
			{}

			/**
			@brief Default constructor with handle specified.
			*/
			PhysicalDevice(Handle _handle) : handle(_handle)
			{
				Parent::GetFeatures        (handle, features        );
				Parent::GetMemoryProperties(handle, memoryProperties);
				Parent::GetProperties      (handle, properties      );
				Parent::GetProperties      (handle, properties      );
				Parent::GetProperties2     (handle, properties2     );
			}

			/**
			@brief Assigns the handle.
			*/
			void AssignHandle(Handle _handle) 
			{ 
				handle = _handle; 

				Parent::GetFeatures        (handle, features        );
				Parent::GetMemoryProperties(handle, memoryProperties);
				Parent::GetProperties      (handle, properties      );
				Parent::GetProperties      (handle, properties      );
				Parent::GetProperties2     (handle, properties2     );
			}

			/**
			* @brief Checks to see if the specified extensions are supported by the physical device.
			* 
			* @todo make the extensions specified container generic using an interface.
			*/
			bool CheckExtensionSupport(RoCStr _extensionSpecified) const
			{
				DynamicArray<ExtensionProperties> availableExtensions;

				GetAvailableExtensions(nullptr, availableExtensions);

				bool isSupported = false;

				for (const auto& extension : availableExtensions)
				{
					if (strcmp(extension.Name, _extensionSpecified) == 0)
					{
						isSupported = true;
					}
				}

				return isSupported;
			}

			/**
			@brief Checks to see if the extensions specified are supported.
			*/
			bool CheckExtensionSupport(DynamicArray<RoCStr> _extensionsSpecified) const
			{
				DynamicArray<ExtensionProperties> availableExtensions;

				GetAvailableExtensions(nullptr, availableExtensions);

				using ExtensionNameSet = std::set<std::string>;

				ExtensionNameSet requiredExtensions(_extensionsSpecified.begin(), _extensionsSpecified.end());

				for (const auto& extension : availableExtensions)
				{
					requiredExtensions.erase(extension.Name);
				}

				bool isSupported = requiredExtensions.empty();

				return isSupported;
			}

			/**
			@brief Find the suitable memory type for the type filter and properties specified.
			*/
			uint32 FindMemoryType(uint32 _typeFilter, Memory::PropertyFlags _properties) const
			{
				for (uint32 index = 0; index < memoryProperties.TypeCount; index++)
				{
					auto flags = memoryProperties.Types[index].PropertyFlags;

					if
						(
						_typeFilter & (1 << index) &&
						(flags & _properties) == _properties
						)
					{
						return index;
					}
				}

			#ifdef VT_Option__Use_STL_Exceptions
				throw std::runtime_error("Failed to find suitable memory type!");
			#endif

				return 4294967295;
			}

			/**
			@brief Provides the queue families for the respective device.
			*/
			EResult FindSupportedFormat(const DynamicArray<EFormat>& _canidates, EImageTiling _tiling, FormatFeatureFlags _features, EFormat& _format) const
			{
				return Parent::FindSupportedFormat(handle, _canidates, _tiling, _features, _format);
			}

			/**
			@brief Assigns the handle.
			*/
			EResult GetAvailableExtensions(RoCStr _layerName, DynamicArray<ExtensionProperties>& _extensionListing) const
			{
				return EResult(Parent::GetAvailableLayerExtensions(handle, _layerName, _extensionListing));
			}

			/**
			@brief Provides the available queue families in a dynamic array.
			*/
			DynamicArray<QueueFamilyProperties> GetAvailableQueueFamilies() const
			{
				DynamicArray<QueueFamilyProperties> queryResult; uint32 count;

				QueryQueueFamilyProperties(&count, nullptr);

				queryResult.resize(count);

				QueryQueueFamilyProperties(&count, queryResult.data());

				return queryResult;
			}

			/**
			@brief Provides features.
			*/
			const Features& GetFeatures() const
			{
				return features;
			}

			/**
			@brief Query supported format features which are properties of the physical device.
			*/
			FormatProperties GetFormatProperties(EFormat _format) const
			{
				FormatProperties formatProperties;

				Parent::GetFormatProperties(handle, _format, formatProperties);

				return formatProperties;
			}

			/**
			@brief Gets the max sample count between color and depth.
			*/
			ESampleCount GetMaxSampleCount_ColorAndDepth() const
			{
				SampleCountFlags counts
				(
					properties.LimitsSpec.FramebufferColorSampleCounts,
					properties.LimitsSpec.FramebufferDepthSampleCounts
				);

				if (counts.HasFlag(ESampleCount::_64)) return ESampleCount::_64;
				if (counts.HasFlag(ESampleCount::_32)) return ESampleCount::_32;
				if (counts.HasFlag(ESampleCount::_16)) return ESampleCount::_16;
				if (counts.HasFlag(ESampleCount::_8 )) return ESampleCount::_8 ;
				if (counts.HasFlag(ESampleCount::_4 )) return ESampleCount::_4 ;
				if (counts.HasFlag(ESampleCount::_2 )) return ESampleCount::_2 ;

				return ESampleCount::_1;
			}

			/**
			@brief Provides the memory properties
			*/
			const MemoryProperties& GetMemoryProperties() const
			{
				return memoryProperties;
			}

			/**
			@brief Provides the properties.
			*/
			const Properties& GetProperties() const
			{
				return properties;
			}

			/**
			@brief Provides the properties 2.
			*/
			const Properties2& GetProperties2() const
			{
				return properties2;
			}

			/**
			@brief Query properties of queues available on a physical device. Reports properties of the queues of the specified physical device.
			*/
			EResult QueryExtensionProperties(RoCStr _layerName, uint32* _numExtensions, ExtensionProperties* _extensionPropertiesContainer) const
			{
				return Parent::QueryExtensionProperties(handle, _layerName, _numExtensions, _extensionPropertiesContainer);
			}

			/**
			@brief Query properties of queues available on a physical device.
			*/
			void QueryQueueFamilyProperties(uint32* _numQueueFamilies, QueueFamilyProperties* _queueFamilies) const
			{
				return Parent::QueryQueueFamilyProperties(handle, _numQueueFamilies, _queueFamilies);
			}

			/**
			@brief Query properties of queues available on a physical device.
			*/
			void QueryQueueFamilyProperties2(uint32* _numProperties, QueueFamilyProperties2* _properties) const
			{
				return Parent::QueryQueueFamilyProperties2(handle, _numProperties, _properties);
			}

			/**
			@brief Enumerate the performance query counters available on a queue family of a physical device.
			*/
			EResult QueryPerfomranceQueryCounters
			(
				uint32                           _queueFamilyIndex   ,
				uint32*                          _numCounters        ,
				PerformanceCounter*              _counters           ,
				PerformanceCounter::Description* _counterDescriptions
			) const
			{
				return Parent::QueryPerfomranceQueryCounters(handle, _queueFamilyIndex, _numCounters, _counters, _counterDescriptions);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const PhysicalDevice& _other) const
			{
				return handle == _other.handle;
			}

		protected:

			Handle handle;

			EDeviceType type    ;
			EDriverID   driverID;
			EVendorID   vendorID;

			Features features; 

			MemoryProperties memoryProperties; 

			Properties  properties ;
			Properties2 properties2;
		};

		using QueueFamilyProperties = PhysicalDevice::QueueFamilyProperties;

		/** @} */
	}
}




/*!
@file VT_Initialization.hpp

@brief Vaulted Thermals: Initialization

@details Before using Vulkan, an application must initialize it by loading the Vulkan commands, and creating a VkInstance object.

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#initialization">
Initialization Specification
</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace Corridors
	{
		/**
		@addtogroup Corridors
		@{
		*/

		/**
		@ingroup Extending_Vulkan
		@brief Construct an API version number.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_MAKE_VERSION">Specification</a> 

		@param _major Major version number.
		@param _minor Minor version number.
		@param _patch Patch version number.
		*/
		inline uInt32 MakeVersion(uInt32 _major, uInt32 _minor, uInt32 _patch)
		{
			return VK_MAKE_VERSION(_major, _minor, _patch);
		}

		/** @} */
	}

	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@brief An object that manages the represented application process state within the GPU.

		Other Name: Application State Container

		@details
		Vulkan has no global state reference: 
		Every application must keep track of their state using an instance object.

		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkInstance">Application Instance Specification</a> 

		@ingroup APISpec_Initialization
		*/
		struct AppInstance
		{
			using Memory = V0::Memory;

			/**
			@brief Opaque handle to an instance object.
			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkInstance">Specification</a>

			@ingroup APISpec_Initialization
			*/
			using Handle = VkInstance;

			/**
			@ingroup APISpec_Initialization
			@brief Reserved for future use...

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkInstanceCreateFlags">Specification</a>
			*/
			using CreateFlags = Bitmask<EUndefined, VkInstanceCreateFlags>;

			/**
			@ingroup APISpec_Initialization
			@brief A structure that specifies to the Vulkan driver information about an application that will run an instance.
			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkApplicationInfo">Application Info Specification</a> 
			*/
			struct AppInfo : V0::VKStruct_Base<VkInstanceCreateInfo, EStructureType::ApplicationInformation>
			{
				EType        SType         = STypeEnum         ;
				const void*        Next          = nullptr           ;
				RoCStr       AppName       = nullptr           ;
				uint32       AppVersion    = 0                 ;
				RoCStr       EngineName    = nullptr           ;
				uint32       EngineVersion = 0                 ;
				EAPI_Version API_Version   = EAPI_Version::_1_2;
			};

			/**
			@ingroup APISpec_Initialization
			@brief Structure specifying parameters of a newly created instance.
			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkInstanceCreateInfo">Create Info Specification</a> 
			*/
			struct CreateInfo : V0::VKStruct_Base<VkInstanceCreateInfo, EStructureType::Instance_CreateInfo>
			{
				EType             SType                 = STypeEnum;
				const void*             Next                  = nullptr  ;
				CreateFlags       Flags                ;
				const AppInfo*          AppInfo               = nullptr  ;
				uint32            EnabledLayerCount     = 0        ;
				RoArray_of_RoCStr EnabledLayerNames     = nullptr  ;
				uint32            EnabledExtensionCount = 0        ;
				RoArray_of_RoCStr EnabledExtensionNames = nullptr  ;
			};

			/**
			@brief Used when creating a Vulkan app instance and want to enable specific validation features. (Added to the Next chain).

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkValidationFeaturesEXT">Specification</a> 

			@ingroup APISpec_Initialization
			*/
			struct ValidationFeatures : V0::VKStruct_Base<VkValidationFeaturesEXT, EStructureType::ValidationFeatures_EXT>
			{
				EType                     SType                          = STypeEnum;
				const void*                     Next                           = nullptr  ;
				uint32                    EnabledValidationFeatureCount  = 0        ;
				const EValidationFeatureEnable* EnabledValidationFeatures      = nullptr  ;
				uint32                    DisabledValidationFeatureCount = 0        ;
				const EValidationFeatureEnable* DisabledValidationFeatures     = nullptr  ;
			};

			/**
			@brief Used when creating a Vulkan app instance and want to disable validation checks.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkValidationFlagsEXT">Specification</a> 

			@ingroup APISpec_Initialization
			*/
			struct ValidationFlags : V0::VKStruct_Base<VkValidationFlagsEXT, EStructureType::ValidationFlags_EXT>
			{
				EType             SType                        = STypeEnum;
				const void*             Next                         = nullptr  ;
				uint32            DisabledValidationCheckCount = 0        ;
				const EValidationCheck* DisabledValidationChecks     = nullptr  ;
			};

			/**
			@ingroup APISpec_Initialization
			@brief Create a new Vulkan application instance.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateInstance">Create Instance Specification</a> 

			@param _info      The creation specification structure to use.
			@param _allocator Allocator desired (Memory::DefaultAllocator if default desired).
			@param _handle    Reference to object that will have the created object's handle written to (if successful).

			@return Returns EResult code (Indicating how the creation went).
			*/
			static EResult Create(const CreateInfo& _info, const Memory::AllocationCallbacks* _allocator, Handle& _handle)
			{
				return EResult(vkCreateInstance( _info, *_allocator, &_handle));
			}

			/**
			@ingroup APISpec_Initialization
			@brief Destroy an application instance of Vulkan.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyInstance">Destroy Instance Specification</a> 

			@param _handle    Handle of the AppInstance.
			@param _allocator Optional: Allocator to use (Memory::DefaultAllocator if default desired).
			*/
			static void Destroy(Handle _handle , const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyInstance(_handle, *_allocator);
			}

			/**
			* @brief Query the version of application instance-level functionality supported by the implementation.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEnumerateInstanceVersion">Specification</a> 
			* 
			* @ingroup APISpec_Initialization
			* 
			* @param _versionContainer The value of version will be written to this object referenced.
			* 
			* @return Returns EResult code (Indicating the version was able to be retrieved).
			*/
			static EResult GetVersion(uint32& _versionContainer)
			{
				return EResult(vkEnumerateInstanceVersion(&_versionContainer));
			}

			/** 
			@ingroup APISpec_Extending_Vulkan
			@brief Query the available layers.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEnumerateInstanceLayerProperties">Specification</a>  

			@param _numContainer         Referenced object that will either specify the number of available layers to retrieve (if _propertiesContainer is not null), 
			or be written to with the number of available layers (if _propertiesContainer is null).
			@param _propertiesContainer	 Pointer to a properties container array that will be populated if the pointer is not null.

			@return Returns EResult code (Indicating whether query was successful)
			*/
			static EResult QueryAvailableLayers(uint32& _numContainer, LayerProperties* _propertiesContainer)
			{
				return EResult(vkEnumerateInstanceLayerProperties(&_numContainer, *_propertiesContainer));
			}

			/**
			@ingroup APISpec_Extending_Vulkan
			* @brief Query the available instance extensions.

			@details 
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEnumerateInstanceExtensionProperties">Specification</a>.

			*/
			static EResult QueryAvailableAppExtensions(RoCStr _layerName, uint32& _numProperties, ExtensionProperties* _propertiesContainer)
			{
				return EResult(vkEnumerateInstanceExtensionProperties(_layerName, &_numProperties, *_propertiesContainer));
			}

			/**
			@brief Retrieve a list of physical device objects representing the physical devices installed in the system, or get the number of them.

			@details
			If pPhysicalDevices is NULL, then the number of physical devices available is returned in pPhysicalDeviceCount. 
			Otherwise, pPhysicalDeviceCount must point to a variable set by the user to the number of elements in the pPhysicalDevices array, 
			and on return the variable is overwritten with the number of handles actually written to pPhysicalDevices.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#devsandqueues-physical-device-enumeration">Specification</a> 

			@ingroup APISpec_Devices_and_Queues
			*/
			static EResult QueryPhysicalDeviceListing(Handle _handle, uint32* _numDevices, PhysicalDevice::Handle* _deviceListing)
			{
				return EResult(vkEnumeratePhysicalDevices(_handle, _numDevices, _deviceListing));
			}

			/**
			* @brief Retrieve a list of physical device groups.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEnumeratePhysicalDeviceGroups">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			static EResult QueryPhysicalDeviceGroups
			(
				Handle                 _handle         ,
				uint32*                _numGroups      ,
				PhysicalDevice::Group* _groupProperties
			)
			{
				return EResult(vkEnumeratePhysicalDeviceGroups(_handle, _numGroups, *_groupProperties));
			}

			template<typename ReturnType>
			/**

			@brief
			Function pointers for all Vulkan commands can be obtained with this command.

			@details
			vkGetInstanceProcAddr itself is obtained in a platform- and loader- specific manner. 
			Typically, the loader library will export this command as a function symbol, 
			so applications can link against the loader library, or load it dynamically 
			and look up the symbol using platform-specific APIs.

			Note: ReturnType is restricted to only function pointing types.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetInstanceProcAddr">Specification</a> 

			@ingroup APISpec_Initialization
			*/
			static typename std::enable_if
				<
				std::bool_constant
				< 
				std::is_pointer <                             ReturnType       >::value &&
				std::is_function<typename std::remove_pointer<ReturnType>::type>::value
				>::value,

				ReturnType>::type GetProcedureAddress(Handle& _handle, RoCStr _procedureName)
			{
				return reinterpret_cast<ReturnType>(vkGetInstanceProcAddr(_handle, _procedureName));
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief An object that manages the represented application process state within the GPU.

		@details
		Other Name: Application State Container

		Vulkan has no global state reference: 
		Every application must keep track of their state using an instance object.

		@ingroup APISpec_Initialization
		*/
		struct AppInstance : public V1::AppInstance
		{
			using Parent = V1::AppInstance;

			/**
			@brief Create a new Vulkan application instance. (Use default allocator)
			*/
			static EResult Create(const CreateInfo& _info, Handle& _handle)
			{
				return Parent::Create(_info, Memory::DefaultAllocator, _handle);
			}

			using Parent::Create;

			/**
			@brief Destroy an application instance of Vulkan. (Use Default allocator)
			*/
			static void Destroy(Handle _handle)
			{
				Parent::Destroy(_handle, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			@brief Get available layers into a dynamic array. 
			*/
			static EResult GetAvailableLayers(DynamicArray<LayerProperties>& _container)
			{
				uint32 layerCount;

				EResult result = QueryAvailableLayers(layerCount, nullptr);

				if (result != EResult::Success) return result;

				_container.resize(layerCount);

				result = QueryAvailableLayers(layerCount, _container.data());

				return result;
			}

			/**
			@brief Get available layer extensions into a dynamic array with the specified layer name.
			*/
			static EResult GetAvailableLayerExtensions(RoCStr _layerName, DynamicArray<ExtensionProperties>& _propertiesContainer)
			{
				uint32 layerCount;

				EResult result = QueryAvailableAppExtensions(_layerName, layerCount, nullptr);

				if (result != EResult::Success) return result;

				_propertiesContainer.resize(layerCount);

				result = QueryAvailableAppExtensions(_layerName, layerCount, _propertiesContainer.data());

				return result;
			}

			/**
			Get the layers and their extensions in a dynamic array of the layer and extensions properties struct.
			*/
			static EResult GetAvailableLayersAndExtensions(DynamicArray<LayerAndExtensionProperties>& _layersAndExtensions)
			{
				DynamicArray<LayerProperties> layers; EResult result = EResult::Incomplete;

				GetAvailableLayers(layers);

				_layersAndExtensions.resize(layers.size());

				for (uint32 index = 0; index < layers.size(); index++)
				{
					_layersAndExtensions[index].Layer = layers[index];

					result = GetAvailableLayerExtensions(_layersAndExtensions[index].Layer.Name, _layersAndExtensions[index].Extensions);

					if (result != EResult::Success) return result;
				}

				return result;
			}

			/** 
			@brief Provides the handles of all available physical devices.

			@todo Make the device listing container type specifiable using an interface.
			*/
			static EResult GetAvailablePhysicalDevices(Handle _handle, DynamicArray<PhysicalDevice::Handle>& _deviceListing)
			{
				uint32 count; 

				//auto casted = reinterpret_cast<Vault_0::IDynamicArray<PhysicalDevice::Handle>*>(_deviceListing);

				EResult returnCode = QueryPhysicalDeviceListing(_handle, &count, nullptr);

				if (returnCode != EResult::Success) return returnCode;

				_deviceListing.resize(count);

				returnCode = QueryPhysicalDeviceListing(_handle, &count, _deviceListing.data());

				return returnCode;
			}

			/**
			* @brief Provides a list of the device groups present in the system.
			* 
			* @todo Make the group listing container type specifiable using an interface.
			* 
			* \param _instance
			* \param _groupListing
			* \return 
			*/
			static EResult GetAvailablePhysicalDeviceGroups(Handle _handle, DynamicArray<PhysicalDevice::Group>& _groupListing)
			{
				uint32 count;

				EResult returnCode = QueryPhysicalDeviceGroups(_handle, &count, nullptr);

				if (returnCode != EResult::Success) return returnCode;

				_groupListing.resize(count);

				returnCode = QueryPhysicalDeviceGroups(_handle, &count, _groupListing.data());

				return returnCode;
			}
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief An object that manages the represented application process state within the GPU.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.

		@ingroup APISpec_Initialization
		*/
		class AppInstance : public V2::AppInstance
		{
		public:
			using Parent = V2::AppInstance;

			/**
			@brief Will construct an AppInstance host object with a null handle and allocator set to default.
			*/
			AppInstance() : handle(Null<Handle>), allocator(Memory::DefaultAllocator)
			{}

			/**
			@brief Will construct an AppInstance host object with a null handle a the allocator set to the specified allocator.
			*/
			AppInstance(const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			AppInstance(AppInstance&& _other) noexcept :
				handle(_other.handle), allocator(_other.allocator)
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
			}

			/**
			@brief If the handle is found to not be null, this device will attempt to destroy the device object that corresponds to it.
			*/
			~AppInstance()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			* @brief Create an application instance.
			* 
			* @param _appInfo
			* @param _creationSpec
			*/
			EResult Create(const AppInstance::CreateInfo& _createinfo)
			{
				return Parent::Create(_createinfo, handle);
			}

			/**
			* @brief Create an application instance.
			* 
			* @param _appInfo
			* @param _creationSpec
			* @param _allocator
			*/
			EResult Create(const AppInstance::CreateInfo& _createInfo, const Memory::AllocationCallbacks& _allocator)
			{
				allocator = &_allocator;

				return Parent::Create(_createInfo, allocator, handle);
			}

			/**
			* @brief Destroy an application instance.
			*/
			void Destroy()
			{
				Parent::Destroy(handle, allocator);

				handle    = Null<Handle>;
				allocator = nullptr     ;
			}

			/** 
			@brief Provides the handles of all available physical devices.
			*/
			EResult GetAvailablePhysicalDevices(DynamicArray<PhysicalDevice>& _deviceListing) const 
			{
				uint32 count; DynamicArray<PhysicalDevice::Handle> handleList;

				EResult returnCode = QueryPhysicalDeviceListing(&count, nullptr);

				if (returnCode != EResult::Success) return returnCode;

				handleList    .resize(count);
				_deviceListing.resize(count);

				returnCode = QueryPhysicalDeviceListing(&count, handleList.data());

				for (DeviceSize index = 0; index < count; index++)
				{
					_deviceListing[index].AssignHandle(handleList[index]);
				}

				return returnCode;
			}

			/**
			* @brief Provides a list of the device groups present in the system.
			* 
			* \param _instance
			* \param _groupListing
			* \return 
			*/
			EResult GetAvailablePhysicalDeviceGroups(DynamicArray<PhysicalDevice::Group>& _groupListing) const
			{
				uint32 count;

				EResult returnCode = QueryPhysicalDeviceGroups(&count, nullptr);

				if (returnCode != EResult::Success) return returnCode;

				_groupListing.resize(count);

				returnCode = QueryPhysicalDeviceGroups(&count, _groupListing.data());

				return returnCode;
			}

			template<typename ReturnType>
			/**
			Function pointers for all Vulkan commands can be obtained with this command.

			vkGetInstanceProcAddr itself is obtained in a platform- and loader- specific manner. 
			Typically, the loader library will export this command as a function symbol, 
			so applications can link against the loader library, or load it dynamically 
			and look up the symbol using platform-specific APIs.

			Note: ReturnType is restricted to only function pointing types.

			https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkGetInstanceProcAddr.html
			*/
			typename std::enable_if
				<
				std::bool_constant
				< 
				std::is_pointer <                             ReturnType       >::value &&
				std::is_function<typename std::remove_pointer<ReturnType>::type>::value
				>::value,

				ReturnType>::type GetProcedureAddress(RoCStr _procedureName) const
			{
				return Parent::GetProcedureAddress(handle, _procedureName);  // reinterpret_cast<ReturnType>(vkGetInstanceProcAddr(handle, _procedureName));
			}

			/**
			@brief Retrieve a list of physical device objects representing the physical devices installed in the system, or get the number of them.

			@details
			If pPhysicalDevices is NULL, then the number of physical devices available is returned in pPhysicalDeviceCount. 
			Otherwise, pPhysicalDeviceCount must point to a variable set by the user to the number of elements in the pPhysicalDevices array, 
			and on return the variable is overwritten with the number of handles actually written to pPhysicalDevices.
			*/
			EResult QueryPhysicalDeviceListing(uint32* _numDevices, PhysicalDevice::Handle* _deviceListing) const
			{
				return Parent::QueryPhysicalDeviceListing(handle, _numDevices, _deviceListing);
			}

			/**
			@brief Retrieve a list of physical device groups.
			*/
			EResult QueryPhysicalDeviceGroups(uint32* _numGroups, PhysicalDevice::Group* _groupProperties) const
			{
				return Parent::QueryPhysicalDeviceGroups(handle, _numGroups, _groupProperties);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const AppInstance& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			AppInstance& operator= (AppInstance&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = _other.handle   ;
				allocator = _other.allocator;

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;
		};

		/** @} */
	}
}




/*!
@file VT_LogicalDevice.hpp

@brief Vaulted Thermals: Logical Device
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@ingroup APISpec_Devices_and_Queues
		@brief Represent logical connections to physical devices. 

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#devsandqueues-devices">Specification</a> 
		*/
		struct LogicalDevice
		{
			using Memory = V0::Memory;

			/**
			@ingroup APISpec_Devices_and_Queues
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDevice">Specification</a> 
			*/
			using Handle = VkDevice;

			using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future use.

															  /**
															  @ingroup APISpec_Devices_and_Queues
															  @brief 
															  When using the Nsight™ Aftermath SDK, to configure how device crash dumps are created, add a VkDeviceDiagnosticsConfigCreateInfoNV structure 
															  to the pNext chain of the VkDeviceCreateInfo structure.

															  @details
															  <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceDiagnosticsConfigCreateInfoNV">Specification</a> 
															  */
			struct DiagnosticsConfigCreateInfo : V0::VKStruct_Base<VkDeviceDiagnosticsConfigCreateInfoNV, EStructureType::DeviceDiagnosticsConfig_CreateInfo_NV>
			{
				using ConfigFlags = Bitmask<EDeviceDiagnosticConfigFlag, VkDeviceDiagnosticsConfigFlagsNV>;

				EType       SType = STypeEnum;
				const void*       Next  = nullptr  ;
				ConfigFlags Flags;
			};

			/**
			@ingroup APISpec_Devices_and_Queues
			@brief Queues handle different types of batched commands for the GPU to complete.
			@details 
			Vulkan queues provide an interface to the execution engines of a device. 
			Commands for these execution engines are recorded into command buffers ahead of execution time.
			These command buffers are then submitted to queues with a queue submission command for execution in a number of batches. 
			Once submitted to a queue, these commands will begin and complete execution without further application intervention,
			though the order of this execution is dependent on a number of implicit and explicit ordering constraints.
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-queueoperation">Specification</a> 
			*/
			struct Queue
			{
				/**
				@ingroup APISpec_Devices_and_Queues
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueue">Specification</a> 
				*/
				using Handle = VkQueue;

				using ECreateFlag = ELogicalDeviceQueueCreateFlag;

				/** @ingroup APISpec_Devices_and_Queues @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueCreateFlags">Specification</a> */
				using CreateFlags = Bitmask<ECreateFlag, VkDeviceQueueCreateFlags>;

				/**
				@ingroup APISpec_Window_System_Integration_WSI
				@brief Used to specify parameters for a presentation.
				@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPresentInfoKHR">Specification</a> 
				*/
				using PresentationInfo = VkPresentInfoKHR;

				/**
				@ingroup APISpec_Command_Buffers
				@brief Specifies a command buffer submission batch
				@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubmitInfo">Specification</a> 
				*/
				using SubmitInfo = VkSubmitInfo;

				/**
				@brief Internal definition of a fence (not defined yet...)
				*/
				using Fence_Handle = VkFence;

				/**
				@ingroup APISpec_Devices_and_Queues
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueCreateInfo">Specification</a> 
				@details A queue is allocated by the family, as in each queue allocated must have their index in the family tracked.
				This means that the logical device is passed a queue's create info by the family with its specified index,
				queue count from that family to be associated with the logical device, and the family's priority.
				If a queue family is to be used for a specific task (transfer, etc), it is advantageous that that queue family 
				have as little flags for other functionality as possible.
				*/
				struct CreateInfo : V0::VKStruct_Base<VkDeviceQueueCreateInfo, EStructureType::DeviceQueue_CreateInfo>
				{
					EType       SType            = STypeEnum       ;
					const void*       Next             = nullptr         ;
					CreateFlags Flags           ;
					uint32      QueueFamilyIndex;
					uint32      QueueCount      ;
					const float*      QueuePriorities ;
				};

				/**
				* @brief Get a queue handle from a device.
				* 
				* @details
				* vkGetDeviceQueue must only be used to get queues that were created with the flags parameter of VkDeviceQueueCreateInfo set to zero. 
				* To get queues that were created with a non-zero flags parameter use vkGetDeviceQueue2.
				* 
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetDeviceQueue">Specification</a>
				* 
				* @ingroup APISpec_Devices_and_Queues
				* 
				* \param _handle
				* \param _queueFamilyIndex
				* \param _queueIndex
				* \param _queueReturn
				*/
				static void Get(LogicalDevice::Handle _device, uint32 _queueFamilyIndex, uint32 _queueIndex, Handle& _queueReturn)
				{
					vkGetDeviceQueue(_device, _queueFamilyIndex, _queueIndex, &_queueReturn);
				}

				/**
				* @brief Queue an image for presentation.
				* 
				* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkQueuePresentKHR">Specification</a> 
				* 
				* @ingroup APISpec_Window_System_Integration_WSI
				* 
				* \param _queue
				* \param _presentation
				* \return 
				*/
				static EResult QueuePresentation(LogicalDevice::Queue::Handle _queue, const PresentationInfo& _presentation)
				{
					return EResult(vkQueuePresentKHR(_queue, &_presentation));
				}

				/**
				@brief Submit command buffers to the queue.

				@details
				<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkQueueSubmit">Specification</a>

				@ingroup APISpec_Command_Buffers
				*
				* \param _queue
				* \param _submitCount
				* \param _submissions
				* \param _fence
				* \return 
				*/
				static EResult SubmitToQueue
				(
					LogicalDevice::Queue::Handle _queue      ,
					uint32                       _submitCount,
					const SubmitInfo*                  _submissions,
					Fence_Handle                 _fence
				)
				{
					return EResult(vkQueueSubmit(_queue, _submitCount, _submissions, _fence));
				}

				/**
				* @brief To wait on the host for the completion of outstanding queue operations for a given queue.
				* 
				* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkQueueWaitIdle">Specification</a> 
				* 
				* @ingroup APISpec_Synchronization_and_Cache_Control
				* 
				* \param _queue
				* \return 
				*/
				static EResult WaitUntilIdle(Handle _queue)
				{
					return EResult(vkQueueWaitIdle(_queue));
				}
			};

			/**
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueInfo2">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct Queue2 : V0::VKStruct_Base<VkDeviceQueueInfo2, EStructureType::DeviceQueueInfo2>
			{
				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceQueueCreateFlags">Specification</a> @ingroup APISpec_Devices_and_Queues */
				using CreateFlags = Bitmask<EDeviceQueueCreateFlag ,VkDeviceQueueCreateFlags>;

				EType       SType            = STypeEnum;
				const void*       Next             = nullptr  ;
				CreateFlags Flags           ;
				uint32      QueueFamilyIndex;
				uint32      QueueIndex      ;

				/**
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetDeviceQueue2">Specification</a> 
				* 
				* @ingroup APISpec_Devices_and_Queues
				*/
				static void Get
				(
					Handle         _device   ,
					const Queue2*        _queueInfo,
					Queue::Handle* _queue
				)
				{
					vkGetDeviceQueue2(_device, *_queueInfo, _queue);
				}
			};

			/**
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceGroupDeviceCreateInfo">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct GroupCreateInfo : V0::VKStruct_Base<VkDeviceGroupDeviceCreateInfo, EStructureType::Device_GroupDevice_CreateInfo>
			{
				EType   SType               = STypeEnum;
				const void*   Next                = nullptr  ;
				uint32  PhysicalDeviceCount = 0        ;
				const Handle* PhysicalDevices     = nullptr  ;
			};

			/**
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceMemoryOverallocationCreateInfoAMD">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct MemoryOverallocationCreateInfo : V0::VKStruct_Base<VkDeviceMemoryOverallocationCreateInfoAMD, EStructureType::DeviceMemory_Overallocation_CreateInfo_AMD>
			{
				EType                            SType                  = STypeEnum                                ;
				const void*                            Next                   = nullptr                                  ;
				EMemoryOverallocationBehaviorAMD OverallocationBehavior = EMemoryOverallocationBehaviorAMD::Default;
			};

			/**
			* @brief Used to reserve private data storage slots.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDevicePrivateDataCreateInfoEXT">Specification</a>
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct PrivateDataCreateInfo : V0::VKStruct_Base<VkDevicePrivateDataCreateInfoEXT, EStructureType::Device_PrivateData_CreateInfo_EXT>
			{
				EType  SType                       = STypeEnum;
				const void*  Next                        = nullptr  ;
				uint32 PrivateDataSlotRequestCount;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceCreateInfo">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			*/
			struct CreateInfo : V0::VKStruct_Base<VkDeviceCreateInfo, EStructureType::Device_CreateInfo>
			{
				EType                     SType                 = STypeEnum;
				const void*                     Next                  = nullptr  ;
				CreateFlags               Flags                ;
				uint32                    QueueCreateInfoCount  = 0        ;
				const Queue::CreateInfo*        QueueCreateInfos      = nullptr  ;
				uint32                    EnabledLayerCount     = 0        ;
				RoArray_of_RoCStr         EnabledLayerNames     = nullptr  ;
				uint32                    EnabledExtensionCount = 0        ;
				RoArray_of_RoCStr         EnabledExtensionNames = nullptr  ;
				const PhysicalDevice::Features* EnabledFeatures       = nullptr  ;
			};

			/**
			* @brief A logical device is created as a connection to a physical device.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateDevice">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			* 
			* \param _physicalDevice
			* \param _createSpec
			* \param _allocator
			* \param _device
			* \return 
			*/
			static EResult Create
			(
				PhysicalDevice::Handle       _physicalDevice,
				const CreateInfo&                  _info          ,
				const Memory::AllocationCallbacks* _allocator     ,
				Handle&                      _device
			)
			{
				return EResult(vkCreateDevice(_physicalDevice, _info, *_allocator, &_device));
			}

			/**
			* @brief Destroy a logical device.
			* 
			* @details
			* To ensure that no work is active on the device, vkDeviceWaitIdle can be used to gate the destruction of the device. 
			* Prior to destroying a device, an application is responsible for destroying/freeing any Vulkan objects that were created 
			* using that device as the first parameter of the corresponding vkCreate* or vkAllocate* command.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyDevice">Specification</a> 
			* 
			* @ingroup APISpec_Devices_and_Queues
			* 
			* \param _handle
			* \param _allocator
			*/
			static void Destroy(Handle _device, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyDevice(_device, *_allocator);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDeviceWaitIdle">Specification</a> .
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \return 
			*/
			static EResult WaitUntilIdle(Handle _device)
			{
				return EResult(vkDeviceWaitIdle(_device));
			}

			template<typename ReturnType>
			/** 
			@brief Function pointers for all Vulkan commands directly addressed from the device.

			@details
			In order to support systems with multiple Vulkan implementations, the function pointers returned by vkGetInstanceProcAddr
			may point to dispatch code that calls a different real implementation for different VkDevice objects or their child objects.
			The overhead of the internal dispatch for VkDevice objects can be avoided by obtaining device-specific function pointers
			for any commands that use a device or device-child object as their dispatchable object.

			Note: ReturnType is restricted to only function pointing types.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetInstanceProcAddr">Specification</a>

			@ingroup APISpec_Initialization
			*/
			static typename std::enable_if
				<
				std::bool_constant
				< 
				std::is_pointer <                             ReturnType       >::value &&
				std::is_function<typename std::remove_pointer<ReturnType>::type>::value
				>::value,

				ReturnType>::type GetProcedureAddress(Handle& _appInstance, RoCStr _procedureName)
			{
				return reinterpret_cast<ReturnType>(vkGetDeviceProcAddr(_appInstance, _procedureName));
			}
		};

		/**
		@brief Typedef to expose queue outside of logical device. (To use similar to regular Vulkan API.
		*/
		using Queue = LogicalDevice::Queue;

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		* @brief Represent logical connections to physical devices. 
		* 
		* @details
		* 
		* @ingroup APISpec_Devices_and_Queues
		*/
		struct LogicalDevice : public V1::LogicalDevice
		{
			using Parent = V1::LogicalDevice;

			/**
			* @brief A logical device is created as a connection to a physical device. (Uses default allocator)
			* 
			* \param _physicalDevice
			* \param _createSpec
			* \param _allocator
			* \param _device
			* \return 
			*/
			static EResult Create
			(
				PhysicalDevice::Handle _physicalDevice,
				const CreateInfo&            _createSpec    ,
				Handle&                _device
			)
			{
				return Create(_physicalDevice, _createSpec, Memory::DefaultAllocator, _device);
			}

			using Parent::Create;

			/**
			* @brief Destroy a logical device. (Uses default allocator)
			* 
			* \param _handle
			* \param _allocator
			*/
			static void Destroy(Handle _device)
			{
				vkDestroyDevice(_device, *Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/**
		@brief Typedef to expose queue outside of logical device. (To use similar to regular Vulkan API.
		*/
		using Queue = LogicalDevice::Queue;

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@ingroup APISpec_Devices_and_Queues
		@brief Represent logical connections to physical devices. 
		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class LogicalDevice : public V2::LogicalDevice
		{
		public:
			using Parent = V2::LogicalDevice;

			/**
			@ingroup APISpec_Devices_and_Queues
			@brief Queues handle different types of batched commands for the GPU to complete.

			@details 
			Vulkan queues provide an interface to the execution engines of a device.
			Commands for these execution engines are recorded into command buffers ahead of execution time.
			These command buffers are then submitted to queues with a queue submission command for execution in a number of batches.
			Once submitted to a queue, these commands will begin and complete execution without further application intervention,
			though the order of this execution is dependent on a number of implicit and explicit ordering constraints.

			Note: This object only acts as a host interface to a given device object's handle. The logical device of the queue manages the device object lifetime.
			*/
			struct Queue : public Parent::Queue
			{
				using Parent = Parent::Queue;

				/**
				@brief Default constructor.
				*/
				Queue() { assignment = EQueueFlag::VT_SpecifyBitmaskable; }

				/**
				@brief Performs an assignment on construction.
				*/
				Queue(EQueueFlag _type, const LogicalDevice& _device, uint32 _familyIndex, uint32 _queueIndex) :
					assignment(_type), device(&_device), familyIndex(_familyIndex), queueIndex(_queueIndex)
				{}

				/**
				@brief Assigns the queue info.
				*/
				void Assign(const LogicalDevice& _logicalDevice, uint32 _familyIndex, uint32 _queueIndex, EQueueFlag _type)
				{
					device      = &_logicalDevice;
					familyIndex = _familyIndex   ;
					queueIndex  = _queueIndex    ;
					assignment  = _type          ;
				}

				/**
				@brief Provides the queue family index.
				*/
				uint32 GetFamilyIndex() const
				{
					return familyIndex;
				}

				/**
				@brief Provides the queue index in the queue family.
				*/
				uint32 GetQueueIndex() const
				{
					return queueIndex;
				}

				/**
				@brief Provides the queue type.
				*/
				const EQueueFlag& GetType() const
				{
					return assignment;
				}

				/**
				@brief Retrieve a handle to a VkQueue object.
				*/
				void Retrieve()
				{
					Parent::Get(*device, familyIndex, queueIndex, handle);
				}

				/**
				@brief Informs if family was specified.
				*/
				bool FamilySpecified() const
				{
					return assignment != EQueueFlag::VT_SpecifyBitmaskable ? true : false;
				}

				/**
				@brief After queuing all rendering commands and transitioning the image to the correct layout, to queue an image for presentation.
				*/
				EResult QueuePresentation(const PresentationInfo& _presentationInfo) const
				{
					return Parent::QueuePresentation(handle, _presentationInfo);
				}

				/**
				@brief Submit command buffers to a queue.
				*/
				EResult SubmitToQueue(uint32 _submitCount, const SubmitInfo* _submissions, Fence_Handle _fence) const
				{
					return Parent::SubmitToQueue(handle, _submitCount, _submissions, _fence);
				}

				/**
				@brief Wait on the host for the completion of outstanding queue operations for a given queue.
				*/
				EResult WaitUntilIdle() const
				{
					return Parent::WaitUntilIdle(handle);
				}

				/**
				@brief Implicit conversion to give a readonly reference to its handle.
				*/
				operator const Handle&() const
				{
					return handle;
				}

			protected:

				Handle handle;

				EQueueFlag assignment;

				const LogicalDevice* device;

				uint32 familyIndex;

				uint32 queueIndex;
			};

			/**
			@brief Default constructor.
			*/
			LogicalDevice() : handle(Null<Handle>), physicalDevice(nullptr), allocator(Memory::DefaultAllocator)
			{}

			/**
			@brief Constructor with physical device specified.
			*/
			LogicalDevice(const PhysicalDevice& _physicalDevice) : handle(Null<Handle>), physicalDevice(&_physicalDevice), allocator(Memory::DefaultAllocator)
			{}

			/**
			@brief Constructor with physical device and allocator specified.
			*/
			LogicalDevice(const PhysicalDevice& _physicalDevice, const Memory::AllocationCallbacks& _allocator) : 
				handle(Null<Handle>), physicalDevice(&_physicalDevice), allocator(&_allocator) 
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			LogicalDevice(LogicalDevice&& _other) noexcept :
				handle(std::move(_other.handle)), physicalDevice(std::move(_other.physicalDevice)), allocator(std::move(_other.allocator))
			{
				_other.handle         = Null<Handle>;
				_other.physicalDevice = nullptr     ;
				_other.allocator      = nullptr     ;
			}

			/**
			@brief Destructor for logical device. (Will destroy the device object if handle is not null)
			*/
			~LogicalDevice()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/** 
			@brief Assigns a physical device.
			*/
			void AssignPhysicalDevice(const PhysicalDevice& _physicalDevice) 
			{
				physicalDevice = &_physicalDevice;
			}

			/**
			@brief Create logical device.
			*/
			EResult Create(const CreateInfo& _createInfo)
			{
				if (physicalDevice == nullptr) return EResult::Not_Ready;

				return Parent::Create(*physicalDevice, _createInfo, handle);
			}

			/**
			@brief Create a logical device (allocator specified).
			*/
			EResult Create(const CreateInfo& _createInfo, const Memory::AllocationCallbacks& _allocator)
			{
				if (physicalDevice == nullptr) return EResult::Not_Ready;

				allocator = &_allocator;

				return Parent::Create(*physicalDevice, _createInfo, allocator, handle);
			}

			/**
			@brief Create a logical device (physical device specified).
			*/
			EResult Create(const PhysicalDevice& _physicalDevice, const CreateInfo& _createInfo)
			{
				physicalDevice = &_physicalDevice        ;
				allocator      = Memory::DefaultAllocator;

				return Parent::Create(*physicalDevice, _createInfo, handle);
			}

			/**
			@brief Create a logical device (physical device and allocator specified).
			*/
			EResult Create(const PhysicalDevice& _physicalDevice, const CreateInfo& _createInfo, const Memory::AllocationCallbacks& _allocator)
			{
				physicalDevice = &_physicalDevice;
				allocator      = &_allocator     ;

				return Parent::Create(*physicalDevice, _createInfo, allocator, handle);
			}

			/**
			@brief Destroy a logical device.
			*/
			void Destroy()
			{
				Parent::Destroy(handle, allocator);

				handle    = Null<Handle>;
				allocator = nullptr     ;
			}

			/**
			@brief provides a readonly reference to a physical device host object.
			*/
			const PhysicalDevice& GetPhysicalDevice() const
			{
				return *physicalDevice;
			}

			/**
			@brief Wait on the host for the completion of outstanding queue operations for all queues on a given logical device.
			*/
			EResult WaitUntilIdle() const
			{
				return Parent::WaitUntilIdle(handle);
			}

			template<typename ReturnType>
			/**
			@brief In order to support systems with multiple Vulkan implementations, the function pointers returned by vkGetInstanceProcAddr 
			may point to dispatch code that calls a different real implementation for different VkDevice objects or their child objects. 
			The overhead of the internal dispatch for VkDevice objects can be avoided by obtaining device-specific function pointers for 
			any commands that use a device or device-child object as their dispatchable object. 
			*/
			typename std::enable_if
				<
				std::bool_constant
				< 
				std::is_pointer <                             ReturnType       >::value &&
				std::is_function<typename std::remove_pointer<ReturnType>::type>::value
				>::value,
				ReturnType>::type GetProcedureAddress(RoCStr _procedurename) const
			{
				return Parent::GetProcedureAddress<ReturnType>(handle, _procedurename);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const LogicalDevice& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			LogicalDevice& operator= (LogicalDevice&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle         = std::move(_other.handle        );
				physicalDevice = std::move(_other.physicalDevice);
				allocator      = std::move(_other.allocator     );

				_other.handle         = Null<Handle>;
				_other.physicalDevice = nullptr     ;
				_other.allocator      = nullptr     ;

				return *this;
			}

		protected:

			Handle handle;

			const PhysicalDevice* physicalDevice;

			const Memory::AllocationCallbacks* allocator;
		};

		/**
		@brief Typedef to expose queue outside of logical device. (To use similar to regular Vulkan API.
		*/
		using Queue = LogicalDevice::Queue;

		/** @} */
	}
}




/*!
@file VT_Memory.hpp

@brief Vaulted Thermals: Memory

@details Contains the full definition of the intended memory structure.

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory">Specification</a>
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@brief General memory structures and functionality for device memory.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory">Specification</a> 

		@ingroup APISpec_Memory_Allocation
		*/
		struct Memory : public V0::Memory
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceMemory">Specification</a>  */
			using Handle = VkDeviceMemory;

			/**
			@brief Used to specify no offset when mapping memory.
			*/
			static constexpr DeviceSize ZeroOffset = 0;

			/**
			* @brief Allocate memory objects.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkAllocateMemory">Specification</a>
			* 
			* @ingroup APISpec_Memory_Allocation
			* 
			* \param _device
			* \param _allocateInfo
			* \param _allocator
			* \param _memory
			* \return 
			*/
			static EResult Allocate
			(
				LogicalDevice::Handle _device      ,
				const AllocateInfo&         _allocateInfo,
				const AllocationCallbacks*  _allocator   ,
				Handle&               _memory
			)
			{
				return EResult(vkAllocateMemory(_device, _allocateInfo, *_allocator, &_memory) );
			}

			/**
			* @brief Free a memory object.
			*
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkFreeMemory">Specification</a>
			* 
			* @ingroup APISpec_Memory_Allocation
			* 
			* \param _device
			* \param _memory
			* \param _allocator
			* \return 
			*/
			static void Free(LogicalDevice::Handle _device, Handle _memory, const AllocationCallbacks* _allocator)
			{
				vkFreeMemory(_device, _memory, *_allocator);
			}

			/** 
			* @brief Retrieve a host virtual address pointer to a region of a mappable memory object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkMapMemory">Specification</a>
			* 
			* @ingroup APISpec_Memory_Allocation
			* 
			* \param _device
			* \param _memory
			* \param _offset
			* \param _size
			* \param _flags
			* \param _data
			* \return 
			*/
			static EResult Map
			(
				LogicalDevice::Handle _device,
				Handle                _memory,
				DeviceSize            _offset,
				DeviceSize            _size  ,
				MapFlags              _flags ,
				VoidPtr&              _data
			)
			{
				return EResult(vkMapMemory(_device, _memory, _offset, _size, _flags, &_data));
			}

			/**
			* @brief Unmap a memory object once host access to it is no longer needed by the application.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkUnmapMemory">Specification</a> 
			* 
			* @ingroup APISpec_Memory_Allocation
			* 
			* \param _device
			* \param _memory
			*/
			static void Unmap(LogicalDevice::Handle _device, Handle _memory)
			{
				vkUnmapMemory(_device, _memory);
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief General memory structures and functionality for device memory.

		@ingroup APISpec_Memory_Allocation
		*/
		struct Memory : public V1::Memory
		{
			using Parent = V1::Memory;

			/**
			* @brief Allocate memory objects using the default allocator.
			* 
			* \param _device
			* \param _allocateInfo
			* \param _allocator
			* \param _memory
			* \return 
			*/
			static EResult Allocate(LogicalDevice::Handle _device, const AllocateInfo& _allocateInfo, Handle& _memory)
			{
				return EResult(vkAllocateMemory(_device, _allocateInfo, *Memory::DefaultAllocator, &_memory) );
			}

			using Parent::Allocate;

			/**
			* @brief Free a memory object allocated using the default allocator.
			* 
			* \param _device
			* \param _memory
			* \param _allocator
			* \return 
			*/
			static void Free(LogicalDevice::Handle _device, Handle _memory)
			{
				vkFreeMemory(_device, _memory, *Memory::DefaultAllocator);
			}

			using Parent::Free;

			/**
			* @brief Writes to GPU memory by mapping to device memory specified by a 
			* handle and then using memcpy to copy data specified in _data.
			* 
			* \param _device
			* \param _memory
			* \param _offset
			* \param _size
			* \param _flags
			* \param _data
			*/
			static void WriteToGPU
			(
				LogicalDevice::Handle _device,
				Handle                _memory,
				DeviceSize            _offset,
				DeviceSize            _size  ,
				MapFlags              _flags ,
				const VoidPtr&              _data
			)
			{
				VoidPtr gpuAddressing;

				Map(_device, _memory, _offset, _size, _flags, gpuAddressing);   ///< @todo Add exception handling for this / return code...

				memcpy(gpuAddressing, _data, _size);

				Unmap(_device, _memory);
			}
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@ingroup APISpec_Memory_Allocation
		@brief General memory structures and functionality for device memory.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Memory : public V2::Memory
		{
		public:

			using Parent = V2::Memory;

			/**
			@brief Default constructor.
			*/
			Memory() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Constructor with logical device specified.
			*/
			Memory(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Constructor with logical device and allocator specified.
			*/
			Memory(const LogicalDevice& _device, const Memory::AllocationCallbacks _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Memory(Memory&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;	
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destructor will destroy the device object if handle is not null.
			*/
			~Memory()
			{
				if (handle != Null<Handle>) Free();
			}

			/**
			@brief Allocate memory objects.
			*/
			EResult Allocate(const AllocateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Allocate(*device, _info, handle);
			}

			/**
			@brief Allocate memory objects. (Device specified)
			*/
			EResult Allocate(const LogicalDevice& _device, const AllocateInfo& _allocateInfo)
			{
				device = &_device;

				return Parent::Allocate(*device, _allocateInfo, handle);
			}

			/**
			@brief Allocate memory objects. (Device and allocator specified)
			*/
			EResult Allocate(const LogicalDevice& _device, const AllocateInfo& _allocateInfo, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Allocate(*device, _allocateInfo, allocator, handle);
			}

			/**
			@brief Free a memory object.
			*/
			void Free() 
			{
				Parent::Free(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Retrieve a host virtual address pointer to a region of a mappable memory object.
			*/
			EResult Map(DeviceSize _offset, DeviceSize _size, MapFlags _flags, VoidPtr& _data) const
			{
				return Parent::Map(*device, handle, _offset, _size, _flags, _data);
			}

			/**
			@brief Unmap a memory object once host access to it is no longer needed by the application.
			*/
			void Unmap() const
			{
				Parent::Unmap(*device, handle);
			}

			/**
			@brief Writes to GPU memory by mapping to device memory specified by a
			handle and then using memcpy to copy data specified in _data.
			*/
			void WriteToGPU(DeviceSize _offset, DeviceSize _size, MapFlags _flags, VoidPtr& _data) const
			{
				Parent::WriteToGPU(*device, handle, _offset, _size, _flags, _data);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Memory& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Memory& operator= (Memory&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}




/*!
@file VT_Sampler.hpp

@brief Vaulted Thermals: Sampler

@details
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		* @brief Represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSampler">Specification</a> 
		* @ingroup APISpec_Samplers
		*/
		struct Sampler
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSampler">Specification</a> @ingroup APISpec_Samplers */
			using Handle = VkSampler;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSamplerCreateFlags">Specification</a> @ingroup APISpec_Samplers */
			using CreateFlags = Bitmask<ESamplerCreateFlag, VkSamplerCreateFlags>;

			using EMipmapMode = ESamplerMipmapMode ; 
			using AddressMode = ESamplerAddressMode;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSamplerCreateInfo">Specification</a> @ingroup APISpec_Samplers */
			struct CreateInfo : V0::VKStruct_Base<VkSamplerCreateInfo, EStructureType::Sampler_CreateInfo>
			{
				EType             SType                   = STypeEnum;
				const void*             Next                    = nullptr  ;
				CreateFlags       Flags                  ;
				EFilter           MagnificationFilter    ;
				EFilter           MinimumFilter          ;
				EMipmapMode       MipmapMode             ;
				AddressMode       AddressModeU           ;
				AddressMode       AddressModeV           ;
				AddressMode       AddressModeW           ;
				float32           MipLodBias             ;
				Bool              AnisotropyEnable       ;
				float32           MaxAnisotropy          ;
				Bool              CompareEnable          ;
				ECompareOperation CompareOperation       ;
				float32           MinimumLod             ;
				float32           MaxLod                 ;
				EBorderColor      BorderColor            ;
				Bool              UnnormalizedCoordinates;
			};

			/**
			* @brief Create a sampler object.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateSampler">Specification</a> 
			* 
			* @ingroup APISpec_Samplers
			* 
			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _sampler
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _device    ,
				const CreateInfo&                  _createInfo,
				const Memory::AllocationCallbacks* _allocator ,
				Handle&                      _sampler
			)
			{
				return EResult(vkCreateSampler(_device, _createInfo, _allocator->operator const VkAllocationCallbacks*(), &_sampler));
			}

			/**
			* @brief Destroy a sampler.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroySampler">Specification</a> 
			* 
			* @ingroup APISpec_Samplers
			* 
			* \param _device
			* \param _sampler
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _device   ,
				Handle                       _sampler  ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroySampler(_device, _sampler, _allocator->operator const VkAllocationCallbacks*());
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief Represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.
		*/
		struct Sampler : public V1::Sampler
		{
			using Parent = V1::Sampler;

			/**
			* @brief Create a sampler object (Default Allocator).

			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _sampler
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle _device    ,
				const CreateInfo&           _createInfo,
				Handle&               _sampler
			)
			{
				return Parent::Create(_device, _createInfo, Memory::DefaultAllocator, _sampler);
			}

			using Parent::Create;

			/**
			* @brief Destroy a sampler (Default Allocator).
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroySampler">Specification</a> 
			* 
			* \param _device
			* \param _sampler
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _device , Handle _sampler)
			{
				Parent::Destroy(_device, _sampler, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief Represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Sampler : public V2::Sampler
		{
		public:

			using Parent = V2::Sampler;

			/**
			@brief Default constructor.
			*/
			Sampler() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			Sampler(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Sampler(const LogicalDevice& _device, const Memory::AllocationCallbacks _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Sampler(Sampler&& _other) noexcept :
				handle(_other.handle), allocator(_other.allocator), device(_other.device)
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the sampler.
			*/
			~Sampler()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create the sampler.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create the sampler (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create the sampler (logical device and allocator) specified.
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy the sampler.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Sampler& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Sampler& operator= (Sampler&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}



/*!
@file VT_Resource.hpp

@brief Vaulted Thermals: Resources

@details
Vulkan supports two primary resource types: buffers and images. 
Resources are views of memory with associated formatting and dimensionality. 
Buffers are essentially unformatted arrays of bytes whereas images contain format information, 
can be multidimensional and may have associated metadata.

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		*/

		/**
		* @brief A linear array of data.
		* 
		* @details
		* Buffers represent linear arrays of data which are used for various purposes by binding them
		* to a graphics or compute pipeline via descriptor sets or via certain commands, or by
		* directly specifying them as parameters to certain commands.
		* 
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-buffers">Specification</a> 
		* 
		* @ingroup	APISpec_Resource_Creation
		*/
		struct Buffer
		{
			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBuffer">Specification</a>  
			@ingroup APISpec_Resource_Creation
			*/
			using Handle = VkBuffer;

			using ECreateFlag = EBufferCreateFlag;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferCreateFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using CreateFlags = Bitmask<EBufferCreateFlag, VkBufferCreateFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferUsageFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using UsageFlags = Bitmask<EBufferUsage, VkBufferUsageFlags>;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferCreateInfo">Specification</a>
			* @ingroup APISpec_Resource_Creation
			*/
			struct CreateInfo : V0::VKStruct_Base<VkBufferCreateInfo, EStructureType::Buffer_CreateInfo>
			{
				EType        SType                 = STypeEnum;
				const void*        Next                  = nullptr  ;
				CreateFlags  Flags                ;
				DeviceSize   Size                 ;
				UsageFlags   Usage                ;
				ESharingMode SharingMode          ;
				uint32       QueueFamilyIndexCount;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferCopy">Specification</a> @ingroup APISpec_Copy_Commands */
			struct CopyInfo : V0::VKStruct_Base<VkBufferCopy>
			{
				DeviceSize SourceOffset     ;
				DeviceSize DestinationOffset;
				DeviceSize Size             ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferMemoryBarrier">Specification</a>
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct Memory_Barrier : V0::VKStruct_Base<VkBufferMemoryBarrier, EStructureType::BufferMemory_Barrier>
			{
				EType       SType               = STypeEnum;
				const void*       Next                = nullptr  ;
				AccessFlags SrcAccessMask      ;
				AccessFlags DstAccessMask      ;
				uint32      SrcQueueFamilyIndex;
				uint32      DstQueueFamilyIndex;
				Handle      Buffer             ;
				DeviceSize  Offset             ;
				DeviceSize  Size               ;
			};

			/**
			* @brief Attach memory to a buffer object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkBindBufferMemory">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _device
			* \param _buffer
			* \param _memory
			* \param _memoryOffset
			* \return 
			*/
			static EResult BindMemory
			(
				LogicalDevice::Handle _device      ,
				Handle                _buffer      ,
				Memory::Handle        _memory      ,
				DeviceSize            _memoryOffset
			)
			{
				return EResult(vkBindBufferMemory(_device, _buffer, _memory, _memoryOffset));
			}

			/**
			* @brief Create a new buffer object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateBuffer">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _buffer
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _device, const CreateInfo& _createInfo, const Memory::AllocationCallbacks* _allocator, Handle& _buffer)
			{
				return EResult(vkCreateBuffer(_device, _createInfo.operator const VkBufferCreateInfo*(), _allocator->operator const VkAllocationCallbacks*(), &_buffer));
			}



			/**
			* @brief Destroy a buffer object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyBuffer">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _buffer
			* \param _allocator
			* \return 
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _buffer, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyBuffer(_device, _buffer, _allocator->operator const VkAllocationCallbacks*());
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetBufferMemoryRequirements">Specification</a>
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _device
			* \param _buffer
			* \param _memoryRequirements
			*/
			static void GetMemoryRequirements
			(
				LogicalDevice::Handle _device             ,
				Handle                _buffer             ,
				Memory::Requirements& _memoryRequirements
			)
			{
				vkGetBufferMemoryRequirements(_device, _buffer, _memoryRequirements);
			}
		};

		/**
		* @brief A buffer view represents a contiguous range of a buffer and a specific format to be used to interpret the data.
		* 
		* @details
		* Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. 
		* In order to create a valid buffer view, the buffer must have been created with at least one of 
		* the following usage flags: UnformTexelBuffer or StorageTexelBuffer
		* 
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-buffer-views">Specification</a> 
		* 
		* @ingroup APISpec_Resource_Creation
		*/
		struct BufferView
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferView">Specification</a> @ingroup APISpec_Resource_Creation */
			using Handle = VkBufferView;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferViewCreateFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using CreateFlags = Bitmask<EUndefined, VkBufferViewCreateFlags>;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferViewCreateInfo.html">Specification</a> 
			* @ingroup APISpec_Resource_Creation
			*/
			struct CreateInfo : V0::VKStruct_Base<VkBufferViewCreateInfo, EStructureType::BufferView_CreateInfo>
			{
				EType          SType   = STypeEnum;
				const void*          Next    = nullptr  ;
				CreateFlags    Flags  ;
				Buffer::Handle VBuffer;
				EFormat        Format ;
				DeviceSize     Offset ;
				DeviceSize     Range  ;
			};

			/**
			* @brief Create a new buffer view object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateBufferView">Specification</a>.
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _bufferView
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _device, const CreateInfo& _info, const Memory::AllocationCallbacks* _allocator, Handle& _bufferView)
			{
				return EResult(vkCreateBufferView(_device, _info.operator const VkBufferViewCreateInfo*(), _allocator->operator const VkAllocationCallbacks*(), &_bufferView));
			}

			/**
			* @brief Destroy a buffer view object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkDestroyBufferView.html">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _bufferView
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _bufferView, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyBufferView(_device, _bufferView, _allocator->operator const VkAllocationCallbacks*());
			}
		};

		/** 
		@brief
		Images represent multidimensional - up to 3 - arrays of data which can be used for various purposes 
		(e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, 
		or by directly specifying them as parameters to certain commands.

		@details
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-images">Specification</a> 

		@ingroup APISpec_Resource_Creation
		*/
		struct Image
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImage">Specification</a> @ingroup APISpec_Resource_Creation */
			using Handle = VkImage;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageAspectFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using AspectFlags = Bitmask<EImageAspect, VkImageAspectFlags>;

			using ECreateFlag = EImageCreateFlag;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageCreateFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using CreateFlags = Bitmask<EImageCreateFlag, VkImageCreateFlags>;

			using ETiling = EImageTiling;

			using EUsage = EImageUsage;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageUsageFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using UsageFlags = Bitmask<EImageUsage, VkImageUsageFlags>;   ///< Bitmask specifying intended usage of an image.

																		  /** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageCreateInfo">Specification</a> @ingroup APISpec_Resource_Creation */
			struct CreateInfo : V0::VKStruct_Base<VkImageCreateInfo, EStructureType::Image_CreateInfo>
			{
				EType        SType                 = STypeEnum              ;
				const void*        Next                  = nullptr                ;
				CreateFlags  Flags                ;
				EImageType   ImageType             = EImageType::_2D        ;
				EFormat      Format               ;
				Extent3D     Extent               ;
				uint32       MipmapLevels          = 0                      ;
				uint32       ArrayLayers          ;
				ESampleCount Samples               = ESampleCount::_1       ;
				ETiling      Tiling                = EImageTiling::Optimal  ;
				UsageFlags   Usage                ;
				ESharingMode SharingMode           = ESharingMode::Exclusive;
				uint32       QueueFamilyIndexCount = 0                      ;
				const uint32*      QueueFamilyIndices    = nullptr                ;
				EImageLayout InitalLayout          = EImageLayout::Undefined;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageSubresourceLayers">Specification</a>  
			@ingroup APISpec_Copy_Commands
			*/
			struct SubresourceLayers : V0::VKStruct_Base<VkImageSubresourceLayers>
			{
				AspectFlags AspectMask    ;
				uint32      MipLevel      ;
				uint32      BaseArrayLayer;
				uint32      LayerCount    ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageSubresourceRange">Specification</a>  
			@ingroup APISpec_Resource_Creation
			*/
			struct SubresourceRange : V0::VKStruct_Base<VkImageSubresourceRange>
			{
				AspectFlags AspectMask    ;
				uint32      BaseMipLevel  ;
				uint32      LevelCount    ;
				uint32      BaseArrayLayer;
				uint32      LayerCount    ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageMemoryBarrier">Specification</a>  
			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct Memory_Barrier : V0::VKStruct_Base<VkImageMemoryBarrier, EStructureType::ImageMemory_Barrier>
			{
				EType            SType               = STypeEnum;
				const void*            Next                = nullptr  ;
				AccessFlags      SrcAccessMask      ;
				AccessFlags      DstAccessMask      ;
				EImageLayout     OldLayout          ;
				EImageLayout     NewLayout          ;
				uint32           SrcQueueFamilyIndex;
				uint32           DstQueueFamilyIndex;
				Handle           Image              ;
				SubresourceRange SubresourceRange   ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageBlit">Specification</a>  
			@ingroup APISpec_Copy_Commands
			*/
			struct Blit : V0::VKStruct_Base<VkImageBlit>
			{
				SubresourceLayers SrcSubresource;
				Offset3D          SrcOffsets[2] ;
				SubresourceLayers DstSubresource;
				Offset3D          DstOffsets[2] ;
			};

			/**
			* @brief Attach memory to a VkImage object created without the VK_IMAGE_CREATE_DISJOINT_BIT set.
			*
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkBindImageMemory">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _device
			* \param _image
			* \param _memory
			* \param _memoryOffset
			* \return 
			*/
			static EResult BindMemory
			(
				LogicalDevice::Handle _device      ,
				Handle                _image       ,
				Memory::Handle        _memory      ,
				DeviceSize            _memoryOffset
			)
			{
				return EResult(vkBindImageMemory(_device, _image, _memory, _memoryOffset));
			}

			/**  
			* @brief  Create an image object.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateImage">Specification</a>.
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _imageHandle
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _deviceHandle, const CreateInfo& _createInfo, const Memory::AllocationCallbacks* _allocator, Handle& _imageHandle)
			{
				return EResult(vkCreateImage(_deviceHandle, _createInfo, *_allocator, &_imageHandle));
			}

			/** 
			* @brief Destroy an image object.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyImage">Specification</a>.
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _image
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _image, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyImage(_deviceHandle, _image, *_allocator);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetImageMemoryRequirements">Specification</a> 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _device
			* \param _image
			* \param _memoryRequirements
			*/
			static void GetMemoryRequirements(LogicalDevice::Handle _device, Handle _image, Memory::Requirements& _memoryRequirements)
			{
				vkGetImageMemoryRequirements(_device, _image, _memoryRequirements);
			}
		};

		/**
		* @brief An object that represents an image subresource range of a specific image, 
		* and state that controls how the contents are interpreted.
		* 
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-views">Specification</a> 
		* 
		* @ingroup APISpec_Resource_Creation
		*/
		struct ImageView
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageView">Specification</a> @ingroup APISpec_Resource_Creation */
			using Handle = VkImageView;

			using EViewType = EImageViewType;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageViewCreateFlags">Specification</a> @ingroup APISpec_Resource_Creation */
			using CreateFlags = Bitmask<EImageViewCreateFlag, VkImageViewCreateFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImageViewCreateInfo">Specification</a> @ingroup APISpec_Resource_Creation */
			struct CreateInfo : V0::VKStruct_Base<VkImageViewCreateInfo, EStructureType::ImageView_CreateInfo>
			{
				EType                   SType            = STypeEnum;			
				const void*                   Next             = nullptr  ;
				CreateFlags             Flags           ;
				Image::Handle           Image           ;
				EViewType               ViewType        ;
				EFormat                 Format          ;
				ComponentMapping        Components      ;
				Image::SubresourceRange SubresourceRange;
			};


			/**
			* @brief Create an image view object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateImageView">Specification</a>
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _imageView
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _creationSpec,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _imageView
			)
			{
				return EResult(vkCreateImageView(_deviceHandle, _creationSpec, _allocator->operator const VkAllocationCallbacks*(), &_imageView));
			}

			/**
			* @brief Destroy an image view.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyImageView">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Creation
			* 
			* \param _deviceHandle
			* \param _imageView
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle _deviceHandle,
				Handle                _imageView   ,
				const Memory::AllocationCallbacks*  _allocator
			)
			{
				vkDestroyImageView(_deviceHandle, _imageView, _allocator->operator const VkAllocationCallbacks*());
			}
		};

		/**
		* @brief Descriptors are grouped together into descriptor set objects. A descriptor set object is an opaque object containing storage for a set of descriptors,
		* where the types and number of descriptors is defined by a descriptor set layout.
		* 
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#descriptorsets-sets">Specification</a>
		* 
		* @ingroup APISpec_Resource_Descriptors
		*/
		struct DescriptorSet
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSet">Specification</a> @ingroup APISpec_Resource_Descriptors */
			using Handle = VkDescriptorSet;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorBufferInfo">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct BufferInfo : V0::VKStruct_Base<VkDescriptorBufferInfo>
			{
				Buffer::Handle Buffer;
				DeviceSize     Offset;
				DeviceSize     Range ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCopyDescriptorSet">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct Copy : V0::VKStruct_Base<VkCopyDescriptorSet>
			{
				EType  SType           = STypeEnum;
				const void*  Next            = nullptr  ;
				Handle SrcSet         ;
				uint32 SrcBinding     ;
				uint32 SrcArrayElement;
				Handle DstSet         ;
				uint32 DstBinding     ;
				uint32 DstArrayElement;
				uint32 DescriptorCount;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorImageInfo">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct ImageInfo : V0::VKStruct_Base<VkDescriptorImageInfo>
			{
				Sampler::Handle   Sampler    ;
				ImageView::Handle ImageView  ;
				EImageLayout      ImageLayout;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkWriteDescriptorSet">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct Write : V0::VKStruct_Base<VkWriteDescriptorSet, EStructureType::WriteDescriptor_Set>
			{
				EType               SType           = STypeEnum;
				const void*               Next            = nullptr  ;
				Handle              DstSet         ;
				uint32              DstBinding     ;
				uint32              DstArrayElement;
				uint32              DescriptorCount;
				EDescriptorType     DescriptorType ;
				const ImageInfo*          ImageInfo       = nullptr  ;
				const BufferInfo*         BufferInfo      = nullptr  ;
				const BufferView::Handle* TexelBufferView = nullptr  ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkUpdateDescriptorSets">Specification</a>.
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _descriptorWriteCount
			* \param _descriptorWrites
			* \param _descriptorCopyCount
			* \param _descriptorCopies
			*/
			static void Update
			(
				LogicalDevice::Handle _device              ,
				uint32                _descriptorWriteCount,
				const Write*                _descriptorWrites    ,
				uint32                _descriptorCopyCount ,
				const Copy*                 _descriptorCopies
			)
			{
				vkUpdateDescriptorSets(_device, _descriptorWriteCount, _descriptorWrites->operator const VkWriteDescriptorSet*(), _descriptorCopyCount, _descriptorCopies->operator const VkCopyDescriptorSet*());
			}
		};	

		/**
		@brief A descriptor pool maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, 
		meaning that the application must not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#descriptorsets-allocation">Specification</a> 

		@ingroup APISpec_Resource_Descriptors
		*/
		struct DescriptorPool
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPool">Specification</a> @ingroup APISpec_Resource_Descriptors */
			using Handle = VkDescriptorPool;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPoolCreateFlags">Specification</a> @ingroup APISpec_Resource_Descriptors */
			using CreateFlags = Bitmask<EDescriptorPoolCreateFlag, VkDescriptorPoolCreateFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPoolResetFlags">Specification</a> @ingroup APISpec_Resource_Descriptors */
			using ResetFlags = Bitmask<EUndefined, VkDescriptorPoolResetFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetAllocateInfo">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct AllocateInfo : V0::VKStruct_Base<VkDescriptorSetAllocateInfo, EStructureType::Descriptor_SetAllocateInfo>
			{
				using PipelineLayoutDescriptorSetHandle = VkDescriptorSetLayout;   // Pipeline definitions not defined yet.

				EType                              SType              = STypeEnum;
				const void*                              Next               = nullptr  ;
				Handle                             DescriptorPool    ;
				uint32                             DescriptorSetCount;
				const PipelineLayoutDescriptorSetHandle* SetLayouts        ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPoolSize">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct Size : V0::VKStruct_Base<VkDescriptorPoolSize>
			{
				EDescriptorType Type ;
				uint32          Count;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorPoolCreateInfo">Specification</a> @ingroup APISpec_Resource_Descriptors */
			struct CreateInfo : V0::VKStruct_Base<VkDescriptorPoolCreateInfo, EStructureType::Descriptor_Pool_CreateInfo>
			{
				EType       SType         = STypeEnum;
				const void*       Next          = nullptr  ;
				CreateFlags Flags        ;
				uint32      MaxSets      ;
				uint32      PoolSizeCount = 0        ;
				const Size*       PoolSizes     = nullptr  ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkAllocateDescriptorSets">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _allocateInfo
			* \param _descriptorSets
			* \return 
			*/
			static EResult Allocate
			(
				LogicalDevice::Handle  _device        ,
				const AllocateInfo&          _allocateInfo  ,
				DescriptorSet::Handle* _descriptorSets
			)
			{
				return EResult(vkAllocateDescriptorSets(_device, _allocateInfo, _descriptorSets));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateDescriptorPool">Specification</a>
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _descriptorPool
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle         _device        ,
				const CreateInfo&                   _createInfo    ,
				const Memory::AllocationCallbacks*  _allocator     ,
				Handle&                       _descriptorPool
			)
			{
				return EResult(vkCreateDescriptorPool(_device, _createInfo, _allocator->operator const VkAllocationCallbacks*(), &_descriptorPool));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyDescriptorPool">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _descriptorPool
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _device,
				Handle                       _descriptorPool,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroyDescriptorPool(_device, _descriptorPool, _allocator->operator const VkAllocationCallbacks*());
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkFreeDescriptorSets">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _descriptorPool
			* \param _descriptorSetCount
			* \param _descriptorSets
			* \return 
			*/
			static EResult Free
			(
				LogicalDevice::Handle  _device            ,
				Handle                 _descriptorPool    ,
				uint32                 _descriptorSetCount,
				const DescriptorSet::Handle* _descriptorSets
			)
			{
				return EResult(vkFreeDescriptorSets(_device, _descriptorPool, _descriptorSetCount, _descriptorSets));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkResetDescriptorPool">Specification</a> 
			* 
			* @ingroup APISpec_Resource_Descriptors
			* 
			* \param _device
			* \param _descriptorPool
			* \param _flags
			* \return 
			*/
			static EResult Reset
			(
				LogicalDevice::Handle _device        ,
				Handle                _descriptorPool,
				ResetFlags&           _flags
			)
			{
				return EResult(vkResetDescriptorPool(_device, _descriptorPool, _flags));
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief A linear array of data.
		*/
		struct Buffer : V1::Buffer
		{
			using Parent = V1::Buffer;

			/**
			@brief Offers alternative constructor.
			*/
			struct CreateInfo : public Parent::CreateInfo
			{
				using Parent = Parent::CreateInfo;

				CreateInfo() : Parent()
				{}

				CreateInfo(UsageFlags _usage, ESharingMode _sharingMode)
				{
					SType                 = STypeEnum   ;
					Next                  = nullptr     ;
					Size                  = 0           ;
					Usage                 = _usage      ;
					SharingMode           = _sharingMode;
					QueueFamilyIndexCount = 0           ;
				}
			};

			/**
			* @brief Create a new buffer object. (Default allocator)
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _buffer
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _device, const CreateInfo& _createInfo, Handle& _buffer)
			{
				return Parent::Create(_device, _createInfo, Memory::DefaultAllocator, _buffer);
			}

			using Parent::Create;

			/**
			* @brief Destroy a buffer object. (Default allocator)

			* \param _deviceHandle
			* \param _buffer
			* \param _allocator
			* \return 
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _buffer)
			{
				Parent::Destroy(_device, _buffer, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			* @brief Will create a buffer and immediately bind it to allocated memory made just for it.
			* 
			* \param _bufferInfo
			* \param _propertyFlags
			* \param _buffer
			* \param _bufferMemory
			* \param _bufferMemoryOffset
			* \param _physicalDevice
			* \param _device
			* \param _allcator
			* \return 
			*/
			static EResult CreateAndBind
			(
				PhysicalDevice::Handle _physicalDevice,
				LogicalDevice::Handle  _device        ,
				CreateInfo             _bufferInfo    ,
				Handle&                _buffer        , 
				Memory::PropertyFlags  _propertyFlags , 
				Memory::Handle&        _bufferMemory      
			)
			{
				EResult returnCode = Buffer::Create(_device, _bufferInfo, Memory::DefaultAllocator, _buffer);

				if (returnCode != EResult::Success)
					return returnCode;

				Memory::Requirements memReq;

				Buffer::GetMemoryRequirements(_device, _buffer, memReq);

				Memory::AllocateInfo allocationInfo{};

				allocationInfo.AllocationSize  = memReq.Size;
				allocationInfo.MemoryTypeIndex = PhysicalDevice::FindMemoryType(_physicalDevice, memReq.MemoryTypeBits, _propertyFlags);

				returnCode = Memory::Allocate(_device, allocationInfo, Memory::DefaultAllocator, _bufferMemory);

				if (returnCode != EResult::Success)
					return returnCode;

				Buffer::BindMemory(_device, _buffer, _bufferMemory, Memory::ZeroOffset);

				return returnCode;
			}

			/**
			* @brief Will create a buffer and immediately bind it to allocated memory made just for it.
			* 
			* \param _bufferInfo
			* \param _propertyFlags
			* \param _buffer
			* \param _bufferMemory
			* \param _bufferMemoryOffset
			* \param _physicalDevice
			* \param _device
			* \param _allcator
			* \return 
			*/
			static EResult CreateAndBind
			(
				PhysicalDevice::Handle       _physicalDevice,
				LogicalDevice::Handle        _device        ,
				CreateInfo                   _bufferInfo    ,
				Handle&                      _buffer        , 
				Memory::PropertyFlags        _propertyFlags , 
				Memory::Handle&              _bufferMemory  ,
				Memory::AllocationCallbacks* _allcator
			)
			{
				EResult returnCode = Buffer::Create(_device, _bufferInfo, _allcator, _buffer);

				if (returnCode != EResult::Success) return returnCode;

				Memory::Requirements memReq;

				Buffer::GetMemoryRequirements(_device, _buffer, memReq);

				Memory::AllocateInfo allocationInfo{};

				allocationInfo.AllocationSize  = memReq.Size;
				allocationInfo.MemoryTypeIndex = PhysicalDevice::FindMemoryType(_physicalDevice, memReq.MemoryTypeBits, _propertyFlags);

				returnCode = Memory::Allocate(_device, allocationInfo, _allcator, _bufferMemory);

				if (returnCode != EResult::Success) return returnCode;

				Buffer::BindMemory(_device, _buffer, _bufferMemory, Memory::ZeroOffset);

				return returnCode;
			}
		};

		/**
		@brief A buffer view represents a contiguous range of a buffer and a specific format to be used to interpret the data.
		*/
		struct BufferView : public V1::BufferView
		{
			using Parent = V1::BufferView;

			/**
			* @brief Create a new buffer view object.
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _bufferView
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _device, const CreateInfo& _info, Handle& _bufferView)
			{
				return Parent::Create(_device, _info, Memory::DefaultAllocator, _bufferView);
			}

			using Parent::Create;

			/**
			* @brief Destroy a buffer view object.
			* 
			* \param _deviceHandle
			* \param _bufferView
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _bufferView)
			{
				Parent::Destroy(_device, _bufferView, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/**
		@brief 
		Images represent multidimensional - up to 3 - arrays of data which can be used for various purposes
		(e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets,
		or by directly specifying them as parameters to certain commands.
		*/
		struct Image : public V1::Image
		{
			using Parent = V1::Image;


			/**  
			* @brief  Create an image object.
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _imageHandle
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _deviceHandle, const CreateInfo& _createInfo, Handle& _imageHandle)
			{
				return Parent::Create(_deviceHandle, _createInfo, Memory::DefaultAllocator, _imageHandle);
			}

			using Parent::Create;

			/** 
			* @brief Destroy an image object.
			* 
			* \param _deviceHandle
			* \param _image
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _image)
			{
				Parent::Destroy(_deviceHandle, _image, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			* @brief Will create an image and immediately bind it to memory made just for it.
			* 
			* \param _physicalDevice
			* \param _device
			* \param _info
			* \param _image
			* \param _propertyFlags
			* \param _imageMemory
			* \return 
			*/
			static EResult CreateAndBind
			(
				PhysicalDevice::Handle _physicalDevice,
				LogicalDevice::Handle  _device        ,
				CreateInfo             _info          ,
				Handle&                _image         , 
				Memory::PropertyFlags  _propertyFlags , 
				Memory::Handle&        _imageMemory      
			)
			{
				EResult returnCode = Image::Create(_device, _info, _image);

				if (returnCode != EResult::Success)
					return returnCode;

				Memory::Requirements memReq;

				Image::GetMemoryRequirements(_device, _image, memReq);

				Memory::AllocateInfo allocationInfo{};

				allocationInfo.AllocationSize  = memReq.Size;
				allocationInfo.MemoryTypeIndex = PhysicalDevice::FindMemoryType(_physicalDevice, memReq.MemoryTypeBits, _propertyFlags);

				returnCode = Memory::Allocate(_device, allocationInfo, _imageMemory);

				if (returnCode != EResult::Success)
					return returnCode;

				Image::BindMemory(_device, _image, _imageMemory, Memory::ZeroOffset);

				return returnCode;
			}

			/**
			* @brief Will create an image and immediately bind it to memory made just for it..
			* 
			* \param _physicalDevice
			* \param _device
			* \param _info
			* \param _image
			* \param _propertyFlags
			* \param _imageMemory
			* \return 
			*/
			static EResult CreateAndBind
			(
				PhysicalDevice::Handle       _physicalDevice,
				LogicalDevice::Handle        _device        ,
				CreateInfo                   _info          ,
				Handle&                      _image         , 
				Memory::PropertyFlags        _propertyFlags , 
				Memory::Handle&              _imageMemory   ,
				Memory::AllocationCallbacks* _allcator
			)
			{
				EResult returnCode = Image::Create(_device, _info, _allcator, _image);

				if (returnCode != EResult::Success)
					return returnCode;

				Memory::Requirements memReq;

				Image::GetMemoryRequirements(_device, _image, memReq);

				Memory::AllocateInfo allocationInfo{};

				allocationInfo.AllocationSize  = memReq.Size;
				allocationInfo.MemoryTypeIndex = PhysicalDevice::FindMemoryType(_physicalDevice, memReq.MemoryTypeBits, _propertyFlags);

				returnCode = Memory::Allocate(_device, allocationInfo, _allcator, _imageMemory);

				if (returnCode != EResult::Success)
					return returnCode;

				Image::BindMemory(_device, _image, _imageMemory, Memory::ZeroOffset);

				return returnCode;
			}
		};

		/**
		@brief An object that represents an image subresource range of a specific image,
		and state that controls how the contents are interpreted.
		*/
		struct ImageView : public V1::ImageView
		{
			using Parent = V1::ImageView;


			/**
			* @brief Create an image view object.
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _imageView
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _creationSpec,
				Handle&                      _imageView
			)
			{
				return Parent::Create(_deviceHandle, _creationSpec, Memory::DefaultAllocator, _imageView);
			}

			using Parent::Create;

			/**
			* @brief Destroy an image view.
			* 
			* \param _deviceHandle
			* \param _imageView
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle _deviceHandle,
				Handle                _imageView   
			)
			{
				return Parent::Destroy(_deviceHandle, _imageView, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		using V1::DescriptorSet;

		/**
		@brief A descriptor pool maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized,
		meaning that the application must not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
		*/
		struct DescriptorPool : public V1::DescriptorPool
		{
			using Parent = V1::DescriptorPool;


			/**
			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _descriptorPool
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle _device        ,
				const CreateInfo&           _createInfo    ,
				Handle&               _descriptorPool
			)
			{
				return Parent::Create(_device, _createInfo, Memory::DefaultAllocator, _descriptorPool);
			}

			using Parent::Create;

			/**
			* \param _device
			* \param _descriptorPool
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _descriptorPool)
			{
				Parent::Destroy(_device, _descriptorPool, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			static EResult Free
			(
				LogicalDevice::Handle  _device,
				const AllocateInfo&          _info,
				const DescriptorSet::Handle* _descriptorSets
			)
			{
				return Parent::Free(_device, _info.DescriptorPool, _info.DescriptorSetCount, _descriptorSets);
			}

			using Parent::Free;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief A linear array of data.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Buffer : public V2::Buffer
		{
		public:

			using Parent = V2::Buffer;

			/**
			@brief Default constructor.
			*/
			Buffer() : 
				handle            (Null<Handle>), 
				allocator         (nullptr)     ,
				device            (nullptr)     , 
				memoryRequirements()            
			{}

			/**
			@brief Logical device specified.
			*/
			Buffer(const LogicalDevice& _device) : 
				handle            (Null<Handle>), 
				allocator         (nullptr)     ,
				device            (&_device)    , 
				memoryRequirements()   
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Buffer(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : 
				handle            (Null<Handle>),
				allocator         (&_allocator) ,
				device            (&_device)    ,
				memoryRequirements()
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Buffer(Buffer&& _other) noexcept :
				handle   (_other.handle   ),
				allocator(_other.allocator),
				device   (_other.device   ),
				memoryRequirements(_other.memoryRequirements)
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroys the buffer if the handle is null.
			*/
			~Buffer()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Attach memory to a buffer object.
			*/
			EResult BindMemory(const Memory& _memory, DeviceSize _memoryOffset)
			{
				return Parent::BindMemory(*device, handle, _memory, _memoryOffset);
			}	

			/**
			@brief Create a buffer.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				EResult returnCode = Parent::Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);

				return returnCode;
			}

			/**
			@brief Create a buffer (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				EResult returnCode = Parent::Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);

				return returnCode;
			}

			/**
			@brief Create a buffer (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				EResult returnCode = Parent::Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);

				return returnCode;
			}

			/**
			@brief Destroy the buffer.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			const LogicalDevice& GetDevice()
			{
				return *device;
			}

			/**
			@brief Provides the memory requirements for the buffer.
			*/
			const Memory::Requirements& GetMemoryRequirements() const
			{
				return memoryRequirements;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Buffer& _other) const 
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Buffer& operator= (Buffer&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;

			Memory::Requirements memoryRequirements;
		};

		/**
		@brief A buffer view represents a contiguous range of a buffer and a specific format to be used to interpret the data.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class BufferView : public V2::BufferView
		{
		public:
			using Parent = V2::BufferView;

			/**
			@brief Default constructor.
			*/
			BufferView() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical specified.
			*/
			BufferView(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			BufferView(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			BufferView(BufferView&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the buffer view if the handle is null.
			*/
			~BufferView()
			{
				if (handle = Null<Handle>) Destroy();
			}

			/**
			@brief Create a buffer view.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create a buffer view (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create a buffer view (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a buffer view.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const BufferView& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			BufferView& operator= (BufferView&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief 
		Images represent multidimensional - up to 3 - arrays of data which can be used for various purposes
		(e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets,
		or by directly specifying them as parameters to certain commands.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.

		Note: If the image belongs to a swapchain, the swapchain handles the objects lifetime and should not be destroyed by this object,
		instead Clear() should be called before object's destruction to make sure that the device object is destroyed by this host object.
		*/
		class Image : public V2::Image
		{
		public:
			using Parent = V2::Image;

			/**
			@brief Default constructor.
			*/
			Image() : 
				handle            (Null<Handle>), 
				allocator         (nullptr)     ,
				device            (nullptr)     , 
				memoryRequirements() 
			{}

			/**
			@brief Specifies logical device.
			*/
			Image(const LogicalDevice& _device) : 
				handle            (Null<Handle>), 
				allocator         (nullptr)     ,
				device            (&_device)    , 
				memoryRequirements()  
			{}

			/**
			@brief Specifies logical device and allocator.
			*/
			Image(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : 
				handle            (Null<Handle>),
				allocator         (&_allocator) ,
				device            (&_device)    ,
				memoryRequirements()
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Image(Image&& _other) noexcept :
				handle   (_other.handle   ),
				allocator(_other.allocator),
				device   (_other.device   ),
				memoryRequirements(_other.memoryRequirements)
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the image if the handle is not null.
			*/
			~Image()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Assign the logical device and handle.
			*/
			void Assign(const LogicalDevice& _device, Handle _handle)
			{
				device = &_device;
				handle = _handle ;
			}

			/**
			@brief Clear the logical device and handle.
			*/
			void Clear()
			{
				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief
			*/
			EResult BindMemory(const Memory& _memory, DeviceSize _memoryOffset)
			{
				return Parent::BindMemory(*device, handle, _memory, _memoryOffset);
			}

			/**
			@brief Create an image.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				EResult returnCode = Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);
			}

			/**
			@brief Create an image (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				EResult returnCode = Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);

				return returnCode;
			}

			/**
			@brief Create an image (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				EResult returnCode = Parent::Create(*device, _info, allocator, handle);

				if (returnCode == EResult::Success)
					Parent::GetMemoryRequirements(*device, handle, memoryRequirements);

				return returnCode;
			}

			/**
			@brief Destroy an image.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Provides the memory requirements.
			*/
			const Memory::Requirements& GetMemoryRequirements() const
			{
				return memoryRequirements;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Image& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Image& operator= (Image&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;

			Memory::Requirements memoryRequirements;
		};

		/**
		@brief An object that represents an image subresource range of a specific image,
		and state that controls how the contents are interpreted.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class ImageView : public V2::ImageView
		{
		public:
			using Parent = V2::ImageView;

			/**
			@brief Default constructor.
			*/
			ImageView() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specifies the logical device.
			*/
			ImageView(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Specifies the logical device and allocator.
			*/
			ImageView(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			ImageView(ImageView&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the image view if handle is not null.
			*/
			~ImageView()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create an image view.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create an image view (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create an image view (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy the image view.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const ImageView& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			ImageView& operator= (ImageView&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:	

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief Descriptors are grouped together into descriptor set objects. A descriptor set object is an opaque object containing storage for a set of descriptors,
		where the types and number of descriptors is defined by a descriptor set layout.

		@detaisl This object only acts as a host interface to a given device object's handle. The descriptor pool manages the descriptor set's lifetime.
		*/
		class DescriptorSet : public V2::DescriptorSet
		{
		public:
			using Parent = V2::DescriptorSet;

			/**
			@brief Default allocator.
			*/
			DescriptorSet() : handle(Null<Handle>), device(nullptr)
			{}

			/**
			@brief Logical device and handle assigned.
			*/
			DescriptorSet(Handle _handle, const LogicalDevice& _device) : handle(_handle), device(&_device)
			{}

			/**
			@brief Assigns the logical device and handle.
			*/
			void Assign(const LogicalDevice& _device, Handle _handle)
			{
				device = &_device;
				handle = _handle ;
			}

			/**
			@brief Clears the logical device and handle.
			*/
			void Clear()
			{
				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Once allocated, descriptor sets can be updated with a combination of write and copy operations.
			*/
			void Update
			(
				uint32                _descriptorWriteCount,
				const Write*                _descriptorWrites    ,
				uint32                _descriptorCopyCount ,
				const Copy*                 _descriptorCopies
			)
			{
				Parent::Update(*device, _descriptorWriteCount, _descriptorWrites, _descriptorCopyCount, _descriptorCopies);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const DescriptorSet& _other) const
			{
				return handle == _other.handle;
			}

		protected:

			Handle handle;

			const LogicalDevice* device;
		};

		/**
		@brief A descriptor pool maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized,
		meaning that the application must not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class DescriptorPool : public V2::DescriptorPool
		{
		public:
			using Parent = V2::DescriptorPool;

			/**
			@brief Default constructor
			*/
			DescriptorPool() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specifies logical device.
			*/
			DescriptorPool(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specifies logical device and allocator.
			*/
			DescriptorPool(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			DescriptorPool(DescriptorPool&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroys a descriptor pool.
			*/
			~DescriptorPool()
			{
				if (handle = Null<Handle>) Destroy();
			}

			/**
			@brief Allocates descriptor sets based on allocate info and provided via the handles container.
			*/
			EResult Allocate(AllocateInfo& _info, DescriptorSet::Handle* _handlesContainer)
			{
				return Parent::Allocate(*device, _info, _handlesContainer);
			}

			/**
			@brief Allocates descriptor sets based on allocate info and provided via the descriptor set dynamic array and handle array.
			*/
			EResult Allocate
			(
				AllocateInfo&                        _info   ,
				DynamicArray<DescriptorSet>&         _sets   ,
				DynamicArray<DescriptorSet::Handle>& _handles
			)
			{
				_sets.resize(_info.DescriptorSetCount); _handles.resize(_info.DescriptorSetCount);

				EResult returnCode = Parent::Allocate(*device, _info, _handles.data());

				if (returnCode != EResult::Success) return returnCode;

				for (DeviceSize index = 0; index < _info.DescriptorSetCount; index++)
				{
					_sets[index].Assign(*device, _handles[index]);
				}

				return returnCode;
			}

			/**
			@brief Create a descriptor pool.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create a descriptor pool (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create a descriptor pool (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a descriptor set.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Free descriptor sets within the specified handles container.
			*/
			EResult Free(uint32 _count, DescriptorSet::Handle* _handles)
			{
				return Parent::Free(*device, handle, _count, _handles);
			}

			/**
			@brief Free descriptor sets specified in the dynamic array.
			*/
			EResult Free(DynamicArray<DescriptorSet::Handle> _handles)
			{
				return Parent::Free(*device, handle, static_cast<uint32>(_handles.size()), _handles.data());
			}

			/**
			@brief Return all descriptor sets allocated from a given pool to the pool, rather than freeing individual descriptor sets.
			*/
			EResult Reset(ResetFlags& _flags)
			{
				return Parent::Reset(*device, handle, _flags);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const DescriptorPool& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			DescriptorPool& operator= (DescriptorPool&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}



/*!
@file VT_SyncAndCacheControl.hpp

@brief Vaulted Thermals: Synchronization and Cache Control

@details
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V0
	{
		struct Fence_PlatformAgnostic
		{
			using EExternalHandleTypeFlag = EExternalFenceHandleTypeFlag;

			/** 
			@ingroup APISpec_Synchronization_and_Cache_Control 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFence">Specification</a> 
			*/
			using Handle = VkFence;
		};

		struct Semaphore_PlatformAgnostic
		{
			/**
			@ingroup APISpec_Synchronization_and_Cache_Control
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphore">Specification</a> 
			*/
			using Handle = VkSemaphore;	

			using EExternalHandleType = EExternalSemaphoreHandleTypeFlag;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExternalSemaphoreHandleTypeFlags">Specification</a> @ingroup APISpec_Additional_Capabilities */
			using ExternalHandleTypeFlags = Bitmask<EExternalHandleType, VkExternalSemaphoreHandleTypeFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreImportFlags">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			using ImportFlags = Bitmask<ESemaphoreImportFlag, VkSemaphoreImportFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreWaitFlags">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			using WaitFlags = Bitmask<ESemaphoreWaitFlag, VkSemaphoreWaitFlags>;
		};

		template<EOS> struct Fence_Maker    ;
		template<EOS> struct Semaphore_Maker;

		template<> struct Fence_Maker<EOS::Linux> : Fence_PlatformAgnostic
		{
			using OS_Handle = PlatformTypes_Maker<EOS::Linux>::OS_Handle;

			/** 
			@brief Do not use, dummy structure.
			*/
			struct ExportableHandleInfo : V0::VKStruct_Base<DummyBase, EStructureType::Max_Enum>
			{
				EType SType;
				const void* Next ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceGetFdInfoKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct GetOS_HandleInfo : V0::VKStruct_Base<VkFenceGetFdInfoKHR, EStructureType::Fence_Get_FD_Info_KHR>
			{
				EType                   SType      = STypeEnum;
				const void*                   Next       = nullptr  ;
				Handle                  Fence     ;
				EExternalHandleTypeFlag HandleType;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImportFenceFdInfoKHR">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ImportOS_HandleInfo : V0::VKStruct_Base<VkImportFenceFdInfoKHR, EStructureType::ImportFence_FD_Info_KHR>
			{
				EType                   SType          = STypeEnum;
				const void*                   Next           = nullptr  ;
				Handle                  Fence         ;
				FenceImportFlags        Flags         ;
				EExternalHandleTypeFlag HandleType    ;
				OS_Handle               FileDescriptor;
			};

			/**
			* @brief 
			* 
			* @details<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetFenceFdKHR">Specification</a>  
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pGetFdInfo
			* \param pFd
			* \return 
			*/
			static EResult GetOS_Handle
			(
				V1::LogicalDevice::Handle _device        ,
				const GetOS_HandleInfo&         _fdInfo        ,
				OS_Handle*                _fileDescriptor
			)
			{
				return EResult(vkGetFenceFdKHR(_device, _fdInfo, _fileDescriptor));
			}

			/**
			* @brief  
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkImportFenceFdKHR">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _importInfo
			* \return 
			*/
			static EResult ImportOS_Handle
			(
				V1::LogicalDevice::Handle _device    ,
				const ImportOS_HandleInfo&      _importInfo
			)
			{
				return EResult(vkImportFenceFdKHR(_device, _importInfo));
			}
		};

		template<> struct Fence_Maker<EOS::Windows> : Fence_PlatformAgnostic
		{
			using OS_Handle = PlatformTypes_Maker<EOS::Windows>::OS_Handle;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExportFenceWin32HandleInfoKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ExportableOS_HandleInfo : V0::VKStruct_Base<VkExportFenceWin32HandleInfoKHR, EStructureType::ExportFence_Win32Handle_Info_KHR>
			{
				EType                SType        = STypeEnum;
				const void*                Next         = nullptr  ;
				const SECURITY_ATTRIBUTES* Attributes  ;
				DWORD                AccessRights;
				LPCWSTR              Name        ;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceGetWin32HandleInfoKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct GetOS_HandleInfo : V0::VKStruct_Base<VkFenceGetWin32HandleInfoKHR, EStructureType::Fence_GetWin32Handle_Info_KHR>
			{
				EType                   SType      = STypeEnum;
				const void*                   Next       = nullptr  ;
				Handle                  Fence     ;
				EExternalHandleTypeFlag HandleType;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImportFenceWin32HandleInfoKHR">Specification</a> 
			* 
			* @details
			* Note: Windows provides an extra member for the handle name.
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ImportOS_HandleInfo : V0::VKStruct_Base<VkImportFenceWin32HandleInfoKHR, EStructureType::ImportFence_Win32Handle_Info_KHR>
			{
				EType                   SType      = STypeEnum;
				const void*                   Next       = nullptr  ;
				Handle                  Fence     ;
				FenceImportFlags        Flags     ;
				EExternalHandleTypeFlag HandleType;
				OS_Handle               Handle    ;
				LPCWSTR                 Name      ;
			};

			/**
			* @brief Export a Windows handle representing the state of a fence.

			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetFenceWin32HandleKHR">Specification</a>  
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \return 
			*/
			static EResult GetOS_Handle
			(
				V1::LogicalDevice::Handle _device            ,
				const GetOS_HandleInfo&         _getWin32HandleInfo,
				OS_Handle&                _winHandle
			)
			{
				return EResult(vkGetFenceWin32HandleKHR(_device, _getWin32HandleInfo, &_winHandle));
			}

			/**
			* @brief Import a fence payload from a Windows handle.
			*
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkImportFenceWin32HandleKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pImportFenceWin32HandleInfo
			* \return 
			*/
			static EResult ImportOS_Handle
			(
				V1::LogicalDevice::Handle _device    ,
				const ImportOS_HandleInfo&      _importInfo
			)
			{
				return EResult(vkImportFenceWin32HandleKHR(_device, _importInfo));
			}
		};

		template<> struct Semaphore_Maker<EOS::Linux> : Semaphore_PlatformAgnostic
		{
			using OS_Handle = PlatformTypes_Maker<EOS::Linux>::OS_Handle;

			/** 
			@brief Do not use, dummy structure. 
			*/
			struct ExportableOS_HandleInfo : V0::VKStruct_Base<DummyBase, EStructureType::Max_Enum>
			{
				EType SType = STypeEnum;
				const void* Next  = nullptr  ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreGetFdInfoKHR">Specification</a>  

			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct GetOS_HandleInfo : V0::VKStruct_Base<VkSemaphoreGetFdInfoKHR, EStructureType::Semaphore_Get_FD_Info_KHR>
			{
				EType               SType      = STypeEnum;
				const void*               Next       = nullptr  ;
				Handle              Semaphore ;
				EExternalHandleType HandleType;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImportSemaphoreFdInfoKHR">Specification</a>  

			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ImportOS_HandleInfo : V0::VKStruct_Base<VkImportSemaphoreFdInfoKHR, EStructureType::ImportSemaphore_FD_Info_KHR>
			{
				EType               SType      = STypeEnum;
				const void*               Next       = nullptr  ;
				Handle              Semaphore ;
				ImportFlags         Flags     ;
				EExternalHandleType HandleType;
				OS_Handle           OSHandle  ;
			};


			/**
			* @brief Export a POSIX file descriptor representing the payload of a semaphore.
			*  
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetSemaphoreFdKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pGetFdInfo
			* \param pFd
			* \return 
			*/
			static EResult GetOS_Handle
			(
				V1::LogicalDevice::Handle _device        ,
				const GetOS_HandleInfo&         _getInfo       ,
				OS_Handle*                _fileDescriptor
			)
			{
				return EResult(vkGetSemaphoreFdKHR(_device, _getInfo, _fileDescriptor));
			}

			/**
			* @brief Import a semaphore payload from a POSIX file descriptor.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkImportSemaphoreFdKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pImportSemaphoreFdInfo
			* \return 
			*/
			static EResult ImportOS_Handle(V1::LogicalDevice::Handle _device, const ImportOS_HandleInfo& _importPOSIX_Info)
			{
				return EResult(vkImportSemaphoreFdKHR(_device, _importPOSIX_Info));
			}
		};

		template<> struct Semaphore_Maker<EOS::Windows> : Semaphore_PlatformAgnostic
		{
			using OS_Handle = PlatformTypes_Maker<EOS::Windows>::OS_Handle;

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExportSemaphoreWin32HandleInfoKHR">Specification</a>  

			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ExportableOS_HandleInfo : V0::VKStruct_Base<VkExportSemaphoreWin32HandleInfoKHR, EStructureType::ExportSemaphore_Win32Handle_Info_KHR>
			{
				EType                SType        = STypeEnum;
				const void*                Next         = nullptr  ;
				const SECURITY_ATTRIBUTES* Attributes   = nullptr  ;
				DWORD                AccessRights;
				LPCWSTR              Name        ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreGetWin32HandleInfoKHR">Specification</a>  

			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct GetOS_HandleInfo : V0::VKStruct_Base<VkSemaphoreGetWin32HandleInfoKHR, EStructureType::Semaphore_GetWin32Handle_Info_KHR>
			{
				EType               SType      = STypeEnum;
				const void*               Next       = nullptr  ;
				Handle              Semaphore ;
				EExternalHandleType HandleType;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkImportSemaphoreWin32HandleInfoKHR">Specification</a>  

			@ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ImportOS_HandleInfo : V0::VKStruct_Base<VkImportSemaphoreWin32HandleInfoKHR, EStructureType::ImportSemaphore_Win32Handle_Info_KHR>
			{
				EType               SType      = STypeEnum;
				const void*               Next       = nullptr  ;
				Handle              Semaphore ;
				ImportFlags         Flags     ;
				EExternalHandleType HandleType;
				OS_Handle           OSHandle  ;
				LPCWSTR             Name      ;
			};


			/**
			* @brief Export a Windows handle representing the payload of a semaphore.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetSemaphoreWin32HandleKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pGetWin32HandleInfo
			* \param pHandle
			* \return 
			*/
			static EResult GetOS_Handle
			(
				V1::LogicalDevice::Handle _device ,
				const GetOS_HandleInfo&         _getInfo,
				OS_Handle&                _handle
			)
			{
				return EResult(vkGetSemaphoreWin32HandleKHR(_device, _getInfo, &_handle));
			}

			/**
			* @brief Import a semaphore payload from a Windows handle.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkImportSemaphoreWin32HandleKHR">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pImportSemaphoreWin32HandleInfo
			* \return 
			*/
			static EResult ImportOS_Handle(V1::LogicalDevice::Handle _device, const ImportOS_HandleInfo& _importHandleInfo)
			{
				return EResult(vkImportSemaphoreWin32HandleKHR(_device, _importHandleInfo));
			}
		};
	}

	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		* @brief 
		* Events are a synchronization primitive that can be used to insert a fine-grained dependency between commands submitted to the same queue, 
		* or between the host and a queue. Events must not be used to insert a dependency between commands submitted to different queues. 
		* Events have two states - signaled and unsignaled. 
		* 
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-events">Specification</a> 
		* 
		* @ingroup APISpec_Synchronization_and_Cache_Control
		*/
		struct Event
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkEvent">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			using Handle = VkEvent;

			using CreateFlags = Bitmask<EUndefined, VkEventCreateFlags>;   ///< @brief Reserved for future use.

																		   /** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkEventCreateInfo">Specification</a> @ingroup  APISpec_Synchronization_and_Cache_Control */
			struct CreateInfo : V0::VKStruct_Base<VkEventCreateInfo, EStructureType::Event_CreateInfo>
			{
				EType       SType = STypeEnum;
				const void*       Next  = nullptr  ;
				CreateFlags Flags;
			};

			/**
			* @brief Create an Event.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateEvent">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _event
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _device    ,
				const Event::CreateInfo&           _createInfo,
				const Memory::AllocationCallbacks* _allocator ,
				Handle&                      _event
			)
			{
				return EResult(vkCreateEvent(_device, _createInfo, *_allocator, &_event));
			}

			/**
			* @brief Destroy an event.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyEvent">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _event
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _device   ,
				Handle                       _event    ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroyEvent(_device, _event, *_allocator);
			}

			/**
			* @brief Query the state of an event from the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetEventStatus">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param event
			* \return 
			*/
			static EResult GetStatus(LogicalDevice::Handle _device, Handle _event)
			{
				return EResult(vkGetEventStatus(_device, _event));
			}

			/**
			* @brief Set the state of an event to unsignaled from the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkResetEvent">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _event
			* \return 
			*/
			static EResult Reset(LogicalDevice::Handle _device, Handle _event)
			{
				return EResult(vkResetEvent(_device, _event));
			}

			/**
			* @brief 
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkSetEvent">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _event
			* \return 
			*/
			static EResult Set(LogicalDevice::Handle _device, Handle _event)
			{
				return EResult(vkSetEvent(_device, _event));
			}
		};

		/**
		@brief Fences are a synchronization primitive that can be used to insert a dependency from a queue to the host. Fences have two states - signaled and unsignaled.

		@details
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-fences">Specification</a> 

		@ingroup APISpec_Synchronization_and_Cache_Control
		*/
		struct Fence : V0::Fence_Maker<V0::OS_Platform>
		{
			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceCreateFlags">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			using CreateFlags = Bitmask<EFenceCreateFlag, VkFenceCreateFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExternalFenceHandleTypeFlags">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			using ExternalHandleFlags = Bitmask<EExternalFenceHandleTypeFlag, VkExternalFenceHandleTypeFlags>;

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFenceCreateInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct CreateInfo : V0::VKStruct_Base<VkFenceCreateInfo, EStructureType::Fence_CreateInfo>
			{
				EType       SType = STypeEnum;
				const void*       Next  = nullptr  ;
				CreateFlags Flags;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceEventInfoEXT">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct DeviceEventInfo : V0::VKStruct_Base<VkDeviceEventInfoEXT, EStructureType::Device_EventInfo_EXT>
			{
				EType            SType       = STypeEnum;
				const void*            Next        = nullptr  ;
				EDeviceEventType DeviceEvent;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDisplayEventInfoEXT">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct DisplayEventInfo : V0::VKStruct_Base<VkDisplayEventInfoEXT, EStructureType::Display_EventInfo_EXT>
			{
				EType             SType        = STypeEnum;
				const void*             Next         = nullptr  ;
				EDisplayEventType DisplayEvent;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExportFenceCreateInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			struct ExportCreateInfo : V0::VKStruct_Base<VkExportFenceCreateInfo, EStructureType::ExportFence_CreateInfo>
			{
				EType               SType       = STypeEnum;
				const void*               Next        = nullptr  ;
				ExternalHandleFlags HandleTypes;
			};

			/**
			* @brief Create a fence.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateFence">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _logicalDevice
			* \param _createInfo
			* \param _allocator
			* \param _fence
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _logicalDevice,
				const CreateInfo&                  _createInfo   ,
				const Memory::AllocationCallbacks* _allocator    ,
				Handle&                      _fence
			)
			{
				return EResult(vkCreateFence(_logicalDevice, _createInfo, *_allocator, &_fence));
			}

			/**
			* @brief Destroy a fence.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyFence">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _logicalDevice
			* \param _fence
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _logicalDevice,
				Handle                       _fence        ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroyFence(_logicalDevice, _fence, *_allocator);
			}

			/**
			* @brief Export a Windows handle representing the state of a fence.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetFenceStatus">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _logicalDevice
			* \param _fence
			* \return 
			*/
			static EResult GetStatus(LogicalDevice::Handle _logicalDevice, Handle _fence)
			{
				return EResult(vkGetFenceStatus(_logicalDevice, _fence));
			}			

			/**
			* @brief Create a fence that will be signaled when an event occurs on a device.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkRegisterDeviceEventEXT">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pDeviceEventInfo
			* \param pAllocator
			* \param pFence
			* \return 
			*/
			static EResult RegisterDeviceEvent
			(
				LogicalDevice::Handle        _device         ,
				const DeviceEventInfo&             _deviceEventInfo,
				const Memory::AllocationCallbacks* _allocator      ,
				Handle&                      _fence
			)
			{
				return EResult(vkRegisterDeviceEventEXT(_device, _deviceEventInfo, *_allocator, &_fence));
			}

			/**
			* @brief Create a fence that will be signaled when an event occurs on a Display object.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkRegisterDisplayEventEXT">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param display
			* \param pDisplayEventInfo
			* \param pAllocator
			* \param pFence
			* \return 
			*/
			static EResult RegisterDisplayEvent
			(
				LogicalDevice::Handle        _device          ,
				Display::Handle              _display         ,
				const DisplayEventInfo&            _displayEventInfo,
				const Memory::AllocationCallbacks* _allocator       ,
				Handle&                      _fence
			)
			{
				return EResult(vkRegisterDisplayEventEXT(_device, _display, _displayEventInfo, *_allocator, &_fence));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkResetFences">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _logicalDevice
			* \param _fences
			* \param _fenceCount
			* \return 
			*/
			static EResult Reset(LogicalDevice::Handle _logicalDevice, Handle* _fences, uint32 _fenceCount)
			{
				return EResult(vkResetFences(_logicalDevice, _fenceCount, _fences));
			}

			/**
			* 
			* @brief Wait for one or more fences to enter the signaled state on the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkWaitForFences">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param fenceCount
			* \param pFences
			* \param waitAll
			* \param timeout
			* \return 
			*/
			static EResult WaitForFences
			(
				LogicalDevice::Handle _device    ,
				uint32                _fenceCount,
				const Handle*               _fences    ,
				Bool                  _waitAll   ,
				uInt64                _timeout
			)
			{
				return EResult(vkWaitForFences(_device, _fenceCount, _fences, _waitAll, _timeout));
			}
		};

		/**
		@brief Semaphores are a synchronization primitive that can be used to insert a dependency between queue operations or between a queue operation and the host. 
		Binary semaphores have two states - signaled and unsignaled.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-semaphores">Specification</a> 

		@ingroup APISpec_Synchronization_and_Cache_Controls
		*/
		struct Semaphore : V0::Semaphore_Maker<V0::OS_Platform>
		{
			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreCreateInfo">Specification</a> APISpec_Synchronization_and_Cache_Control
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Controls
			*/
			struct CreateInfo : V0::VKStruct_Base<VkSemaphoreCreateInfo, EStructureType::Semaphore_CreateInfo>
			{
				using CreateFlags = Bitmask<EUndefined, VkSemaphoreCreateFlags>;

				EType       SType = STypeEnum;
				const void*       Next  = nullptr  ;
				CreateFlags Flags;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkExportSemaphoreCreateInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Controls
			*/
			struct ExportCreateInfo : V0::VKStruct_Base<VkExportSemaphoreCreateInfo, EStructureType::Export_Semaphore_CreateInfo_KHR>
			{
				EType                   SType       = STypeEnum;
				const void*                   Next        = nullptr  ;
				ExternalHandleTypeFlags HandleTypes;				
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreSignalInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			struct SignalInfo : V0::VKStruct_Base<VkSemaphoreSignalInfo, EStructureType::Semaphore_SignalInfo>
			{
				EType  SType     = STypeEnum;
				const void*  Next      = nullptr  ;
				Handle Semaphore;
				uInt64 Value    ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreTypeCreateInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			struct TypeSpecifiedCreateInfo : V0::VKStruct_Base<VkSemaphoreTypeCreateInfo, EStructureType::SemaphoreType_CreateInfo>
			{
				EType  SType         = STypeEnum;
				const void*  Next          = nullptr  ;
				Handle SemaphoreType;
				uInt64 InitialValue ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSemaphoreWaitInfo">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			struct WaitInfo : V0::VKStruct_Base<VkSemaphoreWaitInfo, EStructureType::Semaphore_WaitInfo>
			{
				EType     SType          = STypeEnum;
				const void*     Next           = nullptr  ;
				WaitFlags Flags         ;
				uint32    SemaphoreCount;
				const Handle*   Semaphores     = nullptr  ;
				const uInt64*   Values         = nullptr  ;
			};

			/**
			* @brief Create a semaphore.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateSemaphore">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pCreateInfo
			* \param pAllocator
			* \param pSemaphore
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _device    ,
				const CreateInfo&                  _createInfo,
				const Memory::AllocationCallbacks* _allocator ,
				Handle&                      _semaphore
			)
			{
				return EResult(vkCreateSemaphore(_device, _createInfo, *_allocator, &_semaphore));
			}

			/**
			* @brief Destroy a semaphore.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroySemaphore">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _semaphore
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _device   ,
				Handle                       _semaphore,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroySemaphore(_device, _semaphore, *_allocator);
			}

			/**
			* @brief Query the current counter value of a semaphore created with a SemaphoreType of Timeline from the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetSemaphoreCounterValue">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param semaphore
			* \param pValue
			* \return 
			*/
			static EResult GetCounterValue
			(
				LogicalDevice::Handle _device   ,
				Handle                _semaphore,
				uInt64&               _value
			)
			{
				return EResult(vkGetSemaphoreCounterValue(_device, _semaphore, &_value));
			}			

			/**
			* @brief Signal a semaphore created with a SemaphoreType of Timeline with a particular counter value, on the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkSignalSemaphore">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param device
			* \param pSignalInfo
			* \return 
			*/
			static EResult Signal(LogicalDevice::Handle _device, const SignalInfo& _signalInfo)
			{
				return EResult(vkSignalSemaphore(_device, _signalInfo));
			}

			/**
			* @brief Wait for a set of semaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE to reach particular counter values on the host.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkWaitSemaphores">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			* 
			* \param _device
			* \param _waitInfo
			* \param timeout
			* \return 
			*/
			static EResult WaitFor
			(
				LogicalDevice::Handle _device  ,
				const WaitInfo&             _waitInfo,
				uInt64                _timeout
			)
			{
				return EResult(vkWaitSemaphores(_device, _waitInfo, _timeout));
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief
		Events are a synchronization primitive that can be used to insert a fine-grained dependency between commands submitted to the same queue,
		or between the host and a queue. Events must not be used to insert a dependency between commands submitted to different queues.
		Events have two states - signaled and unsignaled.
		*/
		struct Event : public V1::Event
		{
			using Parent = V1::Event;

			/**
			* @brief Create an event (Default Allocator).
			* 
			* \param _device
			* \param _createInfo
			* \param _allocator
			* \param _event
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle _device    ,
				const Event::CreateInfo&    _createInfo,
				Handle&               _event
			)
			{
				return Parent::Create(_device, _createInfo, Memory::DefaultAllocator, _event);
			}

			using Parent::Create;

			/**
			* @brief Destroy an event (Default Allocator).

			* \param _device
			* \param _event
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _device, Handle _event)
			{
				Parent::Destroy(_device, _event, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/**
		@brief Fences are a synchronization primitive that can be used to insert a dependency from a queue to the host. Fences have two states - signaled and unsignaled.
		*/
		struct Fence : public V1::Fence
		{
			using Parent = V1::Fence;

			/**
			* @brief Create a fence (Default Allocator).
			* 
			* \param _logicalDevice
			* \param _createInfo
			* \param _allocator
			* \param _fence
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _logicalDevice,
				const CreateInfo&                  _createInfo   ,
				Handle&                      _fence
			)
			{
				return Parent::Create(_logicalDevice, _createInfo, Memory::DefaultAllocator, _fence);
			}

			using Parent::Create;

			/**
			* @brief Destroy a fence (Default Allocator).
			* 
			* \param _logicalDevice
			* \param _fence
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _logicalDevice, Handle _fence)
			{
				Parent::Destroy(_logicalDevice, _fence, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			* 
			* @brief
			* 
			* @details
			* 
			* \param device
			* \param pDeviceEventInfo
			* \param pAllocator
			* \param pFence
			* \return 
			*/
			static EResult RegisterDeviceEvent
			(
				LogicalDevice::Handle        _device         ,
				const DeviceEventInfo&             _deviceEventInfo,
				Handle&                      _fence
			)
			{
				return Parent::RegisterDeviceEvent(_device, _deviceEventInfo, Memory::DefaultAllocator, _fence);
			}

			using Parent::RegisterDeviceEvent;

			/**
			* @brief 
			* 
			* @details
			* 
			* \param device
			* \param display
			* \param pDisplayEventInfo
			* \param pAllocator
			* \param pFence
			* \return 
			*/
			static EResult RegisterDisplayEvent
			(
				LogicalDevice::Handle        _device          ,
				Display::Handle              _display         ,
				const DisplayEventInfo&            _displayEventInfo,
				Handle&                      _fence
			)
			{
				return Parent::RegisterDisplayEvent(_device, _display, _displayEventInfo, Memory::DefaultAllocator, _fence);
			}

			using Parent::RegisterDisplayEvent;
		};

		/**
		@brief Semaphores are a synchronization primitive that can be used to insert a dependency between queue operations or between a queue operation and the host.
		Binary semaphores have two states - signaled and unsignaled.
		*/
		struct Semaphore : public V1::Semaphore
		{
			using Parent = V1::Semaphore;

			/**
			@brief Create a semaphore (Default Allocator).
			*/
			static EResult Create
			(
				LogicalDevice::Handle _device    ,
				const CreateInfo&           _createInfo,
				Handle&               _semaphore
			)
			{
				return Parent::Create(_device, _createInfo, Memory::DefaultAllocator, _semaphore);
			}

			using Parent::Create;

			/**
			@brief Destroy a semaphore (Default Allocator).
			*/
			static void Destroy
			(
				LogicalDevice::Handle _device   ,
				Handle                _semaphore
			)
			{
				Parent::Destroy(_device, _semaphore, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief
		Events are a synchronization primitive that can be used to insert a fine-grained dependency between commands submitted to the same queue,
		or between the host and a queue. Events must not be used to insert a dependency between commands submitted to different queues.
		Events have two states - signaled and unsignaled.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Event : public V2::Event
		{
		public:
			using Parent = V2::Event;

			/**
			@brief Default constructor.
			*/
			Event() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			Event(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Event(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Event(Event&& _other) noexcept : 
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the event if the handle is not null.
			*/
			~Event()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create an event.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create an event (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create an event (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy an event.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Query the state of an event from the host.
			*/
			EResult GetStatus()
			{
				return Parent::GetStatus(*device, handle);
			}

			/**
			@brief Set the state of an event to unsignaled from the host.
			*/
			EResult Reset()
			{
				return Parent::Reset(*device, handle);
			}

			/**
			@brief Set the state of an event to signaled from the host.
			*/
			EResult Set()
			{
				return Parent::Set(*device, handle);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Event& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Event& operator= (Event&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief Fences are a synchronization primitive that can be used to insert a dependency from a queue to the host. Fences have two states - signaled and unsignaled.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Fence : public V2::Fence
		{
		public:
			using Parent = V2::Fence;

			/**
			@brief Default constructor.
			*/
			Fence() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			Fence(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Fence(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Fence(Fence&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy a fence if handle is not null.
			*/
			~Fence()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create a fence.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a fence (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a fence (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a fence.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Provides the logical device handle.
			*/
			LogicalDevice::Handle GetDeviceHandle() const
			{
				return *device;
			}

			/**
			@brief Query the status of a fence from the host
			*/
			EResult GetStatus()
			{
				return Parent::GetStatus(*device, handle);
			}

			/**
			@brief Platform agnostic way to export the os handle of the fence.
			*/
			EResult GetOS_Handle(const GetOS_HandleInfo& _win32Info, OS_Handle & _winHandle)
			{
				return Parent::GetOS_Handle(*device, _win32Info, _winHandle);
			}

			/**
			@brief Import a fence payload from a os handle.
			*/
			EResult ImportOS_Handle(const ImportOS_HandleInfo& _importInfo)
			{
				return Parent::ImportOS_Handle(*device, _importInfo);
			}

			/**
			@brief Create a fence that will be signaled when an event occurs on a device.
			*/
			EResult RegisterDeviceEvent(const DeviceEventInfo _eventInfo)
			{
				return Parent::RegisterDeviceEvent(*device, _eventInfo, allocator, handle);
			}

			/**
			@brief Create a fence that will be signaled when an event occurs on a Display object.
			*/
			EResult RegisterDisplayEvent(Display::Handle _display, const DisplayEventInfo& _eventInfo)
			{
				return Parent::RegisterDisplayEvent(*device, _display, _eventInfo, allocator, handle);
			}

			/**
			@brief Set the state of fences to unsignaled from the host.
			*/
			EResult Reset()
			{
				return Parent::Reset(*device, &handle, 1);
			}

			/**
			@brief Reset the fences in the provided container.
			*/
			static EResult Reset(DynamicArray<Fence> _fences)
			{
				auto device = _fences[0].GetDeviceHandle();

				DynamicArray<Fence::Handle> handles;

				for (auto& fence : _fences) handles.push_back(fence);

				return Parent::Reset(device, handles.data(), static_cast<uint32>(_fences.size()));
			}

			/**
			@brief Wait for the fence to enter the signaled state on the host.
			*/
			EResult WaitFor(uInt64 _timeout)
			{
				return Parent::WaitForFences(*device, 1, &handle, false, _timeout);
			}

			/**
			@brief Wait for one or more fences to enter the signaled state on the host.
			*/
			static EResult WaitForFence(DynamicArray<Fence> _fences, bool _waitForAll, uInt64 _timeout)
			{
				auto device = _fences[0].GetDeviceHandle();

				DynamicArray<Fence::Handle> handles;

				for (auto& fence : _fences) handles.push_back(fence);

				return Parent::WaitForFences(device, static_cast<uint32>(_fences.size()), handles.data(), _waitForAll, _timeout);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Fence& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Fence& operator= (Fence&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief Semaphores are a synchronization primitive that can be used to insert a dependency between queue operations or between a queue operation and the host.
		Binary semaphores have two states - signaled and unsignaled.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Semaphore : public V2::Semaphore
		{
		public:
			using Parent = V2::Semaphore;

			/**
			@brief Default constructor.
			*/
			Semaphore() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			Semaphore(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Semaphore(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Semaphore(Semaphore&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the semaphore if the handle is not null.
			*/
			~Semaphore()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create a semaphore.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a semaphore (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a semaphore (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a semaphore.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Query the current counter value of a semaphore created with a SemaphoreType of Timeline from the host.
			*/
			EResult GetCounterValue(uInt64& _value)
			{
				return Parent::GetCounterValue(*device, handle, _value);
			}

			/**
			@brief Export an os handle representing the payload of a semaphore.
			*/
			EResult GetOS_Handle(const GetOS_HandleInfo& _getInfo, OS_Handle& _osHandle)
			{
				return Parent::GetOS_Handle(*device, _getInfo, _osHandle);
			}

			/**
			@brief Import a semaphore payload from an os handle.
			*/
			EResult ImportOS_Handle(const ImportOS_HandleInfo& _importPOSIX_Info)
			{
				return Parent::ImportOS_Handle(*device, _importPOSIX_Info);
			}

			/**
			@brief Signal a semaphore created with a SemaphoreType of Timeline with a particular counter value, on the host.
			*/
			EResult Signal(const SignalInfo& _info)
			{
				return Parent::Signal(*device, _info);
			}

			/**
			@brief Wait for a set of semaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE to reach particular counter values on the host.
			*/
			EResult WaitFor(const WaitInfo& _info, uInt64 _timeout)
			{
				return Parent::WaitFor(*device, _info, _timeout);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Semaphore& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Semaphore& operator= (Semaphore&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}




/*!
@file VT_Shaders.hpp

@brief Vaulted Thermals: Shaders

@details
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#shaders">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		* @brief 
		* Shader modules contain shader code and one or more entry points. 
		* 
		* @details
		* Shaders are selected from a shader module by specifying an entry point as part of pipeline creation. 
		* The stages of a pipeline can use shaders that come from different modules.
		* 
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#shader-modules">Specification</a> 
		* 
		* @ingroup APISpec_Shaders
		*/
		struct ShaderModule
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderModule">Specification</a> @ingroup APISpec_Shaders */
			using Handle = VkShaderModule;

			/** 
			@brief Reserved for future use.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderModuleCreateInfo">Specification</a> 
			@ingroup APISpec_Shaders 
			*/
			using CreateFlags = Bitmask<EUndefined, Flags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderModuleCreateInfo">Specification</a> @ingroup APISpec_Shaders */
			struct CreateInfo : V0::VKStruct_Base<VkShaderModuleCreateInfo, EStructureType::ShaderModule_CreateInfo>
			{
				EType             SType     = STypeEnum;
				const void*             Next      = nullptr  ;
				CreateFlags       Flags    ;
				std::size_t       CodeSize  = 0        ;
				const SPIR_V::Bytecode* Code      = nullptr  ;
			};

			/**
			* @brief Create a sher module.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateShaderModule">Specification</a> 
			* 
			* @ingroup APISpec_Shaders
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _shaderModule
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _creationSpec,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _shaderModule
			)
			{
				return EResult(vkCreateShaderModule(_deviceHandle, _creationSpec, *_allocator, &_shaderModule));
			}

			/**
			* @brief Destroy a shader module.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyShaderModule">Specification</a> 
			* 
			* @ingroup APISpec_Shaders
			* 
			* \param _deviceHandle
			* \param _moduleHandle
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _moduleHandle, const Memory::AllocationCallbacks* _allocator)
			{
				return vkDestroyShaderModule(_deviceHandle, _moduleHandle, *_allocator);
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief Shader modules contain shader code and one or more entry points. 
		*/
		struct ShaderModule : public V1::ShaderModule
		{
			using Parent = V1::ShaderModule;

			/**
			@brief Offers a default constructor and one code/code size parameters.
			*/
			struct CreateInfo : public Parent::CreateInfo
			{
				using Parent = Parent::CreateInfo;

				CreateInfo() : Parent::CreateInfo()
				{}

				CreateInfo(RoCStr _code, std::size_t _codeSize)
				{
					using SPIR_V::Bytecode;

					SType    = STypeEnum;
					Next     = nullptr  ;
					CodeSize = _codeSize;
					Code     = reinterpret_cast<const Bytecode*>(_code);
				}
			};

			/**
			* @brief Create a sher module.
			* 
			* @details
			* 
			* \param _deviceHandle
			* \param _creationSpec
			* \param _allocator
			* \param _shaderModule
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle _deviceHandle,
				const CreateInfo&           _creationSpec,
				Handle&               _shaderModule
			)
			{
				return Parent::Create(_deviceHandle, _creationSpec, Memory::DefaultAllocator, _shaderModule);
			}

			using Parent::Create;

			/**
			* @brief Destroy a shader module.
			* 
			* @details
			* 
			* \param _deviceHandle
			* \param _moduleHandle
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _moduleHandle)
			{
				Parent::Destroy(_deviceHandle, _moduleHandle, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief Shader modules contain shader code and one or more entry points. 

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class ShaderModule : public V2::ShaderModule
		{
		public:

			using Parent = V2::ShaderModule;

			/**
			@brief Default constructor.
			*/
			ShaderModule() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specifies the logical device.
			*/
			ShaderModule(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Specifies the logical device and allocator.
			*/
			ShaderModule(const LogicalDevice& _device, const Memory::AllocationCallbacks _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			ShaderModule(ShaderModule&& _other) noexcept : 
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the shader module if the handle is not null.
			*/
			~ShaderModule()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create a shader module.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a shader module (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a shader module (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a shader module.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ; 
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const ShaderModule& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			ShaderModule& operator= (ShaderModule&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}




/*!
@file VT_Pipelines.hpp

@brief Vaulted Thermals: Pipelines

@details
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		* @brief A monolithic object describing the entire graphics, raytracing, or compute pipeline.
		* 
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines">Specification</a> 
		* 
		* @ingroup APISpec_Pipelines
		*/
		struct Pipeline
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipeline">Specification</a> @ingroup APISpec_Pipelines */
			using Handle = VkPipeline;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderStageFlags">Specification</a> @ingroup APISpec_Pipelines */
			using ShaderStageFlags = Bitmask<EShaderStageFlag, VkShaderStageFlags>;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineStageFlags">Specification</a> @ingroup APISpec_Synchronization_and_Cache_Control */
			using StageFlags = Bitmask<EPipelineStageFlag, VkPipelineStageFlags>;

			/**
			* @brief Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. 
			* 
			* @details
			* Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. 
			* Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, 
			* and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. 
			* Applications can manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.
			* 
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines-cache">Specification</a> 
			* 
			* @ingroup APISpec_Pipelines
			*/
			struct Cache
			{
				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.htmal#VkPipelineCache">Specification</a> @ingroup APISpec_Pipelines */
				using Handle = VkPipelineCache;

				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCacheCreateFlags">Specification</a> @ingroup APISpec_Pipelines  */
				using CreateFlags = Bitmask<EPipelineCacheCreateFlag, VkPipelineCacheCreateFlags>;

				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCacheCreateInfo">Specification</a> @ingroup APISpec_Pipelines */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineCacheCreateInfo, EStructureType::Pipeline_Cache_CreateInfo>
				{
					EType       SType           = STypeEnum;
					const void*       Next            = nullptr  ;
					CreateFlags Flags          ;
					std::size_t InitialDataSize;
					const void*       InitialData     = nullptr  ;
				};

				/**
				* @brief Create a pipeline cache.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreatePipelineCache">Specification</a>
				* 
				* @ingroup APISpec_Pipelines
				* 
				* \param _deviceHandle
				* \param _createInfo
				* \param _allocator
				* \param _pipelineCache
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle        _deviceHandle ,
					const CreateInfo&                  _createInfo   ,
					const Memory::AllocationCallbacks* _allocator    ,
					Cache::Handle&               _pipelineCache
				)
				{
					return EResult(vkCreatePipelineCache(_deviceHandle, _createInfo, *_allocator, &_pipelineCache));
				}

				/**
				* @brief Destroy a pipeline cache.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyPipelineCache">Specification</a> 
				* 
				* @ingroup APISpec_Pipelines
				* 
				* \param _deviceHandle
				* \param _cache
				* \param _allocator
				*/
				static void Destroy(LogicalDevice::Handle _deviceHandle, Cache::Handle _cache, const Memory::AllocationCallbacks* _allocator)
				{
					vkDestroyPipelineCache(_deviceHandle, _cache, *_allocator);
				}

				/** 
				@todo 
				#TODO: MakeMergCacheFunction vkMergePipelineCaches 
				*/

				/** 
				@todo 
				#TODO:  vkGetPipelineCacheData 
				*/
			};

			/**
			@ingroup APISpec_The_Framebuffer

			@brief Blending combines the incoming source fragments R, G, B, and A values with the destination R, G, B, and A values of each sample stored in the framebuffer
			at the fragments xf,yf location. Blending is performed for each color sample covered by the fragment, rather than just once for each fragment.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#framebuffer-blending">Specification</a>
			*/
			struct ColorBlendState
			{
				/**
				@ingroup APISpec_The_Framebuffer

				@brief Specifies per-target blending state for each individual color attachment.

				@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineColorBlendAttachmentState">Specification</a> 
				*/
				struct AttachmentState : V0::VKStruct_Base<VkPipelineColorBlendAttachmentState, EStructureType::Pipeline_ColorBlendAdvancedState_CreateInfo_EXT>
				{
					Bool                EnableBlend                 ;
					EBlendFactor        Source_ColorBlendFactor     ;
					EBlendFactor        Destination_ColorBlendFactor;
					EBlendOperation     ColorOperation              ;
					EBlendFactor        Source_AlphaBlendFactor     ;
					EBlendFactor        Destination_AlphaBlendFactor;
					EBlendOperation     AlphaOperation              ;
					ColorComponentFlags ColorWriteMask              ;
				};

				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< @brief Reserved for future use.

																  /**
																  @ingroup APISpec_The_Framebuffer

																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineColorBlendStateCreateInfo">Specification</a>
																  */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineColorBlendStateCreateInfo, EStructureType::Pipeline_ColorBlendState_CreateInfo>
				{
					EType            SType                 = STypeEnum;
					const void*            Next                  = nullptr  ;
					CreateFlags      Flags                ;
					Bool             EnableLogicOperations;
					ELogicOperation  LogicOperation       ;
					uint32           AttachmentCount       = 0        ;
					const AttachmentState* Attachments           = nullptr  ;
					float32          BlendConstants[4]    ;
				};
			};

			/**
			@brief Pipeline state controlling the depth bounds tests, stencil test, and depth test.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fragops-ds-state">Specification</a> 

			@ingroup APISpec_Fragment_Operations
			*/
			struct DepthStencilState
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineDepthStencilStateCreateFlags">Specification</a> 
				@ingroup APISpec_Fragment_Operations
				*/
				using CreateFlags = Bitmask<EUndefined, VkPipelineDepthStencilStateCreateFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineDepthStencilStateCreateInfo">Specification</a>  
				@ingroup APISpec_Fragment_Operations
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineDepthStencilStateCreateInfo, EStructureType::Pipeline_DepthStencilState_CreateInfo>
				{
					EType                 SType                 = STypeEnum;
					const void*                 Next                  = nullptr  ;
					CreateFlags           Flags                ;
					Bool                  DepthTestEnable      ;
					Bool                  DepthWriteEnable     ;
					ECompareOperation     DepthCompareOp       ;
					Bool                  DepthBoundsTestEnable;
					Bool                  StencilTestEnable    ;
					StencilOperationState Front                ;
					StencilOperationState Back                 ;
					float32               MinDepthBounds       ;
					float32               MaxDepthBounds       ;
				};
			};

			/** 
			@brief Used to indicate which properties of the pipeline state object are dynamic and can be changed independently of the pipeline state. 

			@details This can be NULL, which means no state in the pipeline is considered dynamic.

			@ingroup APISpec_Pipelines
			*/
			struct DynamicState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< @brief Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineDynamicStateCreateInfo">Specification</a>  
																  @ingroup APISpec_Pipelines
																  */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineDynamicStateCreateInfo, EStructureType::Pipeline_DynamicState_CreateInfo>
				{
					EType          SType      = STypeEnum;
					const void*          Next       = nullptr  ;
					CreateFlags    Flags     ;
					uint32         StateCount = 0        ;
					const EDynamicState* States     = nullptr  ;
				};
			};

			/** 
			@brief Each draw is made up of zero or more vertices and zero or more instances, which are processed by the device and result in the assembly of primitives.
			Primitives are assembled according to the InputAssemblyState member.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#drawing">Specification</a> 

			@ingroup APISpec_Drawing_Commands
			*/
			struct InputAssemblyState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< @brief Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineInputAssemblyStateCreateInfo">Specification</a>  
																  @ingroup APISpec_Drawing_Commands
																  */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineInputAssemblyStateCreateInfo, EStructureType::Pipeline_InputAssemblyState_CreateInfo>
				{
					EType              SType                  = STypeEnum;
					const void*              Next                   = nullptr  ;
					CreateFlags        Flags                 ;
					EPrimitiveTopology Topology              ;
					Bool               PrimitiveRestartEnable;
				};
			};

			/**
			* @brief Access to descriptor sets from a pipeline is accomplished through a pipeline layout.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#descriptorsets-pipelinelayout">Specification</a> 
			* @ingroup APISpec_Resource_Descriptors
			*/
			struct Layout
			{
				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineLayout">Specification</a> 
				@ingroup APISpec_Resource_Descriptors 
				*/
				using Handle = VkPipelineLayout;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPushConstantRange">Specification</a>  
				@ingroup APISpec_Resource_Descriptors
				*/
				struct PushConstantRange : V0::VKStruct_Base<VkPushConstantRange>
				{
					ShaderStageFlags StageFlags;
					uint32           Offset    ;
					uint32           Size      ;
				};


				/**
				* @brief Defines the types and number of descriptor sets used in a pipeline.
				* 
				* @details
				* A descriptor set object is an opaque object containing storage for a set of descriptors, 
				* where the types and number of descriptors is defined by a descriptor set layout. 
				* 
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#descriptorsets-setlayout">Specification</a> 
				* 
				* @ingroup APISpec_Resource_Descriptors
				*/
				struct DescriptorSet
				{
					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayout">Specification</a> 
					@ingroup APISpec_Resource_Descriptors
					*/
					using Handle = VkDescriptorSetLayout;

					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutBinding">Specification</a> 
					@ingroup APISpec_Resource_Descriptors
					*/
					struct Binding : V0::VKStruct_Base<VkDescriptorSetLayoutBinding>
					{
						uint32           BindingID        ;
						EDescriptorType  Type             ;
						uint32           Count            ;
						ShaderStageFlags StageFlags       ;
						const Sampler::Handle* ImmutableSamplers;

						/** 
						@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorBindingFlags">Specification</a> 
						@ingroup APISpec_Resource_Descriptors 
						*/
						using CreateFlags = Bitmask<EDescriptorBindingFlag ,VkDescriptorBindingFlags>;

						/** 
						@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutBindingFlagsCreateInfo">Specification</a> 
						@ingroup APISpec_Resource_Descriptors 
						*/
						struct FlagsCreateInfo : V0::VKStruct_Base<VkDescriptorSetLayoutBindingFlagsCreateInfo, EStructureType::Descriptor_SetLayoutBindingFlags_CreateInfo>
						{
							EType        SType        = STypeEnum;
							const void*        Next         = nullptr  ;
							uint32       BindingCount = 0        ;
							const CreateFlags* BindingFlags = nullptr  ;
						};
					};

					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateFlags">Specification</a>  
					@ingroup APISpec_Resource_Descriptors
					*/
					using CreateFlags = Bitmask<EDescriptorSetLayoutCreateFlag, VkDescriptorSetLayoutCreateFlags>;

					/** 
					@brief Information about the descriptor set layout.
					@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateInfo">Specification</a>  
					@ingroup APISpec_Resource_Descriptors
					*/
					struct CreateInfo : V0::VKStruct_Base<VkDescriptorSetLayoutCreateInfo, EStructureType::Descriptor_SetLayout_CreateInfo>
					{
						EType       SType        = STypeEnum;
						const void*       Next         = nullptr  ;
						CreateFlags Flags       ;
						uint32      BindingCount = 0        ;
						const Binding*    Bindings     = nullptr  ;
					};

					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetLayoutSupport">Specification</a>

					@ingroup APISpec_Resource_Descriptors	
					*/
					struct Support : V0::VKStruct_Base<VkDescriptorSetLayoutSupport, EStructureType::Descriptor_SetLayoutSupport>
					{
						EType SType     = STypeEnum;
						void* Next      = nullptr  ;
						Bool  Supported;

						/** 
						@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDescriptorSetVariableDescriptorCountLayoutSupport">Specification</a>  

						@ingroup APISpec_Resource_Descriptors
						*/
						struct SetVariableCount : V0::VKStruct_Base<VkDescriptorSetVariableDescriptorCountLayoutSupport, EStructureType::Descriptor_SetVariable_Descriptor_CountLayoutSupport>
						{
							EType  SType            = STypeEnum;
							void*  Next             = nullptr  ;
							uint32 MaxVariableCount;
						};
					};

					/**
					* @brief Create a descriptor set layout.
					* 
					* @details
					* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateDescriptorSetLayout">Specification</a> 
					* 
					* @ingroup APISpec_Resource_Descriptors
					* 
					* \param _deviceHandle
					* \param _createInfo
					* \param _allocator
					* \param _setLayout
					* \return 
					*/
					static EResult Create
					(
						LogicalDevice::Handle        _deviceHandle,
						const CreateInfo&                  _createInfo  ,
						const Memory::AllocationCallbacks* _allocator   ,
						Handle&                      _setLayout
					)
					{
						return EResult(vkCreateDescriptorSetLayout(_deviceHandle, _createInfo, *_allocator, &_setLayout));
					}

					/**
					* @brief Destroy a descriptor set layout.
					* 
					* @details
					* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyDescriptorSetLayout">Specification</a> 
					* 
					* @ingroup APISpec_Resource_Descriptors
					* 
					* \param _deviceHandle
					* \param _descriptorSet
					* \param _allocator
					*/
					static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _descriptorSet, const Memory::AllocationCallbacks* _allocator)
					{
						vkDestroyDescriptorSetLayout(_deviceHandle, _descriptorSet, *_allocator);
					}

					/**
					* @brief Query whether a descriptor set layout can be created.
					* 
					* @details
					* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetDescriptorSetLayoutSupport">Specification</a> 
					* 
					* @ingroup APISpec_Resource_Descriptors
					* 
					* \param _deviceHandle
					* \param _createInfo
					* \param _support
					*/
					static void GetSupport(LogicalDevice::Handle _deviceHandle, CreateInfo& _createInfo, Support& _support)
					{
						vkGetDescriptorSetLayoutSupport(_deviceHandle, _createInfo, _support);
					}
				};


				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< @brief Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineLayoutCreateInfo">Specification</a>  
																  @ingroup APISpec_Resource_Descriptors
																  */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineLayoutCreateInfo, EStructureType::Pipeline_Layout_CreateInfo>
				{
					EType                  SType                  = STypeEnum;
					const void*                  Next                   = nullptr  ;
					CreateFlags            Flags                 ;
					uint32                 SetLayoutCount        ;
					const DescriptorSet::Handle* SetLayouts             = nullptr  ;
					uint32                 PushConstantRangeCount = 0        ;
					const PushConstantRange*     PushConstantRanges     = nullptr  ;
				};

				/**
				* @brief Create a pipeline layout.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreatePipelineLayout">Specification</a> 
				* 
				* @ingroup APISpec_Resource_Descriptors
				* 
				* \param _deviceHandle
				* \param _creationSpec
				* \param _allocator
				* \param _pipelineLayout
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle        _deviceHandle  ,
					const CreateInfo&                  _creationSpec  ,
					const Memory::AllocationCallbacks* _allocator     ,
					Handle&                      _pipelineLayout
				)
				{
					return EResult(vkCreatePipelineLayout(_deviceHandle, _creationSpec, *_allocator, &_pipelineLayout));
				}

				/**
				* @brief Destroy a pipeline layout.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyPipelineLayout">Specification</a> 
				* 
				* @ingroup APISpec_Resource_Descriptors
				* 
				* \param _deviceHandle
				* \param _pipelineLayout
				* \param _allocator
				*/
				static void Destroy
				(
					LogicalDevice::Handle        _deviceHandle  ,
					Handle                       _pipelineLayout,
					const Memory::AllocationCallbacks* _allocator
				)
				{
					vkDestroyPipelineLayout(_deviceHandle, _pipelineLayout, *_allocator);
				}
			};

			/** 
			@brief Structure specifying parameters of a newly created pipeline multisample state.
			@ingroup APISpec_Rasterization
			*/
			struct MultiSampleState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSampleMask">Specification</a>  
																  @ingroup APISpec_Rasterization
																  */
				using SampleMask = VkSampleMask;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineMultisampleStateCreateInfo">Specification</a>  
				@ingroup APISpec_Rasterization
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineMultisampleStateCreateInfo, EStructureType::Pipeline_MultisampleState_CreateInfo>
				{
					EType        SType                 = STypeEnum;
					const void*        Next                  = nullptr  ;
					CreateFlags  Flags                ;
					ESampleCount RasterizationSamples ;
					Bool         EnableSampleShading  ;
					float32      MinSampleShading     ;
					const SampleMask*  SampleMask            = nullptr  ;
					Bool         EnableAlphaToCoverage;
					Bool         EnableAlphaToOne     ;
				};
			};

			/** 
			@brief Rasterization is the process by which a primitive is converted to a two-dimensional image. 
			Each point of this image contains associated data such as depth, color, or other attributes.
			@ingroup APISpec_Rasterization
			*/
			struct RasterizationState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCullModeFlags">Specification</a>  
																  @ingroup APISpec_Rasterization
																  */
				using CullModeFlags = Bitmask<ECullModeFlag, VkCullModeFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineRasterizationStateCreateInfo">Specification</a>  
				@ingroup APISpec_Rasterization
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineRasterizationStateCreateInfo, EStructureType::Pipeline_RasterizationState_CreateInfo>
				{
					EType         SType                   = STypeEnum;
					const void*         Next                    = nullptr  ;
					CreateFlags   Flags                  ;
					Bool          EnableDepthClamp       ;
					Bool          EnableRasterizerDiscard;
					EPolygonMode  PolygonMode            ;
					CullModeFlags CullMode               ;
					EFrontFace    FrontFace              ;
					Bool          EnableDepthBias        ;
					float32       DepthBiasConstantFactor;
					float32       DepthBiasClamp         ;
					float32       DepthBiasSlopeFactor   ;
					float32       LineWidth              ;
				};
			};

			/** 
			@brief
			Specialization constants are a mechanism whereby constants in a SPIR-V module can have their constant value specified 
			at the time the VkPipeline is created. This allows a SPIR-V module to have constants that can be modified 
			while executing an application that uses the Vulkan API.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSpecializationMapEntry">Specification</a>

			@ingroup APISpec_Pipelines
			*/
			struct Specialization
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSpecializationMapEntry">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				struct MapEntry : V0::VKStruct_Base<VkSpecializationMapEntry>
				{
					uint32      ConstantID;
					uint32      Offset    ;
					std::size_t Size      ;
				};

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSpecializationInfo">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				struct Info : V0::VKStruct_Base<VkSpecializationInfo>
				{
					uint32      MapEntryCount = 0      ;
					const MapEntry*   MapEntires    = nullptr;
					std::size_t SizeOfData    = 0      ;
					const void*       Data          = nullptr;
				};
			};

			/**
			* @brief Used to handle shader staging within a pipeline, more than one shader can be staged in a pipeline.
			* 
			* @ingroup APISpec_Pipelines
			*/
			struct ShaderStage
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkShaderStageFlags">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				using CreateFlags = Bitmask<EPipelineShaderStageCreateFlag, VkShaderStageFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineShaderStageCreateInfo">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineShaderStageCreateInfo , EStructureType::Pipeline_ShaderStage_CreateInfo>
				{
					EType                 SType          = STypeEnum;
					const void*                 Next           = nullptr  ;
					CreateFlags           Flags         ;
					EShaderStageFlag      Stage         ;
					ShaderModule::Handle  Module        ;
					RoCStr                Name          ;
					const Specialization::Info* Specialization = nullptr  ;
				};
			};

			/** 
			@brief Tessellation involves three pipeline stages. 

			@details 
			First, a tessellation control shader transforms control points of a patch and can produce per-patch data.
			Second, a fixed-function tessellator generates multiple primitives corresponding to a tessellation of the patch in (u,v) or (u,v,w) parameter space. 
			Third, a tessellation evaluation shader transforms the vertices of the tessellated patch, for example to compute their positions and attributes as part of the 
			tessellated surface. The tessellator is enabled when the pipeline contains both a tessellation control shader and a tessellation evaluation shader.

			@ingroup APISpec_Tessellation
			*/
			struct TessellationState
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineTessellationStateCreateFlags">Specification</a>  
				@ingroup APISpec_Tessellation
				*/
				using CreateFlags = Bitmask<EUndefined, VkPipelineTessellationStateCreateFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineTessellationStateCreateInfo">Specification</a>  
				@ingroup APISpec_Tessellation
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineTessellationStateCreateInfo, EStructureType::Pipeline_TessellationState_CreateInfo>
				{
					EType       SType              = STypeEnum;
					const void*       Next               = nullptr  ;
					CreateFlags Flags             ;
					uint32      PatchControlPoints;
				};
			};

			/**
			* @brief .
			* @ingroup APISpec_Fixed-Function_Vertex_Processing
			*/
			struct VertexInputState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkVertexInputAttributeDescription">Specification</a>  
																  @ingroup APISpec_Fixed-Function_Vertex_Processing
																  */
				struct AttributeDescription : V0::VKStruct_Base<VkVertexInputAttributeDescription>
				{
					uint32  Location;
					uint32  Binding ;
					EFormat Format  ;
					uint32  Offset  ;
				};

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkVertexInputBindingDescription">Specification</a>
				@ingroup APISpec_Fixed-Function_Vertex_Processing
				*/
				struct BindingDescription : V0::VKStruct_Base<VkVertexInputBindingDescription>
				{
					uint32           Binding  ;
					uint32           Stride   ;
					EVertexInputRate InputRate;
				};

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineVertexInputStateCreateInfo">Specification</a>  
				@ingroup APISpec_Fixed-Function_Vertex_Processing
				*/
				struct CreateInfo : V0::VKStruct_Base<VkPipelineVertexInputStateCreateInfo, EStructureType::Pipeline_VertexInputState_CreateInfo>
				{
					EType                 SType                         = STypeEnum;
					const void*                 Next                          = nullptr  ;
					CreateFlags           Flags                        ;
					uint32                VertexBindingDescriptionCount = 0        ;
					const BindingDescription*   BindingDescriptions           = nullptr  ;
					uint32                AttributeDescriptionCount     = 0        ;
					const AttributeDescription* AttributeDescription          = nullptr  ;
				};
			};

			/**
			@ingroup APISpec_Fixed-Function_Vertex_Post-Processing

			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vertexpostproc-viewport">Specification</a> 
			*/
			struct ViewportState
			{
				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future use.

																  /** 
																  @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineViewportStateCreateInfo">Specification</a>  
																  @ingroup APISpec_Fixed-Function_Vertex_Post-Processing
																  */
				struct CreateInfo : V0::VKStruct_Base<VkPipelineViewportStateCreateInfo, EStructureType::Pipeline_ViewportState_CreateInfo>
				{
					EType       SType         = STypeEnum;
					const void*       Next          = nullptr  ;
					CreateFlags Flags        ;
					uint32      ViewportCount = 0        ;
					const Viewport*   Viewports     = nullptr  ;
					uint32      ScissorCount  = 0        ;
					const Rect2D*     Scissors      = nullptr  ;
				};
			};

			/**
			* @brief The compute pipeline represents a compute shader.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines-compute">Specification</a> 
			* 
			* @ingroup APISpec_Pipelines
			*/
			struct Compute
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCreateFlags">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				using CreateFlags = Bitmask<EPipelineCreateFlag, VkPipelineCreateFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkComputePipelineCreateInfo">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				struct CreateInfo : V0::VKStruct_Base<VkComputePipelineCreateInfo, EStructureType::ComputePipeline_CreateInfo>
				{
					EType                   SType              = STypeEnum;
					const void*                   Next               = nullptr  ;
					CreateFlags             Flags             ;
					ShaderStage::CreateInfo ShaderStage       ;
					Layout::Handle          Layout            ;
					Pipeline::Handle        BasePipelineHandle;
					sint32                  BasePipelineIndex ;
				};

				/**
				* @brief Create a compute pipeline.
				* 
				* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateComputePipelines">Specification</a> 
				* 
				* @ingroup APISpec_Pipelines
				* 
				* \param _deviceHandle
				* \param _cache
				* \param _createInfoCount
				* \param _createInfos
				* \param _allocator
				* \param _pipelines
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle        _deviceHandle   ,
					Cache::Handle                _cache          ,
					uint32                       _createInfoCount,
					const CreateInfo*                  _createInfos    ,
					const Memory::AllocationCallbacks* _allocator      ,
					Handle*                      _pipelines
				)
				{
					return EResult(vkCreateComputePipelines(_deviceHandle, _cache, _createInfoCount, *_createInfos, *_allocator, _pipelines));
				}
			};

			/**
			* @brief Graphics pipelines consist of multiple shader stages, multiple fixed-function pipeline stages, and a pipeline layout.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines-graphics">Specification</a> 
			* 
			* @ingroup APISpec_Pipelines
			*/
			struct Graphics
			{
				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPipelineCreateFlags">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				using CreateFlags = Bitmask<EPipelineCreateFlag, VkPipelineCreateFlags>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkGraphicsPipelineCreateInfo">Specification</a>  
				@ingroup APISpec_Pipelines
				*/
				struct CreateInfo : V0::VKStruct_Base<VkGraphicsPipelineCreateInfo, EStructureType::GraphicsPipeline_CreateInfo>
				{
					using RenderPass_Handle = VkRenderPass;   // RenderPass::Handle not defined yet. (Defined in VT_RenderPass.hpp)

					EType                           SType              = STypeEnum;
					const void*                           Next               = nullptr  ;
					CreateFlags                     Flags             ;
					uint32                          StageCount         = 0        ;
					const ShaderStage::CreateInfo*        Stages             = nullptr  ;
					const VertexInputState::CreateInfo*   VertexInputState   = nullptr  ;
					const InputAssemblyState::CreateInfo* InputAssemblyState = nullptr  ;
					const TessellationState::CreateInfo*  TessellationState  = nullptr  ;
					const ViewportState::CreateInfo*      ViewportState      = nullptr  ;
					const RasterizationState::CreateInfo* RasterizationState = nullptr  ;
					const MultiSampleState::CreateInfo*   MultisampleState   = nullptr  ;
					const DepthStencilState::CreateInfo*  DepthStencilState  = nullptr  ;
					const ColorBlendState::CreateInfo*    ColorBlendState    = nullptr  ;
					const DynamicState::CreateInfo*       DynamicState       = nullptr  ;
					Pipeline::Layout::Handle        Layout            ;
					RenderPass_Handle               RenderPass        ;
					uint32                          Subpass           ;
					Pipeline::Handle                BasePipelineHandle;
					sint32                          BasePipelineIndex ;
				};

				/**
				* @brief Graphics pipelines can contain multiple shader groups that can be bound individually. \
				* Each shader group behaves as if it was a pipeline using the shader groups state.
				* 
				* @details
				*  When the pipeline is bound by regular means, it behaves as if the state of group 0 is active, 
				* use vkCmdBindPipelineShaderGroupNV to bind an individual shader group. The primary purpose 
				* of shader groups is allowing the device to bind different pipeline state using Device-Generated Commands.
				* 
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#graphics-shadergroups">Specification</a> 
				* 
				* @ingroup APISpec_Pipelines
				*/
				struct ShaderGroup 
				{
					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkGraphicsShaderGroupCreateInfoNV">Specification</a>  
					@ingroup APISpec_Pipelines
					*/
					struct CreateInfo : V0::VKStruct_Base<VkGraphicsShaderGroupCreateInfoNV, EStructureType::GraphicsShaderGroup_CreateInfo_NV>
					{
						EType                          SType             = STypeEnum;
						const void*                          Next              = nullptr  ;
						uint32                         StageCount        = 0        ;
						const ShaderStage::CreateInfo*       Stages            = nullptr  ;
						const VertexInputState::CreateInfo*  VertexInputState  = nullptr  ;
						const TessellationState::CreateInfo* TessellationState = nullptr  ;
					};

					/** 
					@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkGraphicsPipelineShaderGroupsCreateInfoNV">Specification</a>  
					@ingroup APISpec_Pipelines
					*/
					struct MultipleCreateInfo : V0::VKStruct_Base<VkGraphicsPipelineShaderGroupsCreateInfoNV, EStructureType::GraphicsPipeline_ShaderGroups_CreateInfo_NV>
					{
						EType             SType         = STypeEnum;
						const void*             Next          = nullptr  ;
						uint32            GroupCount    = 0        ;
						const CreateInfo*       Groups        = nullptr  ;
						uint32            PipelineCount = 0        ;
						const Pipeline::Handle* Pipelines     = nullptr  ;
					};
				};

				/**
				* @brief Create a graphics pipeline.
				* 
				* @details
				* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateGraphicsPipelines">Specification</a> 
				* 
				* @ingroup APISpec_Pipelines
				* 
				* \param _deviceHandle
				* \param _pipelineCache
				* \param _createInfoCount
				* \param _createInfos
				* \param _allocator
				* \param _pipelines
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle        _deviceHandle   ,
					Cache::Handle                _pipelineCache  ,
					uint32                       _createInfoCount,
					const CreateInfo*                  _createInfos    ,
					const Memory::AllocationCallbacks* _allocator      ,
					Handle*                      _pipelines
				)
				{
					return EResult(vkCreateGraphicsPipelines(_deviceHandle, _pipelineCache, _createInfoCount, *_createInfos, *_allocator, _pipelines));
				}
			};

			/**
			* @brief Destroy a pipeline object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyPipeline">Specification</a> 
			* 
			* @ingroup APISpec_Pipelines
			* 
			* \param _deviceHandle
			* \param _pipeline
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _pipeline, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyPipeline(_deviceHandle, _pipeline, *_allocator);
			}
		};

		/**
		using Typedef of descriptor set layout in more recognizable form.
		*/
		using DescriptorSetLayout = Pipeline::Layout::DescriptorSet;

		/** 
		using Typedef of pipeline cache in a more recognizable form.
		*/
		using PipelineCache = Pipeline::Cache;

		/**
		@brief Typedef pipeline layout in more recognizable form.
		*/
		using PipelineLayout = Pipeline::Layout;

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief A monolithic object describing the entire graphics, raytracing, or compute pipeline.
		*/
		struct Pipeline : public V1::Pipeline
		{
			using Parent = V1::Pipeline;

			/**
			@brief Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application.

			@details
			Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines.
			Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents,
			and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation.
			Applications can manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.
			*/
			struct Cache : public Parent::Cache
			{
				using Parent = Parent::Cache;

				/**
				* @brief Create a pipeline cache (Uses the default allocator).
				* 
				* \param _deviceHandle
				* \param _createInfo
				* \param _pipelineCache
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle  _deviceHandle ,
					const CreateInfo&            _createInfo   ,
					Cache::Handle&         _pipelineCache
				)
				{
					return Parent::Create(_deviceHandle, _createInfo, Memory::DefaultAllocator, _pipelineCache);
				}

				using Parent::Create;

				/**
				* @brief Destroy a pipeline cache.
				* 
				* @details

				* \param _deviceHandle
				* \param _cache
				*/
				static void Destroy(LogicalDevice::Handle _deviceHandle, Cache::Handle _cache)
				{
					Parent::Destroy(_deviceHandle, _cache, Memory::DefaultAllocator);
				}

				using Parent::Destroy;
			};

			/**
			@brief Access to descriptor sets from a pipeline is accomplished through a pipeline layout.
			*/
			struct Layout : public Parent::Layout
			{
				using Parent = Parent::Layout;

				/**
				Descriptors are grouped together into descriptor set objects.

				@details
				A descriptor set object is an opaque object containing storage for a set of descriptors,
				where the types and number of descriptors is defined by a descriptor set layout.
				*/
				struct DescriptorSet : public Parent::DescriptorSet
				{
					using Parent = Parent::DescriptorSet;

					/**
					* @brief Create a descriptor set layout.
					* 
					* @details
					* 
					* \param _deviceHandle
					* \param _createInfo
					* \param _setLayout
					* \return 
					*/
					static EResult Create
					(
						LogicalDevice::Handle _deviceHandle,
						const CreateInfo&           _createInfo  ,
						Handle&               _setLayout
					)
					{
						return Parent::Create(_deviceHandle, _createInfo, Memory::DefaultAllocator, _setLayout);
					}

					using Parent::Create;

					/**
					* @brief Destroy a descriptor set layout.
					* 
					* @details
					* 
					* \param _deviceHandle
					* \param _descriptorSet
					*/
					static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _descriptorSet)
					{
						Parent::Destroy(_deviceHandle, _descriptorSet, Memory::DefaultAllocator);
					}

					using Parent::Destroy;
				};

				/**
				* @brief Create a pipeline layout.
				* 
				* @details
				* 
				* \param _deviceHandle
				* \param _creationSpec
				* \param _pipelineLayout
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle _deviceHandle  ,
					const CreateInfo&           _creationSpec  ,
					Handle&               _pipelineLayout
				)
				{
					return Parent::Create(_deviceHandle, _creationSpec, Memory::DefaultAllocator, _pipelineLayout);
				}

				using Parent::Create;

				/**
				* @brief Destroy a pipeline layout.
				* 
				* @details
				* 
				* \param _deviceHandle
				* \param _pipelineLayout
				*/
				static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _pipelineLayout)
				{
					Parent::Destroy(_deviceHandle, _pipelineLayout, Memory::DefaultAllocator);
				}

				using Parent::Destroy;
			};

			struct Compute : public Parent::Compute
			{
				using Parent = Parent::Compute;

				/**
				* @brief Create a compute pipeline.
				* 
				* @details 
				* 
				* \param _deviceHandle
				* \param _cache
				* \param _createInfoCount
				* \param _createInfos
				* \param _pipelines
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle        _deviceHandle   ,
					Cache::Handle                _cache          ,
					uint32                       _createInfoCount,
					const CreateInfo*                  _createInfos    ,
					Handle*                      _pipelines
				)
				{
					return Parent::Create(_deviceHandle, _cache, _createInfoCount, _createInfos, Memory::DefaultAllocator, _pipelines);
				}

				using Parent::Create;
			};

			struct Graphics : public Parent::Graphics
			{
				using Parent = Parent::Graphics;

				/**
				* @brief Create a graphics pipeline.
				* 
				* @details
				* 
				* \param _deviceHandle
				* \param _pipelineCache
				* \param _createInfoCount
				* \param _createInfos
				* \param _pipelines
				* \return 
				*/
				static EResult Create
				(
					LogicalDevice::Handle _deviceHandle   ,
					Cache::Handle         _pipelineCache  ,
					uint32                _createInfoCount,
					const CreateInfo*           _createInfos    ,
					Handle*               _pipelines
				)
				{
					return Parent::Create(_deviceHandle, _pipelineCache, _createInfoCount, _createInfos, Memory::DefaultAllocator, _pipelines);
				}

				using Parent::Create;
			};

			/**
			* @brief Destroy a pipeline object.
			* 
			* @details
			* 
			* \param _deviceHandle
			* \param _pipeline
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _pipeline)
			{
				Parent::Destroy(_deviceHandle, _pipeline, Memory::DefaultAllocator);
			}
		};

		/**
		using Typedef of descriptor set layout in more recognizable form.
		*/
		using DescriptorSetLayout = Pipeline::Layout::DescriptorSet;

		/** 
		using Typedef of pipeline cache in a more recognizable form.
		*/
		using PipelineCache = Pipeline::Cache;

		/**
		@brief Typedef pipeline layout in more recognizable form.
		*/
		using PipelineLayout = Pipeline::Layout;

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief A monolithic object describing the entire graphics, raytracing, or compute pipeline.
		*/
		class Pipeline : public V2::Pipeline
		{
		public:
			using Parent = V2::Pipeline;

			/**
			@brief Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application.

			@details
			Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines.
			Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents,
			and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation.
			Applications can manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.
			*/
			class Cache : public Parent::Cache
			{
			public:
				using Parent = V2::Pipeline::Cache;

				/**
				@brief Default constructor.
				*/
				Cache() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
				{}

				/**
				@brief Logical device specified.
				*/
				Cache(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
				{}

				/**
				@brief Logical device and allocator specified.
				*/
				Cache(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
				{}

				/**
				@brief Performs a move operation to transfer ownership of the device object to this host object.
				*/
				Cache(Cache&& _other) noexcept :
					handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
				{
					_other.handle    = Null<Handle>            ;
					_other.allocator = Memory::DefaultAllocator;
					_other.device    = nullptr                 ;
				}

				/**
				@brief Destroys the cache if handle is null.
				*/
				~Cache()
				{
					if (handle != Null<Handle>) Destroy();
				}

				/**
				@brief Create a cache.
				*/
				EResult Create(const CreateInfo& _info)
				{
					if (device == nullptr) return EResult::Not_Ready;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Create a cache (logical device specified).
				*/
				EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
				{
					device = &_device;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Create a cache (logical device and allocator specified).
				*/
				EResult Create(const LogicalDevice& _device, CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
				{
					device    = &_device   ;
					allocator = &_allocator;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Destroy a cache.
				*/
				void Destroy()
				{
					Parent::Destroy(*device, handle, allocator);

					handle = Null<Handle>;
					device = nullptr     ;
				}

				/**
				@brief Implicit conversion to give a reference to its handle.
				*/
				operator Handle&()
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a readonly reference to its handle.
				*/
				operator const Handle&() const
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a pointer to its handle.
				*/
				operator const Handle*() const
				{
					return &handle;
				}

				/**
				@brief Checks to see if its the same object by checking to see if its the same handle.
				*/
				bool operator== (const Cache& _other) const
				{
					return handle == _other.handle;
				}

				/**
				@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
				*/
				Cache& operator= (Cache&& _other) noexcept
				{
					if (this == &_other)
						return *this;

					handle    = std::move(_other.handle   );
					allocator = std::move(_other.allocator);
					device    = std::move(_other.device   );

					_other.handle    = Null<Handle>            ;
					_other.allocator = Memory::DefaultAllocator;
					_other.device    = nullptr                 ;

					return *this;
				}

			protected:

				Handle handle;

				const Memory::AllocationCallbacks* allocator;

				const LogicalDevice* device;
			};

			/**
			@brief Access to descriptor sets from a pipeline is accomplished through a pipeline layout.
			*/
			class Layout : public Parent::Layout
			{
			public:
				using Parent = V2::Pipeline::Layout;

				/**
				@brief Descriptors are grouped together into descriptor set objects.

				@details
				A descriptor set object is an opaque object containing storage for a set of descriptors,
				where the types and number of descriptors is defined by a descriptor set layout.
				*/
				class DescriptorSet : public Parent::DescriptorSet
				{
				public:
					using Parent = V2::Pipeline::Layout::DescriptorSet;

					/**
					@brief Default constructor.
					*/
					DescriptorSet() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
					{}

					/**
					@brief Specify the logical device.
					*/
					DescriptorSet(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
					{}

					/**
					@brief Specify the logical device and allocator.
					*/
					DescriptorSet(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) :
						handle(Null<Handle>), allocator(&_allocator), device(&_device)
					{}

					/**
					@brief Performs a move operation to transfer ownership of the device object to this host object.
					*/
					DescriptorSet(DescriptorSet&& _other) noexcept :
						handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
					{
						_other.handle    = Null<Handle>            ;
						_other.allocator = Memory::DefaultAllocator;
						_other.device    = nullptr                 ;
					}

					/**
					@brief Destroy the descriptor set layout if the handle is null.
					*/
					~DescriptorSet()
					{
						if (handle != Null<Handle>) Destroy();
					}

					/**
					@brief Assign the create info.
					*/
					void Assign(const CreateInfo& _info)
					{
						info = _info;

						Parent::GetSupport(*device, info, support);
					}

					/**
					@brief Assign the device and create info.
					*/
					void Assign(const LogicalDevice& _device, const CreateInfo& _info)
					{
						device    = &_device                ;
						info      = _info                   ;

						Parent::GetSupport(*device, info, support);
					}

					/**
					@brief Assign the logical device, create info, and allocator.
					*/
					void Assign(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
					{
						device    = &_device   ;
						info      = _info      ;
						allocator = &_allocator;

						Parent::GetSupport(*device, info, support);
					}

					/**
					@brief Create the descriptor set layout.
					*/
					EResult Create()
					{
						if (device == nullptr) return EResult::Not_Ready;

						return Parent::Create(*device, info, allocator, handle);
					}

					/**
					@brief Destroy the descriptor set layout.
					*/
					void Destroy()
					{
						Parent::Destroy(*device, handle, allocator);

						handle    = Null<Handle>            ;
						allocator = Memory::DefaultAllocator;
						device    = nullptr                 ;
					}

					/**
					@brief Provides the layout support.
					*/
					const Support& GetSupport() const
					{
						return support;
					}

					/**
					@brief Implicit conversion to give a reference to its handle.
					*/
					operator Handle&()
					{
						return handle;
					}

					/**
					@brief Implicit conversion to give a readonly reference to its handle.
					*/
					operator const Handle&() const
					{
						return handle;
					}

					/**
					@brief Implicit conversion to give a pointer to its handle.
					*/
					operator const Handle*() const
					{
						return &handle;
					}

					/**
					@brief Checks to see if its the same object by checking to see if its the same handle.
					*/
					bool operator== (const DescriptorSet& _other) const
					{
						return handle == _other.handle;
					}

					/**
					@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
					*/
					DescriptorSet& operator= (DescriptorSet&& _other) noexcept
					{
						if (this == &_other)
							return *this;

						handle    = std::move(_other.handle   );
						allocator = std::move(_other.allocator);
						device    = std::move(_other.device   );

						_other.handle    = Null<Handle>            ;
						_other.allocator = Memory::DefaultAllocator;
						_other.device    = nullptr                 ;

						return *this;
					}

				protected:

					Handle handle;

					const Memory::AllocationCallbacks* allocator;

					CreateInfo info;

					const LogicalDevice* device;

					Support support;
				};

				/**
				@brief Default constructor.
				*/
				Layout() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
				{}

				/**
				@brief Specify logical device.
				*/
				Layout(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
				{}

				/**
				@brief Specify logical device and allocator.
				*/
				Layout(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
				{}

				/**
				@brief Performs a move operation to transfer ownership of the device object to this host object.
				*/
				Layout(Layout&& _other) noexcept :
					handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
				{
					_other.handle    = Null<Handle>            ;
					_other.allocator = Memory::DefaultAllocator;
					_other.device    = nullptr                 ;
				}

				/**
				@brief Destroy the pipeline layout if the handle is null.
				*/
				~Layout()
				{
					if (handle != Null<Handle>) Destroy();
				}

				/**
				@brief Create a pipeline layout.
				*/
				EResult Create(const CreateInfo& _info)
				{
					if (device == nullptr) return EResult::Not_Ready;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Create the pipeline layout (logical device specified).
				*/
				EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
				{
					device = &_device;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Create the pipeline layout (logical device and allocator specified).
				*/
				EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
				{
					device    = &_device   ;
					allocator = &_allocator;

					return Parent::Create(*device, _info, allocator, handle);
				}

				/**
				@brief Destroy the pipeline layout.
				*/
				void Destroy()
				{
					Parent::Destroy(*device, handle, allocator);
				}

				/**
				@brief Implicit conversion to give a reference to its handle.
				*/
				operator Handle&()
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a readonly reference to its handle.
				*/
				operator const Handle&() const
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a pointer to its handle.
				*/
				operator const Handle*() const
				{
					return &handle;
				}

				/**
				@brief Checks to see if its the same object by checking to see if its the same handle.
				*/
				bool operator== (const Layout& _other) const
				{
					return handle == _other.handle;
				}

				/**
				@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
				*/
				Layout& operator= (Layout&& _other) noexcept
				{
					if (this == &_other)
						return *this;

					handle    = std::move(_other.handle   );
					allocator = std::move(_other.allocator);
					device    = std::move(_other.device   );

					_other.handle    = Null<Handle>            ;
					_other.allocator = Memory::DefaultAllocator;
					_other.device    = nullptr                 ;

					return *this;
				}

			protected:

				Handle handle;

				const Memory::AllocationCallbacks* allocator;

				const LogicalDevice* device;
			};

			/**
			@brief Default constructor.
			*/
			Pipeline() : handle(Null<Handle>), cache(nullptr), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specify logical device.
			*/
			Pipeline(const LogicalDevice& _device) : handle(Null<Handle>), cache(nullptr), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Specify logical device and cache.
			*/
			Pipeline(const LogicalDevice& _device, const Cache& _cache) : handle(Null<Handle>), cache(&_cache), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Specify logical device and allocator.
			*/
			Pipeline(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), cache(nullptr), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Specify the logical device, cache, and allocator.
			*/	
			Pipeline(const LogicalDevice& _device, const Cache& _cache, const Memory::AllocationCallbacks& _allocator) : 
				handle(Null<Handle>), cache(&_cache), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Pipeline(Pipeline&& _other) noexcept :
				handle(std::move(_other.handle)), cache(std::move(_other.cache)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.cache     = nullptr                 ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the pipeline if the handle is not null.
			*/
			~Pipeline()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Destroy the pipeline.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Pipeline& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Pipeline& operator= (Pipeline&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				cache     = std::move(_other.cache    );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.cache     = nullptr                 ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Cache* cache;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief The compute pipeline represents a compute shader.
		*/
		class ComputePipeline : public Pipeline
		{
		public:

			using CreateInfo = Parent::Compute::CreateInfo;

			/**
			@brief Assign the logical device, cache, allocator and handle to the compute pipeline.
			*/
			void Assign
			(
				const LogicalDevice&               _device   ,
				const Cache&                       _cache    ,
				const Memory::AllocationCallbacks* _allocator,
				Handle                       _handle
			)
			{
				handle    = _handle   ;
				allocator = _allocator;
				cache     = &_cache   ;
				device    = &_device  ;
			}

			/**
			@brief Create a compute pipeline.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Parent::Compute::Create
				(
					*device            ,
					Null<Cache::Handle>,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create a compute pipeline (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device    = &_device;
				cache     = nullptr ;

				return Parent::Parent::Compute::Create
				(
					*device            ,
					Null<Cache::Handle>,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create a compute pipeline (logical device and cache specified).
			*/
			EResult Create(const LogicalDevice& _device, const Cache& _cache, const CreateInfo& _info)
			{
				device    = &_device;
				cache     = &_cache ;

				return Parent::Parent::Compute::Create
				(
					*device  ,
					*cache   ,
					1        ,
					&_info   ,
					allocator,
					&handle
				);
			}

			/**
			@brief Create a compute pipeline (logical device, cache, and allocator specified).
			*/
			EResult Create
			(
				const LogicalDevice&               _device   , 
				const Cache&                       _cache    , 
				const CreateInfo&                  _info     ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				device    = &_device  ;
				cache     = &_cache   ;
				allocator = _allocator;

				return Parent::Parent::Compute::Create
				(
					*device  ,
					*cache   ,
					1        ,
					&_info   ,
					allocator,
					&handle
				);
			}

			/**
			@brief Create multiple compute pipelines that will be returned by the given dynamic array container of _pipelines.
			*/
			static EResult Create
			(
				const LogicalDevice&                 _device         ,
				const Cache&                         _cache          ,
				uint32                         _createInfoCount,
				const CreateInfo*                    _createInfos    ,
				const Memory::AllocationCallbacks*   _allocator      ,
				DynamicArray<ComputePipeline>& _pipelines
			)
			{
				_pipelines.resize(_createInfoCount);

				Handle* handles;

				EResult returnCode = 
					Parent::Parent::Compute::Create
					(
					_device         ,
					_cache          ,
					_createInfoCount,
					_createInfos    ,
					_allocator      ,
					handles
					);

				if (returnCode != EResult::Success) return returnCode;

				int index = 0;

				for (auto& pipeline : _pipelines)
				{
					pipeline.Assign(_device, _cache, _allocator, handles[index]);
				}

				return returnCode;
			}
		};

		/**
		@brief Graphics pipelines consist of multiple shader stages, multiple fixed-function pipeline stages, and a pipeline layout.
		*/
		class GraphicsPipeline : public Pipeline
		{
		public:
			using CreateInfo = Parent::Graphics::CreateInfo;

			/**
			@brief Assign the logical device, cache, allocator and handle to the graphics pipeline.
			*/
			void Assign
			(
				const LogicalDevice&               _device   ,
				const Cache&                       _cache    ,
				const Memory::AllocationCallbacks* _allocator,
				Handle                       _handle
			)
			{
				handle    = _handle   ;
				allocator = _allocator;
				cache     = &_cache   ;
				device    = &_device  ;
			}

			/**
			@brief Create a graphics pipeline.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Parent::Graphics::Create
				(
					*device            ,
					Null<Cache::Handle>,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create a graphics pipeline (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device    = &_device;
				cache     = nullptr ;

				return Parent::Parent::Graphics::Create
				(
					*device            ,
					Null<Cache::Handle>,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create a graphics pipeline (logical device and cache specified).
			*/
			EResult Create(const LogicalDevice& _device, Cache& _cache, const CreateInfo& _info)
			{
				device    = &_device;
				cache     = &_cache ;

				return Parent::Parent::Graphics::Create
				(
					*device,
					*cache             ,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create a graphics pipeline (logical device, cache, and allocator specified).
			*/
			EResult Create
			(
				const LogicalDevice&               _device   , 
				const Cache&                       _cache    , 
				CreateInfo&                  _info     ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				device    = &_device  ;
				cache     = &_cache   ;
				allocator = _allocator;

				return Parent::Parent::Graphics::Create
				(
					*device            ,
					*cache             ,
					1                  ,
					&_info             ,
					allocator          ,
					&handle
				);
			}

			/**
			@brief Create multiple graphics pipelines that will be returned by the given dynamic array container of _pipelines.
			*/
			static EResult Create
			(
				const LogicalDevice&                  _device         ,
				const Cache&                          _cache          ,
				uint32                          _createInfoCount,
				const CreateInfo*                     _createInfos    ,
				const Memory::AllocationCallbacks*    _allocator      ,
				DynamicArray<GraphicsPipeline>& _pipelines
			)
			{
				_pipelines.resize(_createInfoCount);

				Handle* handles;

				EResult returnCode = 
					Parent::Parent::Graphics::Create
					(
					_device         ,
					_cache          ,
					_createInfoCount,
					_createInfos    ,
					_allocator      ,
					handles
					);

				if (returnCode != EResult::Success) return returnCode;

				int index = 0;

				for (auto& pipeline : _pipelines)
				{
					pipeline.Assign(_device, _cache, _allocator, handles[index]);
				}

				return returnCode;
			}
		};

		/**
		using Typedef of descriptor set layout in more recognizable form.
		*/
		using DescriptorSetLayout = Pipeline::Layout::DescriptorSet;

		/** 
		using Typedef of pipeline cache in a more recognizable form.
		*/
		using PipelineCache = Pipeline::Cache;

		/**
		@brief Typedef pipeline layout in more recognizable form.
		*/
		using PipelineLayout = Pipeline::Layout;

		/** @} */
	}
}




/*!
@file VT_RenderPass.hpp

@brief Vaulted Thermals: Render Pass

@details

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		* @brief Render passes operate in conjunction with framebuffers. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.
		* 
		* @details
		* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_framebuffers">Specification</a>
		* 
		* @ingroup APISpec_Render_Pass
		*/
		struct Framebuffer
		{
			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFramebuffer">Specification</a>  
			@ingroup APISpec_Render_Pass
			*/
			using Handle = VkFramebuffer;

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFramebufferCreateFlags">Specification</a>  
			@ingroup APISpec_Render_Pass
			*/
			using CreateFlags = Bitmask<EFrameBufferCreateFlag, VkFramebufferCreateFlags>;

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkFramebufferCreateInfo">Specification</a>  
			@ingroup APISpec_Render_Pass
			*/
			struct CreateInfo : V0::VKStruct_Base<VkFramebufferCreateInfo, EStructureType::Framebuffer_CreateInfo>
			{
				using RenderPass_Handle = VkRenderPass;   // RenderPass::Handle not defined yet. (Defined later in the file)

				EType              SType           = STypeEnum;
				const void*              Next            = nullptr  ;
				CreateFlags        Flags          ;
				RenderPass_Handle  RenderPass     ;
				uint32             AttachmentCount = 0        ;
				const ImageView::Handle* Attachments     = nullptr  ;
				uint32             Width          ;
				uint32             Height         ;
				uint32             Layers         ;
			};

			/**
			* @brief Creates a framebuffer.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateFramebuffer">Specification</a> 
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* \param _deviceHanle
			* \param _creationSpec
			* \param _allocator
			* \param _framebuffer
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHanle ,
				const CreateInfo&                  _creationSpec,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _framebuffer
			)
			{
				return EResult(vkCreateFramebuffer(_deviceHanle, _creationSpec.operator const VkFramebufferCreateInfo*(), _allocator->operator const VkAllocationCallbacks*(), &_framebuffer));
			}

			/**
			* @brief Destroy a framebuffer.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyFramebuffer">Specification</a> 
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* \param _deviceHandle
			* \param _framebuffer
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _framebuffer, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyFramebuffer(_deviceHandle, _framebuffer, _allocator->operator const VkAllocationCallbacks*());
			}
		};

		/**
		* @brief A render pass represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses.
		* 
		* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass">Specification</a> 
		* 
		* @ingroup APISpec_Render_Pass
		*/
		struct RenderPass
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkRenderPass">Specification</a> @ingroup APISpec_Render_Pass */
			using Handle = VkRenderPass;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentDescriptionFlags">Specification</a> @ingroup APISpec_Render_Pass */
			using AttachmentDescriptionFlags = Bitmask<EAttachmentDescriptionFlag, VkAttachmentDescriptionFlags>;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubpassDescriptionFlags">Specification</a> @ingroup APISpec_Render_Pass */
			using SubpassDesriptionFlags     = Bitmask<ESubpassDescriptionFlag   , VkSubpassDescriptionFlags   >;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkRenderPassCreateFlags">Specification</a> @ingroup APISpec_Render_Pass */
			using CreateFlags                = Bitmask<EUndefined                , VkRenderPassCreateFlags     >;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentDescription">Specification</a> @ingroup APISpec_Render_Pass */
			struct AttachmentDescription : V0::VKStruct_Base<VkAttachmentDescription>
			{
				AttachmentDescriptionFlags Flags         ;
				EFormat                    Format        ;
				ESampleCount               Samples       ;
				EAttachmentLoadOperation   LoadOp        ;
				EAttachmentStoreOperation  StoreOp       ;
				EAttachmentLoadOperation   StencilLoadOp ;
				EAttachmentStoreOperation  StencilStoreOp;
				EImageLayout               InitialLayout ;
				EImageLayout               FinalLayout   ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkAttachmentReference">Specification</a> @ingroup APISpec_Render_Pass */
			struct AttachmentReference : V0::VKStruct_Base<VkAttachmentReference>
			{
				uint32       Attachment;
				EImageLayout Layout    ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkRenderPassBeginInfo">Specification</a> @ingroup APISpec_Render_Pass */
			struct BeginInfo : V0::VKStruct_Base<VkRenderPassBeginInfo, EStructureType::RenderPass_BeginInfo>
			{
				EType               SType           = STypeEnum;
				const void*               Next            = nullptr  ;
				RenderPass::Handle  RenderPass     ;
				Framebuffer::Handle Framebuffer    ;
				Rect2D              RenderArea     ;
				uint32              ClearValueCount;
				const ClearValue*         ClearValues     = nullptr  ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubpassDescription">Specification</a> @ingroup APISpec_Render_Pass */
			struct SubpassDescription : V0::VKStruct_Base<VkSubpassDescription>
			{
				SubpassDesriptionFlags Flags                  ;
				EPipelineBindPoint     PipelineBindPoint      ;
				uint32                 InputAttachmentCount   ;
				const AttachmentReference*   InputAttachments        = nullptr;
				uint32                 ColorAttachmentCount   ;
				const AttachmentReference*   ColorAttachments        = nullptr;
				const AttachmentReference*   ResolveAttachments      = nullptr;
				const AttachmentReference*   DepthStencilAttachment  = nullptr;
				uint32                 PreserveAttachmentCount;
				const uint32*                PreserveAttachments     = nullptr;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubpassDependency">Specification</a> @ingroup APISpec_Render_Pass */
			struct SubpassDependency : V0::VKStruct_Base<VkSubpassDependency>
			{
				uint32               SourceSubpass        ;
				uint32               DestinationSubpass   ;
				Pipeline::StageFlags SourceStageMask      ;
				Pipeline::StageFlags DestinationStageMask ;
				AccessFlags          SourceAccessMask     ;
				AccessFlags          DestinationAccessMask;
				DependencyFlags      DependencyFlags      ;
			};

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkRenderPassCreateInfo">Specification</a> @ingroup APISpec_Render_Pass */
			struct CreateInfo : V0::VKStruct_Base<VkRenderPassCreateInfo, EStructureType::RenderPass_CreateInfo>
			{
				EType                  SType           = STypeEnum;
				const void*                  Next            = nullptr  ;
				CreateFlags            Flags          ;
				uint32                 AttachmentCount = 0        ;
				const AttachmentDescription* Attachments     = nullptr  ;
				uint32                 SubpassCount    = 0        ;
				const SubpassDescription*    Subpasses       = nullptr  ;
				uint32                 DependencyCount = 0        ;
				const SubpassDependency*     Dependencies    = nullptr  ;
			};

			/**
			* @brief Create a render pass.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass-creation">Specification</a> 
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _renderPass
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _createInfo  ,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _renderPass
			)
			{
				return EResult(vkCreateRenderPass(_deviceHandle, _createInfo.operator const VkRenderPassCreateInfo*(), _allocator->operator const VkAllocationCallbacks*(), &_renderPass));
			}

			/**
			* @brief Destroy a render pass.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyRenderPass">Specification</a> 
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* \param _deviceHandle
			* \param _renderPass
			* \param _allocator
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _renderPass, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroyRenderPass(_deviceHandle, _renderPass, _allocator->operator const VkAllocationCallbacks*());
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief Render passes operate in conjunction with framebuffers. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.
		*/
		struct Framebuffer : public V1::Framebuffer
		{
			using Parent = V1::Framebuffer;

			/**
			* @brief Creates a framebuffer.
			* 
			* @details
			* 
			* \param _deviceHanle
			* \param _creationSpec
			* \param _framebuffer
			* \return 
			*/
			static EResult Create(LogicalDevice::Handle _deviceHanle, const CreateInfo& _creationSpec, Handle& _framebuffer)
			{
				return Parent::Create(_deviceHanle, _creationSpec, Memory::DefaultAllocator, _framebuffer);
			}

			using Parent::Create;

			/**
			* @brief Destroy a framebuffer.
			* 
			* @details
			* 
			* \param _deviceHandle
			* \param _framebuffer
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _framebuffer)
			{
				Parent::Destroy(_deviceHandle, _framebuffer, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/**
		@brief A render pass represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses.
		*/
		struct RenderPass : public V1::RenderPass
		{
			using Parent = V1::RenderPass;


			/**
			@brief Offers a default constructor.
			*/
			struct SubpassDescription : public Parent::SubpassDescription
			{
				SubpassDescription()
				{
					InputAttachmentCount    = 0;
					InputAttachments        = nullptr;
					ColorAttachmentCount    = 0;
					ColorAttachments        = nullptr;
					ResolveAttachments      = nullptr;
					DepthStencilAttachment  = nullptr;
					PreserveAttachmentCount = 0;
					PreserveAttachments     = nullptr;
				}
			};

			/**
			* @brief Create a render pass. (Default Allocator)
			* 
			* @details
			* 
			* @ingroup 
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _renderPass
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle _deviceHandle,
				const CreateInfo&           _createInfo  ,
				Handle&               _renderPass
			)
			{
				return Parent::Create(_deviceHandle, _createInfo, Memory::DefaultAllocator, _renderPass);
			}

			using Parent::Create;

			/**
			* @brief Destroy a render pass. (Default Allocator)
			* 
			* @details
			* 
			* @ingroup 
			* 
			* \param _deviceHandle
			* \param _renderPass
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _renderPass)
			{
				Parent::Destroy(_deviceHandle, _renderPass, Memory::DefaultAllocator);
			}

			using Parent::Destroy;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief Render passes operate in conjunction with framebuffers. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Framebuffer : public V2::Framebuffer
		{
		public:
			using Parent = V2::Framebuffer;

			/**
			@brief Default constructor.
			*/
			Framebuffer() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			Framebuffer(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			Framebuffer(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Framebuffer(Framebuffer&& _other) noexcept :
				handle(_other.handle), allocator(_other.allocator), device(_other.device)
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy the framebuffer.
			*/
			~Framebuffer()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create the framebuffer.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create the framebuffer (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create the framebuffer (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice* _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = _device    ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy the framebuffer.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Framebuffer& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Framebuffer& operator= (Framebuffer&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = _other.handle   ;
				allocator = _other.allocator;
				device    = _other.device   ;

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/**
		@brief A render pass represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class RenderPass : public V2::RenderPass
		{
		public:
			using Parent = V2::RenderPass;

			/**
			@brief Default constructor.
			*/
			RenderPass() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Logical device specified.
			*/
			RenderPass(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Logical device and allocator specified.
			*/
			RenderPass(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			RenderPass(RenderPass&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;	
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy a renderpass.
			*/
			~RenderPass()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Create a render pass.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a render pass (logical device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a render pass (logical device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a render pass.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const RenderPass& _other)
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			RenderPass& operator= (RenderPass&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}



/*!
@file VT_Command.hpp

@brief Vaulted Thermals: Command Buffers

@details

<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#commandbuffers">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@brief Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#commandbuffers">Specification</a> 

		@ingroup APISpec_Command_Buffers
		*/
		struct CommandBuffer
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBuffer">Specification</a> @ingroup APISpec_Command_Buffers */
			using Handle = VkCommandBuffer;

			using EBufferLevel = ECommandBufferLevel;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueryControlFlags">Specification</a> @ingroup APISpec_Queries */
			using QueryControlFlags           = Bitmask<EQueryControlFlags         , VkQueryControlFlags          >;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkQueryPipelineStatisticFlags">Specification</a> @ingroup APISpec_Queries */
			using QueryPipelineStatisticFlags = Bitmask<EQueryPipelineStatisticFlag, VkQueryPipelineStatisticFlags>;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferResetFlags">Specification</a> @ingroup APISpec_Command_Buffers */
			using ResetFlags                  = Bitmask<ECommandBufferResetFlag    , VkCommandBufferResetFlags    >;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferUsageFlags">Specification</a> @ingroup APISpec_Command_Buffers */
			using UsageFlags                  = Bitmask<ECommandBufferUsageFlag    , VkCommandBufferUsageFlags    >;


			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkBufferImageCopy">Specification</a> 
			@ingroup APISpec_Copy_Commands 
			*/
			struct BufferImageRegion : V0::VKStruct_Base<VkBufferImageCopy>
			{
				DeviceSize               BufferOffset      = Memory::ZeroOffset;
				uint32                   BufferRowLength   = 0                 ;
				uint32                   BufferImageHeight = 0                 ;
				Image::SubresourceLayers ImageSubresource ;
				Offset3D                 ImageOffset      ;
				Extent3D                 ImageExtent      ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferInheritanceInfo">Specification</a> 
			@ingroup APISpec_Command_Buffers
			*/
			struct InheritanceWindow : V0::VKStruct_Base<VkCommandBufferInheritanceInfo, EStructureType::CommandBuffer_InheritanceInfo>
			{
				EType                       SType                = STypeEnum                ;
				const void*                       Next                 = nullptr                  ;
				RenderPass::Handle          RenderPass           = Null<RenderPass::Handle> ;
				uint32                      Subpass              = 0                        ;
				Framebuffer::Handle         Framebuffer          = Null<Framebuffer::Handle>;
				Bool                        OcclusionQueryEnable = false                    ;
				QueryControlFlags           QueryFlags          ;
				QueryPipelineStatisticFlags PipelineStatistics  ;


				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferInheritanceConditionalRenderingInfoEXT">Specification</a>

				@ingroup APISpec_Command_Buffers
				*/
				struct ConditionalRenderingInfo : V0::VKStruct_Base<VkCommandBufferInheritanceConditionalRenderingInfoEXT, EStructureType::CommandBuffer_Inheritance_ConditionalRendering_Info_EXT>
				{
					EType SType  = STypeEnum;
					const void* Next   = nullptr  ;
					Bool  Enable = false    ;

					bool operator== (const ConditionalRenderingInfo& _other) { return Next == _other.Next && Enable == _other.Enable ? true : false; }
					bool operator!= (const ConditionalRenderingInfo& _other) { return Next != _other.Next || Enable != _other.Enable ? true : false; }
				};

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferInheritanceRenderPassTransformInfoQCOM">Specification</a> 

				@ingroup APISpec_Command_Buffers
				*/
				struct PassTransformInfo : V0::VKStruct_Base
					<VkCommandBufferInheritanceRenderPassTransformInfoQCOM, EStructureType::CommandBufferInheritance_RenderPassTransform_Info_QCOM>
				{
					EType                 SType      = STypeEnum                      ;
					void*                 Next       = nullptr                        ;
					ESurfaceTransformFlag Transform  = ESurfaceTransformFlag::Identity;
					Rect2D                RenderArea;
				};
			};	

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferBeginInfo">Specification</a>

			@ingroup APISpec_Command_Buffers
			*/
			struct BeginInfo : V0::VKStruct_Base<VkCommandBufferBeginInfo, EStructureType::CommandBuffer_BeginInfo>
			{
				EType              SType           = STypeEnum;
				const void*              Next            = nullptr  ;
				UsageFlags         Flags          ;
				const InheritanceWindow* InheritanceInfo = nullptr  ;
			};

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSubmitInfo">Specification</a>

			@ingroup APISpec_Command_Buffers
			*/
			struct SubmitInfo : V0::VKStruct_Base<VkSubmitInfo, EStructureType::SubmitInfo>
			{
				EType                 SType                = STypeEnum;
				const void*                 Next                 = nullptr  ;
				uint32                WaitSemaphoreCount   = 0        ;
				const Semaphore::Handle*    WaitSemaphores       = nullptr  ;
				const Pipeline::StageFlags* WaitDstStageMask     = nullptr  ;
				uint32                CommandBufferCount   = 0        ;
				const Handle*               CommandBuffers       = nullptr  ;
				uint32                SignalSemaphoreCount = 0        ;
				const Semaphore::Handle*    SignalSemaphores     = nullptr  ;


				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkTimelineSemaphoreSubmitInfo">Specification</a>

				@ingroup APISpec_Command_Buffers
				*/
				struct TimelineSemaphore : V0::VKStruct_Base<VkTimelineSemaphoreSubmitInfo>
				{
					EType   SType                     = STypeEnum;
					const void*   Next                      = nullptr  ;
					uint32  WaitSemaphoreValueCount   = 0        ;
					const uInt64* WaitSemaphoreValues       = nullptr  ;
					uint32  SignalSemaphoreValueCount = 0        ;
					const uInt64* SignalSemaphoreValues     = nullptr  ;
				};	

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkD3D12FenceSubmitInfoKHR">Specification</a>	

				@ingroup APISpec_Command_Buffers
				*/
				struct D3D12Fence : V0::VKStruct_Base<VkD3D12FenceSubmitInfoKHR>
				{
					EType   SType                      = STypeEnum;
					const void*   Next                       = nullptr  ;
					uint32  WaitSemaphoreValuesCount   = 0        ;
					const uInt64* WaitSemaphoreValues        = nullptr  ;
					uint32  SignalSemaphoreValuesCount = 0        ;
					const uInt64* SignalSemaphoreValues      = nullptr  ;
				};

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkWin32KeyedMutexAcquireReleaseInfoKHR">Specification</a> 

				@ingroup APISpec_Command_Buffers
				*/
				struct Win32KeyedMutexAcquireRelease : V0::VKStruct_Base<VkWin32KeyedMutexAcquireReleaseInfoKHR>
				{
					EType           SType           = STypeEnum;
					const void*           Next            = nullptr  ;
					uint32          AcquireCount    = 0        ;
					const Memory::Handle* AcquireSyncs    = nullptr  ;
					const uInt64*         AcquireKeys     = nullptr  ;
					const uint32*         AcquireTimeouts = nullptr  ;
					uint32          ReleaseCount    = 0        ;
					const Memory::Handle* ReleaseSyncs    = nullptr  ;
					const uInt64*         ReleaseKeys     = nullptr  ;
				};

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkProtectedSubmitInfo">Specification</a> 

				@ingoup APISpec_Command_Buffers
				*/
				struct Protected : V0::VKStruct_Base<VkProtectedSubmitInfo>
				{
					EType SType           = STypeEnum;
					const void* Next            = nullptr  ;
					Bool  ProtectedSubmit = false    ;

					bool operator== (const Protected& _other) { return Next == _other.Next && ProtectedSubmit == _other.ProtectedSubmit ? true : false; }
					bool operator!= (const Protected& _other) { return Next != _other.Next && ProtectedSubmit != _other.ProtectedSubmit ? true : false; }
				};

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceGroupSubmitInfo">Specification</a>

				@ingroup APISpec_Command_Buffers
				*/
				struct DeviceGroup : V0::VKStruct_Base<VkDeviceGroupSubmitInfo>
				{
					EType   SType                        = STypeEnum;
					const void*   Next                         = nullptr  ;
					uint32  WaitSemaphoreCount           = 0        ;
					const uint32* WaitSemaphoreDeviceIndices   = nullptr  ;
					uint32  CommandBufferCount           = 0        ;
					const uint32* CommandBufferDeviceMasks     = nullptr  ;
					uint32  SignalSemaphoreCount         = 0        ;
					const uint32* SignalSemaphoreDeviceIndices = nullptr  ;
				};

				/**
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPerformanceQuerySubmitInfoKHR">Specification</a>

				@ingroup APISpec_Command_Buffers
				*/
				struct PerformanceQuery : V0::VKStruct_Base<VkPerformanceQuerySubmitInfoKHR>
				{
					EType  SType            = STypeEnum;
					const void*  Next             = nullptr  ;
					uint32 CounterPassIndex = 0        ;
				};
			};

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDeviceGroupCommandBufferBeginInfo">Specification</a> 

			@ingroup APISpec_Command_Buffers
			*/
			struct DeviceGroupBeginInfo : V0::VKStruct_Base<VkDeviceGroupCommandBufferBeginInfo>
			{
				EType  SType      = STypeEnum;
				const void*  Next       = nullptr  ;
				uint32 DeviceMask = 0        ;
			};


			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkBeginCommandBuffer">Specification</a> 

			@ingroup APISpec_Command_Buffers

			* \param _commandBuffer
			* \param _flags
			* \return 
			*/
			static EResult BeginRecord(const Handle _commandBuffer, const BeginInfo& _info)
			{
				return EResult(vkBeginCommandBuffer(_commandBuffer, _info));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBeginRenderPass">Specification</a>
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* \param _deviceHandle
			* \param _commandPool
			* \param _bufferCount
			* \param _commandBuffers
			*/
			static void BeginRenderPass(const Handle _commandBuffer, const RenderPass::BeginInfo& _beginInfo, ESubpassContents _contents)
			{
				vkCmdBeginRenderPass(_commandBuffer, _beginInfo, VkSubpassContents(_contents));
			}


			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBindDescriptorSets">Specification</a> 

			@ingroup APISpec_Resource_Descriptors
			*/
			static void BindDescriptorSets
			(
				Handle                   _commandBuffer     ,
				EPipelineBindPoint       _pipelineBindPoint ,
				Pipeline::Layout::Handle _layout            ,
				uint32                   _firstSet          ,
				uint32                   _descriptorSetCount,
				const DescriptorSet::Handle*   _descriptorSets    ,
				uint32                   _dynamicOffsetCount,
				const uint32*                  _dynamicOffsets
			)
			{
				vkCmdBindDescriptorSets
				(
					_commandBuffer                         , 
					VkPipelineBindPoint(_pipelineBindPoint), 
					_layout                                , 
					_firstSet                              , 
					_descriptorSetCount                    ,
					_descriptorSets                        , 
					_dynamicOffsetCount                    , 
					_dynamicOffsets
				);
			}

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBindIndexBuffer">Specification</a> 

			@ingroup APISpec_Drawing_Commands
			*/
			static void BindIndexBuffer(Handle _commandBuffer, Buffer::Handle _buffer, DeviceSize _offset, EIndexType _indexType)
			{
				vkCmdBindIndexBuffer(_commandBuffer, _buffer, _offset, VkIndexType(_indexType));
			}

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBindVertexBuffers">Specification</a>

			@ingroup APISpec_Fixed-Function_Vertex_Processing
			*/
			static void BindVertexBuffers
			(
				Handle          _commandBuffer,
				uint32          _firstBinding ,
				uint32          _bindingCount ,
				const Buffer::Handle* _buffers      ,
				const DeviceSize*     _offsets
			)
			{
				vkCmdBindVertexBuffers(_commandBuffer, _firstBinding, _bindingCount, _buffers, _offsets);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBindPipeline">Specification</a>
			* 
			* @ingroup APISpec_Pipelines
			* 
			* \param commandBuffer
			* \param event
			* \param stageMask
			* \return 
			*/
			static void BindPipeline(Handle _commandBuffer, EPipelineBindPoint _pipelineBindPoint, Pipeline::Handle _pipeline)
			{
				vkCmdBindPipeline(_commandBuffer, VkPipelineBindPoint(_pipelineBindPoint), _pipeline);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdBlitImage">Specification</a>
			* 
			* @ingroup APISpec_Copy_Commands
			* 
			* \param commandBuffer
			* \param event
			* \param stageMask
			* \return 
			*/
			static void BlitImage
			(
				Handle        _commandBuffer ,
				Image::Handle _srcImage      ,
				EImageLayout  _srcImageLayout,
				Image::Handle _dstImage      ,
				EImageLayout  _dstImageLayout,
				uint32        _regionCount   ,
				const Image::Blit*  _regions       ,
				EFilter       _filter
			)
			{
				vkCmdBlitImage
				(
					_commandBuffer                ,
					_srcImage                     ,
					VkImageLayout(_srcImageLayout),
					_dstImage                     ,
					VkImageLayout(_dstImageLayout),
					_regionCount                  ,
					*_regions                     ,
					VkFilter(_filter)
				);
			}

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdCopyBuffer">Specification</a>

			@ingroup APISpec_Copy_Commands
			*/
			static void CopyBuffer
			(
				Handle            _commandBuffer    ,
				Buffer::Handle    _sourceBuffer     ,
				Buffer::Handle    _destinationBuffer,
				uint32            _regionCount      ,
				const Buffer::CopyInfo* _regions
			)
			{
				vkCmdCopyBuffer(_commandBuffer, _sourceBuffer, _destinationBuffer, _regionCount, *_regions);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdCopyBufferToImage">Specification</a> 
			* 
			* @ingroup APISpec_Copy_Commands
			*/
			static void CopyBufferToImage
			(
				Handle             _commandBuffer ,
				Buffer::Handle     _srcBuffer     ,
				Image::Handle      _dstImage      ,
				EImageLayout       _dstImageLayout,
				uint32             _regionCount   ,
				const BufferImageRegion* _regions
			)
			{
				vkCmdCopyBufferToImage(_commandBuffer, _srcBuffer, _dstImage, VkImageLayout(_dstImageLayout), _regionCount, *_regions);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdDraw">Specification</a> 
			* 
			* @ingroup APISpec_Drawing_Commands
			*/
			static void Draw(Handle _commandBuffer, uint32 _firstVertex, uint32 _vertexCount, uint32 _firstInstance, uint32 _instanceCount)
			{
				vkCmdDraw(_commandBuffer, _vertexCount, _instanceCount, _firstVertex, _firstInstance);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdDrawIndexed">Specification</a> 
			* 
			* @ingroup APISpec_Drawing_Commands
			*/
			static void DrawIndexed(Handle _commandBuffer, uint32 _indexCount, uint32 _instanceCount, uint32 _firstIndex, sint32 _vertexOffset, uint32 _firstInstance)
			{
				vkCmdDrawIndexed(_commandBuffer, _indexCount, _instanceCount, _firstIndex, _vertexOffset, _firstInstance);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkEndCommandBuffer">Specification</a> 
			* 
			* @ingroup https://www.alienbrain.com/
			* 
			* \param _commandBuffer
			* \return 
			*/
			static EResult EndRecord(Handle _commandBuffer)
			{
				return EResult(vkEndCommandBuffer(_commandBuffer));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdEndRenderPass">Specification</a> .
			* 
			* @ingroup APISpec_Render_Pass
			* 
			* @param _commandBuffer
			* @return
			*/
			static void EndRenderPass(Handle _commandBuffer)
			{
				vkCmdEndRenderPass(_commandBuffer);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdExecuteCommands">Specification</a>
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _primaryCommandBuffer
			* \param _secondaryBufferCount
			* \param _secondaryBuffers
			*/
			static void Execute(Handle _primaryCommandBuffer, uint32 _secondaryBufferCount, const Handle* _secondaryBuffers)
			{
				vkCmdExecuteCommands(_primaryCommandBuffer, _secondaryBufferCount, _secondaryBuffers);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkResetCommandBuffer">Specification</a> 
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _commandBuffer
			* \param _flags
			* \return 
			*/
			static EResult Reset(Handle _commandBuffer, ResetFlags _flags)
			{
				return EResult(vkResetCommandBuffer(_commandBuffer, _flags));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdResetEvent">Specification</a> 
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			static void ResetEvent(Handle _commandBuffer, Event::Handle _event, Pipeline::StageFlags _stageMask)
			{
				vkCmdResetEvent(_commandBuffer, _event, _stageMask);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdPipelineBarrier">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			static void SubmitPipelineBarrier
			(
				Handle                  _commandBuffer           ,
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			)
			{
				vkCmdPipelineBarrier
				(
					_commandBuffer           ,
					_sourceStageMask         ,
					_destinationStageMask    ,
					_dependencyFlags         ,
					_memoryBarrierCount      ,
					*_memoryBarriers         ,
					_bufferMemoryBarrierCount,
					*_bufferMemoryBarriers   ,
					_imageMemoryBarrierCount ,
					*_imageMemoryBarriers
				);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdSetDeviceMask">Specification</a> 
			* 
			* @ingroup APISpec_Command_Buffers
			*/
			static void SetDeviceMask(Handle _commandBuffer, uint32 _deviceMask)
			{
				vkCmdSetDeviceMask(_commandBuffer, _deviceMask);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdSetEvent">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			static void SetEvent(Handle _commandBuffer, Event::Handle _event, Pipeline::StageFlags _stageMask)
			{
				vkCmdSetEvent(_commandBuffer, _event, _stageMask);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCmdWaitEvents">Specification</a>
			* 
			* @ingroup APISpec_Synchronization_and_Cache_Control
			*/
			static void WaitForEvents
			(
				Handle                  _commandBuffer           ,
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			)
			{
				vkCmdWaitEvents
				(
					_commandBuffer           ,
					_eventCount              ,
					_events                  ,
					_srcStageMask            ,
					_dstStageMask            ,
					_memoryBarrierCount      , 
					*_memoryBarriers         ,
					_bufferMemoryBarrierCount,
					*_bufferMemoryBarriers   ,
					_imageMemoryBarrierCount ,
					*_imageMemoryBarriers
				);
			}
		};

		/**
		@brief 
		Command pools are opaque objects that command buffer memory is allocated from, and
		which allow the implementation to amortize the cost of resource creation across
		multiple command buffers. Command pools are externally synchronized, meaning that a
		command pool must not be used concurrently in multiple threads. That includes use
		via recording commands on any command buffers allocated from the pool, as well as
		operations that allocate, free, and reset command buffers or the pool itself.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#commandbuffers-pools">Specification</a>

		@ingroup APISpec_Command_Buffers
		*/
		struct CommandPool
		{
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPool">Specification</a> @ingroup APISpec_Command_Buffers */
			using Handle = VkCommandPool;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolCreateFlags">Specification</a> @ingroup APISpec_Command_Buffers */
			using CreateFlgas = Bitmask<ECommandPoolCreateFlag, VkCommandPoolCreateFlags>;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolResetFlags">Specification</a> @ingroup APISpec_Command_Buffers */
			using ResetFlags  = Bitmask<ECommandPoolResetFlags, VkCommandPoolResetFlags >;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolTrimFlags">Specification</a> @ingroup APISpec_Command_Buffers */
			using TrimFlags   = Bitmask<EUndefined            , VkCommandPoolTrimFlags  >;

			/**
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandBufferAllocateInfo">Specification</a> 

			@ingroup APISpec_Command_Buffers
			*/
			struct AllocateInfo : V0::VKStruct_Base<VkCommandBufferAllocateInfo, EStructureType::CommandBuffer_AllocateInfo>
			{
				EType               SType       = STypeEnum                   ;
				const void*               Next        = nullptr                     ;
				Handle              Pool        = Null<Handle>                ;
				ECommandBufferLevel Level       = ECommandBufferLevel::Primary;
				uint32              BufferCount = 1                           ;
			};

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCommandPoolCreateInfo">Specification</a> 

			@ingroup APISpec_Command_Buffers 
			*/
			struct CreateInfo : V0::VKStruct_Base<VkCommandPoolCreateInfo, EStructureType::CommandPool_CreateInfo>
			{
				EType       SType            = STypeEnum;
				const void*       Next             = nullptr  ;
				CreateFlgas Flags           ;
				uint32      QueueFamilyIndex;
			};

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkAllocateCommandBuffers">Specification</a>
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _deviceHandle
			* \param _allocateInfo
			* \param _commandBuffers
			* \return 
			*/
			static EResult Allocate(LogicalDevice::Handle _deviceHandle, const AllocateInfo& _allocateInfo, CommandBuffer::Handle* _commandBuffers)
			{
				return EResult(vkAllocateCommandBuffers(_deviceHandle, _allocateInfo, _commandBuffers));
			}

			/**
			* @brief Create a command pool.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateCommandPool">Specification</a>
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _deviceHandle
			* \param _createInfo
			* \param _allocator
			* \param _commandPool
			* \return 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _createInfo  ,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _commandPool
			)
			{
				return EResult(vkCreateCommandPool(_deviceHandle, _createInfo, *_allocator, &_commandPool));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyCommandPool">Specification</a>
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _deviceHandle
			* \param _commandPool
			* \param _allocator
			*/
			static void Destroy
			(
				LogicalDevice::Handle        _deviceHandle,
				Handle                       _commandPool ,
				const Memory::AllocationCallbacks* _allocator
			)
			{
				vkDestroyCommandPool(_deviceHandle, _commandPool, *_allocator);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkFreeCommandBuffers">Specification</a>
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _deviceHandle
			* \param _commandPool
			* \param _bufferCount
			* \param _commandBuffers
			*/
			static void Free
			(
				LogicalDevice::Handle _deviceHandle   ,
				Handle                 _commandPool   ,
				uint32                 _bufferCount   ,
				const CommandBuffer::Handle* _commandBuffers
			)
			{
				vkFreeCommandBuffers(_deviceHandle, _commandPool, _bufferCount, _commandBuffers);
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkResetCommandPool">Specification</a> 
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* \param _deviceHandle
			* \param _commandPool
			* \param _flags
			*/
			static EResult Reset
			(
				LogicalDevice::Handle _deviceHandle,
				Handle                _commandPool ,
				ResetFlags            _flags
			)
			{
				return EResult(vkResetCommandPool(_deviceHandle, _commandPool, _flags));
			}

			/**
			* @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkTrimCommandPool">Specification</a> 
			* 
			* @ingroup APISpec_Command_Buffers
			* 
			* @param _deviceHandle
			* @param _commandPool
			* @param _flags
			*/
			static void Trim
			(
				LogicalDevice::Handle _deviceHandle,
				Handle                _commandPool ,
				TrimFlags             _flags
			)
			{
				vkTrimCommandPool(_deviceHandle, _commandPool, _flags);	
			}
		};

		/** @} */	// Vault_1
	}

	namespace V2
	{
		/** 
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief 
		Command pools are opaque objects that command buffer memory is allocated from,
		and which allow the implementation to amortize the cost of resource creation across multiple command buffers. 

		@details
		Command pools are externally synchronized, meaning that a command pool must not be used concurrently in multiple threads. 
		That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, 
		free, and reset command buffers or the pool itself.

		@ingroup APISpec_Command_Buffers
		*/
		struct CommandPool : public V1::CommandPool
		{
			using Parent = V1::CommandPool;

			/**
			@brief Uses the VulkanAPI's default allocator.
			*/
			static EResult Create(LogicalDevice::Handle _deviceHandle, const CreateInfo& _createInfo, Handle& _commandPool)
			{
				return Parent::Create(_deviceHandle, _createInfo, Memory::DefaultAllocator, _commandPool);
			}

			using Parent::Create;

			/**
			@brief Uses the VulkanAPI's default allocator.
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _commandPool)
			{
				Parent::Destroy(_deviceHandle, _commandPool, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			@brief Allows for the passing of the allocate info to specify the pool and buffer count alternatively.
			*/
			static void Free(LogicalDevice::Handle _device, const AllocateInfo& _info, const V1::CommandBuffer::Handle* _commandBuffers)
			{
				Parent::Free(_device, _info.Pool, _info.BufferCount, _commandBuffers);	
			}

			using Parent::Free;

		#pragma region SingleTimeCommands

			/**
			* @brief Will auto-allocate a command buffer on the specified pool and begin recording commands on the buffer. 
			* 
			* @details
			* The handle to the command buffer will be returned.
			* 
			* Expected to be used with the EndSingleTimeCommands function (defined below it).
			*/
			static V1::CommandBuffer::Handle BeginSingleTimeCommands(LogicalDevice::Handle _device, CommandPool::Handle _commandPool)
			{
				AllocateInfo allocationInfo{};

				allocationInfo.Pool = _commandPool;

				V1::CommandBuffer::Handle commandBuffer;

				Allocate(_device, allocationInfo, &commandBuffer);

				V1::CommandBuffer::BeginInfo beginInfo{};

				beginInfo.Flags = ECommandBufferUsageFlag::OneTimeSubmit;

				V1::CommandBuffer::BeginRecord(commandBuffer, beginInfo);

				return commandBuffer;
			}

			/**
			* @brief Will end the recording and submit the command buffer created with the BeginSingleTimeCommands function.
			* 
			* @details
			* Will wait until the queue is idle that the commands were submitted to. Will also free the command buffer after completion.
			* 
			* Expected to be used with the BeginSingleTimeCommands function (defined above it).
			*/
			static void EndSingleTimeCommands
			(
				V1::CommandBuffer   ::Handle _commandBuffer, 
				CommandPool         ::Handle _commandPool  , 
				LogicalDevice       ::Handle _device       , 
				LogicalDevice::Queue::Handle _queue
			)
			{
				V1::CommandBuffer::EndRecord(_commandBuffer);

				V1::CommandBuffer::SubmitInfo submitInfo{};

				submitInfo.CommandBufferCount = 1              ;
				submitInfo.CommandBuffers     = &_commandBuffer;

				LogicalDevice::Queue::SubmitToQueue(_queue, 1, submitInfo, Null<Fence::Handle>);

				LogicalDevice::Queue::WaitUntilIdle(_queue);

				Parent::Free(_device, _commandPool, 1, &_commandBuffer);
			}

		#pragma endregion SingleTimeCommands	
		};

		/**
		@brief Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution.

		@ingroup APISpec_Command_Buffers
		*/
		struct CommandBuffer : public V1::CommandBuffer
		{
			using Parent = V1::CommandBuffer;

			/** @brief Uses a single-time command buffer to copy a buffer */
			static void CopyBuffer
			(
				Buffer::Handle               _sourceBuffer     , 
				Buffer::Handle               _destinationBuffer, 
				Buffer::CopyInfo             _regionInfo       ,
				LogicalDevice::Handle        _device           ,
				CommandPool::Handle          _pool             ,
				LogicalDevice::Queue::Handle _queue
			)
			{
				Handle commandBuffer = CommandPool::BeginSingleTimeCommands(_device, _pool);

				Parent::CopyBuffer(commandBuffer, _sourceBuffer, _destinationBuffer, 1, &_regionInfo);

				CommandPool::EndSingleTimeCommands(commandBuffer, _pool, _device, _queue);
			}	

			using Parent::CopyBuffer;

			/**
			@brief A version of SubmitPipelineBarrier where only a set of regular memory barriers are submitted.
			*/
			static void SubmitPipelineBarrier
			(
				Handle                  _commandBuffer       ,
				Pipeline::StageFlags    _sourceStageMask     ,
				Pipeline::StageFlags    _destinationStageMask,
				DependencyFlags         _dependencyFlags     ,
				uint32                  _memoryBarrierCount  ,
				const Memory::Barrier*        _memoryBarriers          
			)
			{
				Parent::SubmitPipelineBarrier
				(
					_commandBuffer       ,
					_sourceStageMask     ,
					_destinationStageMask,
					_dependencyFlags     ,
					_memoryBarrierCount  ,
					_memoryBarriers      ,
					0, nullptr,
					0, nullptr
				);
			}

			/**
			@brief A version where only a set of buffer memory barriers are submitted.
			*/
			static void SubmitPipelineBarrier
			(
				Handle                  _commandBuffer           ,
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    
			)
			{
				Parent::SubmitPipelineBarrier
				(
					_commandBuffer       ,
					_sourceStageMask     ,
					_destinationStageMask,
					_dependencyFlags     ,
					0, nullptr,
					_bufferMemoryBarrierCount,
					_bufferMemoryBarriers    ,
					0, nullptr
				);
			}

			/**
			@brief A version of SubmitPipelineBarrier where only a set of image memory barriers are submitted.
			*/
			static void SubmitPipelineBarrier
			(
				Handle                  _commandBuffer           ,
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			)
			{
				Parent::SubmitPipelineBarrier
				(
					_commandBuffer       ,
					_sourceStageMask     ,
					_destinationStageMask,
					_dependencyFlags     ,
					0, nullptr,
					0, nullptr,
					_imageMemoryBarrierCount,
					_imageMemoryBarriers
				);
			}

			using Parent::SubmitPipelineBarrier;

			/**
			@brief A version of WaitForEvents where only a set of memory barriers are waited on.
			*/
			static void WaitForEvents
			(
				Handle               _commandBuffer     ,
				uint32               _eventCount        ,
				const Event::Handle*       _events            ,
				Pipeline::StageFlags _srcStageMask      ,
				Pipeline::StageFlags _dstStageMask      ,
				uint32               _memoryBarrierCount,
				const Memory::Barrier*     _memoryBarriers
			)
			{
				Parent::WaitForEvents
				(
					_commandBuffer     ,
					_eventCount        , 
					_events            ,
					_srcStageMask      , 
					_dstStageMask      ,
					_memoryBarrierCount, 
					_memoryBarriers    ,
					0, nullptr, 
					0, nullptr
				);
			}

			/**
			@brief A version of WaitForEvents where only a set of buffer memory barriers are waited on.
			*/
			static void WaitForEvents
			(
				Handle                  _commandBuffer           ,
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers
			)
			{
				Parent::WaitForEvents
				(
					_commandBuffer,
					_eventCount   , 
					_events       ,
					_srcStageMask ,
					_dstStageMask ,
					0, nullptr,
					_bufferMemoryBarrierCount, 
					_bufferMemoryBarriers    ,
					0, nullptr
				);
			}

			/**
			@brief A version of WaitForEvents where only a set of image memory barriers are waited on.
			*/
			static void WaitForEvents
			(
				Handle                 _commandBuffer          ,
				uint32                 _eventCount             ,
				const Event::Handle*         _events                 ,
				Pipeline::StageFlags   _srcStageMask           ,
				Pipeline::StageFlags   _dstStageMask           ,
				uint32                 _imageMemoryBarrierCount,
				const Image::Memory_Barrier* _imageMemoryBarriers
			)
			{
				Parent::WaitForEvents
				(
					_commandBuffer,
					_eventCount   , 
					_events       ,
					_srcStageMask , 
					_dstStageMask ,
					0, nullptr,
					0, nullptr,
					_imageMemoryBarrierCount, 
					_imageMemoryBarriers
				);
			}

			using Parent::WaitForEvents;
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@ingroup APISpec_Command_Buffers
		@brief Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution.

		@details This object only acts as a host interface to a given device object's handle. Since command pools handle the lifetime
		of a command buffer, The command buffer can only clear its references to the device object.
		*/
		class CommandBuffer : public V2::CommandBuffer
		{
		public:

			using Parent = V2::CommandBuffer;

			using AllocateInfo = V2::CommandPool::AllocateInfo;

			/**
			@brief Default constructor.
			*/
			CommandBuffer() : handle(Null<Handle>), device(nullptr)
			{}

			/**
			@brief Constructor with logical device, allocate info, and handle specified (acts as an Assign() call)
			*/
			CommandBuffer(const LogicalDevice& _device, Handle& _handle) :
				device(&_device), handle(_handle)
			{}

			/**
			@brief Assign a device and handle.
			*/
			void Assign(const LogicalDevice& _device, Handle& _handle)
			{
				device = &_device;
				handle = _handle ;
			}

			/**
			@brief Clear references to related device objects.
			*/
			void Clear()
			{
				device = nullptr     ;
				handle = Null<Handle>;
			}

			/**
			@brief Begin recording commands to the buffer.

			@details Command buffer recording follows an immediate design. Calls done related to this buffer will be recorded by the buffer.
			*/
			EResult BeginRecord(const BeginInfo& _info) const
			{
				return Parent::BeginRecord(handle, _info);
			}

			/**
			@brief Begin recording a render pass set of commands into the buffer.
			*/
			void BeginRenderPass(const RenderPass::BeginInfo& _info, ESubpassContents _contents) const
			{
				Parent::BeginRenderPass(handle, _info, _contents);
			}

			/**
			@brief Bind one or more descriptor sets to a command buffer. (No dynamic offsets)
			*/
			void BindDescriptorSets
			(
				EPipelineBindPoint     _bindPoint         ,
				Pipeline::Layout&      _layout            ,
				uint32                 _firstSet          ,
				uint32                 _descritporSetCount,
				const DescriptorSet::Handle* _descriptorSets
			) const
			{
				Parent::BindDescriptorSets(handle, _bindPoint, _layout, _firstSet, _descritporSetCount, _descriptorSets, 0, nullptr);
			}

			/**
			@brief Bind one or more descriptor sets to a command buffer. 
			*/
			void BindDescriptorSets
			(
				EPipelineBindPoint     _bindPoint         ,
				Pipeline::Layout&      _layout            ,
				uint32                 _firstSet          ,
				uint32                 _descritporSetCount,
				const DescriptorSet::Handle* _descriptorSets    ,
				uint32                 _dynamicOffsetCount,
				const uint32*                _dynamicOffsets
			) const
			{
				Parent::BindDescriptorSets(handle, _bindPoint, _layout, _firstSet, _descritporSetCount, _descriptorSets, _dynamicOffsetCount, _dynamicOffsets);
			}

			/**
			@brief Bind an index buffer to a command buffer.
			*/
			void BindIndexBuffer(Buffer& _buffer, DeviceSize _offset, EIndexType _type) const
			{
				Parent::BindIndexBuffer(handle, _buffer, _offset, _type);
			}

			/**
			@brief Bind vertex buffers to a command buffer for use in subsequent draw commands. (No offsets)
			*/
			void BindVertexBuffers(uint32 _firstBinding, uint32 _bindingCount, const Buffer::Handle* _buffers) const
			{
				Parent::BindVertexBuffers(handle, _firstBinding, _bindingCount, _buffers, 0);
			}

			/**
			@brief Bind vertex buffers to a command buffer for use in subsequent draw commands. 
			*/
			void BindVertexBuffers(uint32 _firstBinding, uint32 _bindingCount, const Buffer::Handle* _buffers, const DeviceSize* _offsets) const
			{
				Parent::BindVertexBuffers(handle, _firstBinding, _bindingCount, _buffers, _offsets);
			}

			/**
			@brief Bind a pipeline to a command buffer for use in subsequent commands. (Until another pipeline is bound)
			*/
			void BindPipeline(EPipelineBindPoint _bindPoint, Pipeline& _pipeline) const
			{
				Parent::BindPipeline(handle, _bindPoint, _pipeline);
			}

			/**
			@brief Copy regions of a source image into a destination image, potentially performing format conversion, arbitrary scaling, and filtering.
			*/
			void BlitImage(Image& _src, EImageLayout _srcLayout, Image& _dst, EImageLayout _dstLayout, uint32 _regionCount, const Image::Blit* _regions, EFilter _filter) const
			{
				Parent::BlitImage(handle, _src, _srcLayout, _dst, _dstLayout, _regionCount, _regions, _filter);
			}

			/**
			@brief Copy data between buffer objects.
			*/
			void CopyBuffer(Buffer& _sourceBuffer, Buffer& _destinationBuffer, uint32 _regionCount, const Buffer::CopyInfo* _regions) const
			{
				Parent::Parent::CopyBuffer(handle, _sourceBuffer, _destinationBuffer, _regionCount, _regions);
			}

			/**
			@brief Copy data from a buffer object to an image object.
			*/
			void CopyBufferToImage
			(
				Buffer&            _srcBuffer     ,
				Image&             _dstImage      ,
				EImageLayout       _dstImageLayout,
				uint32		     _regionCount   ,
				const BufferImageRegion* _regions
			) const
			{
				Parent::CopyBufferToImage(handle, _srcBuffer, _dstImage, _dstImageLayout, _regionCount, _regions);
			}

			/**
			@brief Record a non-indexed draw.
			*/
			void Draw(uint32 _firstVertex, uint32 _vertexCount, uint32 _firstInstance, uint32 _instanceCount) const
			{
				Parent::Draw(handle, _firstVertex, _vertexCount, _firstInstance, _instanceCount);
			}

			/**
			@brief Record an indexed draw.
			*/
			void DrawIndexed
			(
				uint32 _indexCount   ,
				uint32 _instanceCount,
				uint32 _firstIndex   ,
				sint32 _vertexOffset ,
				uint32 _firstInstance
			) const
			{
				Parent::DrawIndexed(handle, _indexCount, _instanceCount, _firstIndex, _vertexOffset, _firstInstance);
			}

			/**
			@brief complete recording of a command buffer.
			*/
			EResult EndRecord() const
			{
				return Parent::EndRecord(handle);
			}

			/**
			@brief record a command to end a render pass instance after recording the commands for the last subpass.
			*/
			void EndRenderPass() const
			{
				Parent::EndRenderPass(handle);
			}

			/**
			@brief A secondary command buffer must not be directly submitted to a queue. 
			Instead, secondary command buffers are recorded to execute as part of a primary command buffer..
			*/
			void Execute(uint32 _secondaryBufferCount, const Handle* _secondaryBuffers) const
			{
				Parent::Execute(handle, _secondaryBufferCount, _secondaryBuffers);
			}

			/**
			@brief Set the state of an event to unsignaled from a device.
			*/
			void ResetEvent(Event& _event, Pipeline::StageFlags _stageMask) const
			{
				Parent::ResetEvent(handle, _event, _stageMask);
			}

		#pragma region SubmitPipelineBarrier_OO

			/**
			@brief A version of SubmitPipelineBarrier where only a set of regular memory barriers are submitted.
			*/
			void SubmitPipelineBarrier
			(
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          
			) const
			{
				Parent::SubmitPipelineBarrier
				(
					handle               , 
					_sourceStageMask     , 
					_destinationStageMask, 
					_dependencyFlags     , 
					_memoryBarrierCount  , 
					_memoryBarriers
				);
			}

			/**
			@brief A version where only a set of buffer memory barriers are submitted.
			*/
			void SubmitPipelineBarrier
			(
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    
			) const
			{
				Parent::SubmitPipelineBarrier
				(
					handle, 
					_sourceStageMask         , 
					_destinationStageMask    , 
					_dependencyFlags         , 
					_bufferMemoryBarrierCount, 
					_bufferMemoryBarriers
				);
			}

			/**
			@brief A version of SubmitPipelineBarrier where only a set of image memory barriers are submitted.
			*/
			void SubmitPipelineBarrier
			(
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			) const
			{
				Parent::SubmitPipelineBarrier
				(
					handle, 
					_sourceStageMask        , 
					_destinationStageMask   , 
					_dependencyFlags        , 
					_imageMemoryBarrierCount,
					_imageMemoryBarriers
				);
			}

			/**
			@brief Record a pipeline barrier.
			*/
			void SubmitPipelineBarrier
			(
				Pipeline::StageFlags    _sourceStageMask         ,
				Pipeline::StageFlags    _destinationStageMask    ,
				DependencyFlags         _dependencyFlags         ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			) const
			{
				Parent::SubmitPipelineBarrier
				(
					handle                   , 
					_sourceStageMask         , 
					_destinationStageMask    , 
					_dependencyFlags         , 
					_memoryBarrierCount      , 
					_memoryBarriers          , 
					_bufferMemoryBarrierCount, 
					_bufferMemoryBarriers    , 
					_imageMemoryBarrierCount ,
					_imageMemoryBarriers
				);
			}

		#pragma endregion SubmitPipelineBarrier_OO

			/**
			@brief Update the current device mask of a command buffer.
			*/
			void SetDeviceMask(uint32 _deviceMask) const
			{
				Parent::SetDeviceMask(handle, _deviceMask);
			}

			/**
			@brief Set the state of an event to signaled from a device.
			*/
			void SetEvent(Event& _event, Pipeline::StageFlags _stageMask) const
			{
				Parent::SetEvent(handle, _event, _stageMask);
			}

		#pragma region WaitForEvents_OO

			/**
			@brief A version of WaitForEvents where only a set of memory barriers are waited on.
			*/
			void WaitForEvents
			(
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          
			) const
			{
				Parent::WaitForEvents
				(
					handle             , 
					_eventCount        , 
					_events            , 
					_srcStageMask      , 
					_dstStageMask      , 
					_memoryBarrierCount, 
					_memoryBarriers
				);
			}

			/**
			@brief A version of WaitForEvents where only a set of buffer memory barriers are waited on.
			*/
			void WaitForEvents
			(
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    
			) const
			{
				Parent::WaitForEvents
				(
					handle                   , 
					_eventCount              , 
					_events                  , 
					_srcStageMask            , 
					_dstStageMask            , 
					_bufferMemoryBarrierCount, 
					_bufferMemoryBarriers
				);
			}

			/**
			@brief A version of WaitForEvents where only a set of image memory barriers are waited on.
			*/
			void WaitForEvents
			(
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			) const
			{
				Parent::WaitForEvents
				(
					handle                  , 
					_eventCount             , 
					_events                 , 
					_srcStageMask           , 
					_dstStageMask           , 
					_imageMemoryBarrierCount,
					_imageMemoryBarriers
				);
			}

			/**
			@brief Wait for one or more events to enter the signaled state on a device.
			*/
			void WaitForEvents
			(
				uint32                  _eventCount              ,
				const Event::Handle*          _events                  ,
				Pipeline::StageFlags    _srcStageMask            ,
				Pipeline::StageFlags    _dstStageMask            ,
				uint32                  _memoryBarrierCount      ,
				const Memory::Barrier*        _memoryBarriers          ,
				uint32                  _bufferMemoryBarrierCount,
				const Buffer::Memory_Barrier* _bufferMemoryBarriers    ,
				uint32                  _imageMemoryBarrierCount ,
				const Image::Memory_Barrier*  _imageMemoryBarriers
			) const
			{
				Parent::WaitForEvents
				(
					handle                   , 
					_eventCount              , 
					_events                  ,  
					_srcStageMask            , 
					_dstStageMask            , 
					_memoryBarrierCount      , 
					_memoryBarriers          , 
					_bufferMemoryBarrierCount, 
					_bufferMemoryBarriers    ,
					_imageMemoryBarrierCount ,
					_imageMemoryBarriers
				);
			}

		#pragma endregion WaitForEvents_OO

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointers to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const CommandBuffer& _other) const
			{
				return handle == _other.handle;
			}

		protected:

			Handle handle;

			const LogicalDevice* device;
		};

		/**
		@ingroup APISpec_Command_Buffers
		@brief Command pools are opaque objects that command buffer memory is allocated from,
		and which allow the implementation to amortize the cost of resource creation across multiple command buffers.

		@details
		Command pools are externally synchronized, meaning that a command pool must not be used concurrently in multiple threads.
		That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate,
		free, and reset command buffers or the pool itself.

		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class CommandPool : public V2::CommandPool
		{
		public:
			using Parent = V2::CommandPool;

			/**
			@brief Default constructor.
			*/
			CommandPool() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Default constructor, logical device defined.
			*/
			CommandPool(const LogicalDevice& _device) : handle(Null<Handle>),  allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Default constructor, logical device and allocator defined.
			*/
			CommandPool(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : 
				handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			CommandPool(CommandPool&& _poolToMove) noexcept : 
				handle(std::move(_poolToMove.handle)), allocator(std::move(_poolToMove.allocator)), device(std::move(_poolToMove.device))
			{
				_poolToMove.handle    = Null<Handle>            ;
				_poolToMove.allocator = Memory::DefaultAllocator;
				_poolToMove.device    = nullptr                 ;
			}

			/**
			@brief Call the destroy for the device object if the host object's handle is not null.
			*/
			~CommandPool()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Allocate a command buffer.
			*/
			EResult Allocate(CommandBuffer& _buffer)
			{
				CommandBuffer::Handle bufferHandle;

				AllocateInfo info; info.Pool = handle;

				EResult returnCode = Parent::Allocate(*device, info, &bufferHandle);

				if (returnCode != EResult::Success) return returnCode;

				_buffer.Assign(*device, bufferHandle);

				return returnCode;
			}

			/**
			@brief Allocate a command buffer with the specified allocation info.
			*/
			EResult Allocate(AllocateInfo& _info, CommandBuffer& _buffer)
			{
				CommandBuffer::Handle bufferHandle;

				EResult returnCode = Parent::Allocate(*device, _info, &bufferHandle);

				if (returnCode != EResult::Success) return returnCode;

				_buffer.Assign(*device, bufferHandle);

				return returnCode;
			}

			/**
			@brief Allocate command buffers based on the allocate info.
			*/
			EResult Allocate(AllocateInfo& _info, CommandBuffer::Handle* _buffers)
			{
				EResult returnCode = Parent::Allocate(*device, _info, _buffers);

				return returnCode;
			}

			/**
			@brief Allocate command buffers with the specified count and level.
			*/
			EResult Allocate(ECommandBufferLevel _level, uint32 _count, CommandBuffer::Handle* _buffers)
			{
				AllocateInfo allocInfo; 

				allocInfo.Level       = _level;
				allocInfo.Pool        = handle;
				allocInfo.BufferCount = _count;

				EResult returnCode = Parent::Allocate(*device, allocInfo, _buffers);

				return returnCode;
			}

			/**
			@brief Allocate command buffers and their handles into dynamic arrays. based on the count provided and the level desired.
			*/
			EResult Allocate
			(
				ECommandBufferLevel          _level         ,
				uint32                       _count         ,
				DynamicArray<CommandBuffer>& _commandBuffers
			)
			{
				AllocateInfo allocInfo; 

				allocInfo.Level       = _level;
				allocInfo.Pool        = handle;
				allocInfo.BufferCount = _count;

				DynamicArray<CommandBuffer::Handle> handles(_count);

				_commandBuffers.resize(_count);

				EResult returnCode = Parent::Allocate(*device, allocInfo, handles.data());

				if (returnCode != EResult::Success) return returnCode;

				for (DeviceSize index = 0; index < _count; index++)
				{
					_commandBuffers[index].Assign(*device, handles[index]);
				}

				return returnCode;
			}

			/**
			@brief Allocate command buffers and their handles into dynamic arrays. based on the count provided and the level desired.
			*/
			EResult Allocate
			(
				ECommandBufferLevel                  _level         ,
				uint32                               _count         ,
				DynamicArray<CommandBuffer>&         _commandBuffers,
				DynamicArray<CommandBuffer::Handle>& _handles
			)
			{
				AllocateInfo allocInfo; 

				allocInfo.Level       = _level;
				allocInfo.Pool        = handle;
				allocInfo.BufferCount = _count;

				_commandBuffers.resize(_count); _handles.resize(_count);

				EResult returnCode = Parent::Allocate(*device, allocInfo, _handles.data());

				if (returnCode != EResult::Success) return returnCode;

				for (DeviceSize index = 0; index < _count; index++)
				{
					_commandBuffers[index].Assign(*device, _handles[index]);
				}

				return returnCode;
			}

			/**
			@brief Create a command pool.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Create a command pool (device specified).
			*/
			EResult Create(const LogicalDevice& _device, const CreateInfo& _info)
			{
				device = &_device;

				return Parent::Create(*device, _info, handle);	
			}

			/**
			@brief Create a command pool (device and allocator specified).
			*/
			EResult Create(const LogicalDevice& _device, CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_device   ;
				allocator = &_allocator;

				return Parent::Create(*device, _info, allocator, handle);	
			}

			/**
			@brief Destroy a command pool.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle, allocator);

				handle    = Null<Handle>;
				allocator = nullptr     ;
				device    = nullptr     ;
			}

			/**
			@brief Free the command buffers based on the count and handle container provided.
			*/
			void Free(uint32 _bufferCount, const CommandBuffer::Handle* _commandBuffers)
			{
				Parent::Free(*device, handle, _bufferCount, _commandBuffers);
			}

			/**
			@brief Free the command buffers based on the allocate info and handle container provided.
			*/
			void Free(const AllocateInfo& _info, const CommandBuffer::Handle* _commandBuffers)
			{
				Parent::Free(*device, handle, _info.BufferCount, _commandBuffers);	
			}

			/**
			@brief Free a command buffer.
			*/
			void Free(CommandBuffer& _commandBuffer)
			{
				Parent::Free(*device, handle, 1, _commandBuffer);
			}

			/**
			@brief Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. 
			All command buffers that have been allocated from the command pool are put in the initial state.
			*/
			EResult Reset(ResetFlags _flags)
			{
				return Parent::Reset(*device, handle, _flags);
			}

			/**
			@brief Trimming a command pool recycles unused memory from the command pool back to the system. 
			Command buffers allocated from the pool are not affected by the command.
			*/
			void Trim(TrimFlags _flags)
			{
				Parent::Trim(*device, handle, _flags);
			}

		#pragma region SingleTimeCommands

			/**
			* @brief Will auto-allocate a command buffer on the specified pool and begin recording commands on the buffer. 
			* 
			* @details
			* The handle to the command buffer will be returned.
			* 
			* Expected to be used with the EndSingleTimeCommands function (defined below it).
			*/
			CommandBuffer BeginSingleTimeCommands(EResult& _result)
			{
				AllocateInfo allocationInfo;

				allocationInfo.Pool = handle;

				CommandBuffer::Handle bufferHandle;

				_result = Allocate(allocationInfo, &bufferHandle);

				if (_result != EResult::Success) return CommandBuffer();

				CommandBuffer::BeginInfo beginInfo;

				beginInfo.Flags = ECommandBufferUsageFlag::OneTimeSubmit;

				_result = CommandBuffer::Parent::BeginRecord(bufferHandle, beginInfo);

				return CommandBuffer(*device, bufferHandle);
			}

			/**
			* @brief Will end the recording and submit the command buffer created with the BeginSingleTimeCommands function.
			* 
			* @details
			* Will wait until the queue is idle that the commands were submitted to. Will also free the command buffer after completion.
			* 
			* Expected to be used with the BeginSingleTimeCommands function (defined above it).
			*/
			EResult EndSingleTimeCommands
			(
				CommandBuffer&        _commandBuffer, 
				const LogicalDevice::Queue& _queue
			) 
			{
				EResult result = EResult::Incomplete;

				result = _commandBuffer.EndRecord();

				if (result != EResult::Success) return result;

				CommandBuffer::SubmitInfo submitInfo;

				submitInfo.CommandBufferCount = 1             ;
				submitInfo.CommandBuffers     = _commandBuffer;

				result = _queue.SubmitToQueue(1, submitInfo, Null<Fence::Handle>);

				if (result != EResult::Success) return result;

				result = _queue.WaitUntilIdle();

				if (result != EResult::Success) return result;

				Free(_commandBuffer);

				return result;
			}

			/**
			@brief Uses a single time command buffer to copy a buffer with the provided queue and copy info.
			*/
			EResult CopyBuffer
			(
				Buffer&               _sourceBuffer     , 
				Buffer&               _destinationBuffer, 
				Buffer::CopyInfo&     _regionInfo       ,
				const LogicalDevice::Queue& _queue
			) 
			{
				EResult result;

				CommandBuffer commandBuffer = BeginSingleTimeCommands(result);

				if (result != EResult::Success) return result;

				commandBuffer.CopyBuffer(_sourceBuffer, _destinationBuffer, 1, &_regionInfo);

				result = EndSingleTimeCommands(commandBuffer, _queue);

				return result;
			}

		#pragma endregion SingleTimeCommands

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const CommandPool& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			CommandPool& operator= (CommandPool&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */	// Vault_3
	}
}




/*!
@file VT_Surface.hpp

@brief Vaulted Thermals: Surface

@details
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_wsi_surface">Specification</a> 
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V0
	{
		using V1::Extent2D   ;
		using V1::InstanceExt;

		/**
		@addtogroup Vault_0
		@{
		*/

		/**
		* @brief Cross-Platform set of definitions for a Surface.
		*/
		struct Surface_PlatformAgnostic
		{
			using Image = V1::Image;

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSurfaceKHR">Specification</a> 

			@ingroup APISpec_Window_System_Integration_WSI 
			*/
			using Handle = VkSurfaceKHR;

			using ETransform = ESurfaceTransformFlag;

			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSurfaceTransformFlagsKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
			using ETransformFlags     = Bitmask<ESurfaceTransformFlag, VkSurfaceTransformFlagsKHR>;
			/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkCompositeAlphaFlagsKHR">Specification</a> @ingroup APISpec_Window_System_Integration_WSI */
			using CompositeAlphaFlags = Bitmask<ECompositeAlpha      , VkCompositeAlphaFlagsKHR  >;

			/**
			* @brief Structure describing capabilities of a surface.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSurfaceCapabilitiesKHR">Specification</a> 
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			*/
			struct Capabilities : V0::VKStruct_Base<VkSurfaceCapabilitiesKHR>
			{
				uint32              MinImageCount          ;
				uint32              MaxImageCount          ;
				Extent2D            CurrentExtent          ;
				Extent2D            MinImageExtent         ;
				Extent2D            MaxImageExtent         ;
				uint32              MaxImageArrayLayers    ;
				ETransformFlags     SupportedTransforms    ;
				ETransform          CurrentTransform       ;
				CompositeAlphaFlags SupportedCompositeAlpha;
				Image::UsageFlags   SupportedUsageFlags    ;

				bool operator== (const Capabilities& _other)
				{
					return
						MinImageCount           == _other.MinImageCount           &&
						MaxImageCount           == _other.MaxImageCount           &&
						CurrentExtent           == _other.CurrentExtent           &&
						MinImageExtent          == _other.MinImageExtent          &&
						MaxImageExtent          == _other.MaxImageExtent          &&
						MaxImageArrayLayers     == _other.MaxImageArrayLayers     &&
						SupportedTransforms     == _other.SupportedTransforms     &&
						SupportedCompositeAlpha == _other.SupportedCompositeAlpha &&
						SupportedUsageFlags     == _other.SupportedUsageFlags 
						? true : false;
				}

				bool operator!= (const Capabilities& _other)
				{
					return
						MinImageCount           != _other.MinImageCount           ||
						MaxImageCount           != _other.MaxImageCount           ||
						CurrentExtent           != _other.CurrentExtent           ||
						MinImageExtent          != _other.MinImageExtent          ||
						MaxImageExtent          != _other.MaxImageExtent          ||
						MaxImageArrayLayers     != _other.MaxImageArrayLayers     ||
						SupportedTransforms     != _other.SupportedTransforms     ||
						SupportedCompositeAlpha != _other.SupportedCompositeAlpha ||
						SupportedUsageFlags     != _other.SupportedUsageFlags 
						? true : false;
				}
			};

			/**
			* @brief Structure describing a supported swapchain format-color space pair.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSurfaceFormatKHR">Specification</a> 
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			*/
			struct Format : V0::VKStruct_Base<VkSurfaceFormatKHR>
			{
				EFormat     Format    ;
				EColorSpace ColorSpace;
			};
		};

		/** @brief Used to create an OS platform's surface type. */
		template<EOS> struct Surface_Maker;

		/** @brief Defines a Surface's extended definitions for Windows. */
		template<> struct Surface_Maker<EOS::Windows> : public Surface_PlatformAgnostic
		{
			using OS_AppHandle    = PlatformTypes::OS_AppHandle   ;
			using OS_WindowHandle = PlatformTypes::OS_WindowHandle;

			static constexpr RoCStr OS_Extension = InstanceExt::Win32Surface;

			/** 
			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkWin32SurfaceCreateInfoKHR">Specification</a> 

			@ingroup APISpec_Window_System_Integration_WSI
			*/
			struct CreateInfo : V0::VKStruct_Base<VkWin32SurfaceCreateInfoKHR, EStructureType::Win32_Surface_CreateInfo_KHR>
			{
				using CreateFlags = Bitmask<EUndefined, VkWin32SurfaceCreateFlagsKHR>;   ///< Reserved for future use.

				EType           SType       = STypeEnum        ;
				const void*           Next        = nullptr          ;
				CreateFlags     Flags      ;
				OS_AppHandle    OSAppHandle = GetOS_AppHandle();
				OS_WindowHandle OSWinHandle;
			};

			/**
			* @brief Returns the handle for the current process.
			* 
			* @details
			* <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea">Specification</a> 
			* 
			* \return 
			*/
			static OS_AppHandle GetOS_AppHandle()
			{
				return GetModuleHandle(nullptr);
			}

			/**
			* @brief Create a slink:VkSurfaceKHR object for an Win32 native window.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateWin32SurfaceKHR">Specification</a> 
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _appHandle
			* \param _createInfo
			* \param _allocator
			* \param _surfaceHandle
			* \return 
			*/
			static EResult Create
			(
				V1::AppInstance::Handle      _appHandle    ,
				const CreateInfo&                  _info         ,
				const Memory::AllocationCallbacks* _allocator    ,
				Handle&                      _surfaceHandle
			)
			{
				return EResult(vkCreateWin32SurfaceKHR(_appHandle, _info, _allocator->operator const VkAllocationCallbacks*(), &_surfaceHandle));
			}
		};

		/** @brief Surface definition for the currently detected OS platform. */
		//using Surface = Surface_Maker<OS_Platform>;

		/** @} */
	}

	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/** 
		@brief Native platform surface or window objects are abstracted by surface objects.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_wsi_surface">Specification</a> 

		@ingroup APISpec_Window_System_Integration_WSI
		*/
		struct Surface : public V0::Surface_Maker<V0::OS_Platform>
		{
			/**
			* @brief Destroy a VkSurfaceKHR object.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroySurfaceKHR">Specification</a> 
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _appHandle
			* \param _surfaceHandle
			* \param _allocator
			*/
			static void Destroy(AppInstance::Handle _appHandle, Surface::Handle _surfaceHandle, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroySurfaceKHR(_appHandle, _surfaceHandle, _allocator->operator const VkAllocationCallbacks*());
			}

			/**
			* @brief Query if presentation is supported.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceSupportKHR">Specification</a> 
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _physDeviceHandle
			* \param _queueFamilyIndex
			* \param _surfaceHandle
			* \param _checkResult
			* \return 
			*/
			static EResult CheckPhysicalDeviceSupport
			(
				PhysicalDevice::Handle _physDeviceHandle,
				uint32                 _queueFamilyIndex,
				Surface::Handle        _surfaceHandle   ,
				Bool&                  _checkResult
			)
			{
				return EResult(vkGetPhysicalDeviceSurfaceSupportKHR(_physDeviceHandle, _queueFamilyIndex, _surfaceHandle, &_checkResult));
			}

			/**
			* @brief Query surface capabilities.
			* 
			* @details
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR">Specification</a>  
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _deviceHandle
			* \param _surface
			* \param _capabilitiesResult
			* \return 
			*/
			static EResult GetPhysicalDeviceCapabilities(PhysicalDevice::Handle _deviceHandle, Surface::Handle _surface, Surface::Capabilities& _capabilitiesResult)
			{
				return EResult(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(_deviceHandle, _surface, (VkSurfaceCapabilitiesKHR*)(&_capabilitiesResult)));
			}

			/**
			* @brief Query color formats supported by surface.
			* 
			* @details 
			* If pSurfaceFormats is NULL, then the number of format pairs supported for the given surface is returned in pSurfaceFormatCount. 
			* Otherwise, pSurfaceFormatCount must point to a variable set by the user to the number of elements in the pSurfaceFormats array, 
			* and on return the variable is overwritten with the number of structures actually written to pSurfaceFormats.
			* 
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceFormatsKHR">Specification</a> 
			*
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _deviceHandle
			* \param _surfaceHandle
			* \param _numFormats
			* \param _formatsContainer
			* \return 
			*/
			static EResult GetFormats(PhysicalDevice::Handle _deviceHandle, Surface::Handle _surfaceHandle, uint32& _numFormats, Surface::Format* _formatsContainer)
			{
				return EResult(vkGetPhysicalDeviceSurfaceFormatsKHR(_deviceHandle, _surfaceHandle, &_numFormats, _formatsContainer->operator VkSurfaceFormatKHR*()));
			}

			/**
			* @brief Query supported presentation modes.
			* 
			* @details
			* If pPresentModes is NULL, then the number of presentation modes supported for the given surface is returned in pPresentModeCount. 
			* Otherwise, pPresentModeCount must point to a variable set by the user to the number of elements in the pPresentModes array, 
			* and on return the variable is overwritten with the number of values actually written to pPresentModes.
			* 
			* <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfacePresentModesKHR">Specification</a>  
			* 
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* \param _deviceHandle
			* \param _surfaceHandle
			* \param _numPresentationModes
			* \param _presentationModesContainer
			* \return 
			*/
			static EResult QuerySupportedPresentationModes
			(
				PhysicalDevice::Handle _deviceHandle              , 
				Surface::Handle        _surfaceHandle             , 
				uint32&                _numPresentationModes      , 
				EPresentationMode*     _presentationModesContainer
			)
			{
				return EResult(vkGetPhysicalDeviceSurfacePresentModesKHR(_deviceHandle, _surfaceHandle, &_numPresentationModes, (VkPresentModeKHR*)(_presentationModesContainer)));
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		*/

		/** @brief Surfaces hook onto a window to use as a rendering target. */
		struct Surface : public  V1::Surface
		{
			using Parent = V1::Surface;

			/**
			@brief Create a surface (Default Allocator).
			*/
			static EResult Create(AppInstance::Handle _appHandle, const CreateInfo& _createInfo, Handle& _surfaceHandle)
			{
				return Parent::Create(_appHandle, _createInfo, Memory::DefaultAllocator, _surfaceHandle);
			}

			using Parent::Create;

			/**
			@brief Destroy a surface (Default Allocator).
			*/
			static void Destroy(AppInstance::Handle _appHandle, Surface::Handle _surfaceHandle)
			{
				Parent::Destroy(_appHandle, _surfaceHandle, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			* @brief Provides the available surface formats.
			* 
			* \param _deviceHandle
			* \param _surfaceHandle
			* \param _formatsContainer
			* \return 
			*/
			static EResult GetAvailableFormats
			(
				PhysicalDevice::Handle         _deviceHandle    , 
				Surface::Handle                _surfaceHandle   , 
				DynamicArray<Surface::Format>& _formatsContainer
			)
			{
				uint32 numFormats; 

				EResult result = GetFormats(_deviceHandle, _surfaceHandle, numFormats, nullptr);

				if (result != EResult::Success) return result;

				_formatsContainer.resize(numFormats);

				result = GetFormats(_deviceHandle, _surfaceHandle, numFormats, _formatsContainer.data());

				return result;
			}

			/**
			* @brief Provides the supported presentation modes.
			* 
			* \param _deviceHandle
			* \param _surfaceHandle
			* \param _presentationModesContainer
			* \return 
			*/
			static EResult GetSupportedPresentationModes
			(
				PhysicalDevice::Handle           _deviceHandle              , 
				Surface::Handle                  _surfaceHandle             , 
				DynamicArray<EPresentationMode>& _presentationModesContainer
			)
			{
				uint32 numPresentationModes; 

				EResult result = QuerySupportedPresentationModes(_deviceHandle, _surfaceHandle, numPresentationModes, nullptr);

				if (result != EResult::Success) return result;

				_presentationModesContainer.resize(numPresentationModes);

				result = QuerySupportedPresentationModes(_deviceHandle, _surfaceHandle, numPresentationModes, _presentationModesContainer.data());

				return result;
			}
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		*/

		/**
		@brief Surfaces hook onto a window to use as a rendering target.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Surface : public V2::Surface
		{
		public:

			using Parent = V2::Surface;

			/**
			@brief Default constructor.
			*/
			Surface() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), app(nullptr), physicalDevice(nullptr)
			{}

			/**
			@brief Specifies the app instance.
			*/
			Surface(const AppInstance& _app) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), app(&_app), physicalDevice(nullptr)
			{}

			/**
			@brief Specifies the app instance, and allocator.
			*/
			Surface(const AppInstance& _app, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), app(&_app), physicalDevice(nullptr)
			{}

			/**
			@brief Specifies the app instance and physical device.
			*/
			Surface(const AppInstance& _app, const PhysicalDevice& _physicalDevice) :
				handle(Null<Handle>), allocator(Memory::DefaultAllocator), app(&_app), physicalDevice(&_physicalDevice)
			{}

			/**
			@brief Specifies the app instance, physical device, allocator.
			*/
			Surface(const AppInstance& _app, const PhysicalDevice& _physicalDevice, const Memory::AllocationCallbacks& _allocator) :
				handle(Null<Handle>), allocator(&_allocator), app(&_app), physicalDevice(&_physicalDevice)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Surface(Surface&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), app(std::move(_other.app)), physicalDevice(std::move(_other.physicalDevice))
			{
				_other.handle         = Null<Handle>            ;
				_other.allocator      = Memory::DefaultAllocator;
				_other.app            = nullptr                 ;
				_other.physicalDevice = nullptr                 ;
			}

			/**
			@brief Destroys the surface if handle is not null.
			*/
			~Surface()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Assign the physical device.
			*/
			void AssignPhysicalDevice(const PhysicalDevice& _physicalDevice)
			{
				physicalDevice = &_physicalDevice;
			}

			/**
			@brief Create a surface with the provided window handle.
			*/
			EResult Create(OS_WindowHandle _window)
			{
				CreateInfo geninfo {}; geninfo.OSWinHandle = _window;

				return Parent::Create(*app, geninfo, handle);
			}

			/**
			@brief Create a surface with the specified create info.
			*/
			EResult Create(const CreateInfo&  _info)
			{
				if (app == nullptr) return EResult::Not_Ready;

				return Parent::Create(*app, _info, handle);
			}

			/**
			@brief Create a surface with the specified app instance and widow handle.
			*/
			EResult Create(const AppInstance& _app, OS_WindowHandle _window)
			{
				CreateInfo geninfo {}; geninfo.OSWinHandle = _window;

				app = &_app;

				return Parent::Create(*app, geninfo, handle);
			}

			/**
			@brief Create a surface with the specified app instance and create info.
			*/
			EResult Create(const AppInstance& _appHandle, const CreateInfo& _info)
			{
				app = &_appHandle;

				return Parent::Create(*app, _info, handle);
			}

			/**
			@brief Create a surface with the specified app handle, create info, and allocator.
			*/
			EResult Create(const AppInstance& _appHandle, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				app       = &_appHandle;
				allocator = &_allocator;

				return Parent::Create(*app, _info, allocator, handle);
			}

			/**
			@brief Query if presentation is supported.
			*/
			EResult CheckPhysicalDeviceSupport(uint32 _queueFamilyIndex, Bool& _checkResult)
			{
				return Parent::CheckPhysicalDeviceSupport(*physicalDevice, _queueFamilyIndex, handle, _checkResult);
			}

			/**
			@brief Destroy the surface.
			*/
			void Destroy()
			{
				Parent::Destroy(*app, handle);

				app            = nullptr     ;
				physicalDevice = nullptr     ;
				handle         = Null<Handle>;
			}

			/**
			@brief Provides the available surface formats.
			*/
			EResult GetAvailableFormats(DynamicArray<Format>& _formatsContainer) const
			{
				return Parent::GetAvailableFormats(*physicalDevice, handle, _formatsContainer);
			}

			/**
			@brief Query surface capabilities.
			*/
			EResult GetPhysicalDeviceCapabilities(Capabilities& _result) const
			{
				return Parent::GetPhysicalDeviceCapabilities(*physicalDevice, handle, _result);
			}

			/**
			@brief Provides the supported presentation modes.
			*/
			EResult GetSupportedPresentationModes(DynamicArray<EPresentationMode>& _presentationModesContainer) const
			{
				return Parent::GetSupportedPresentationModes(*physicalDevice, handle, _presentationModesContainer);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Surface& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Surface& operator= (Surface&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle         = std::move(_other.handle        );
				allocator      = std::move(_other.allocator     );
				app            = std::move(_other.app           );
				physicalDevice = std::move(_other.physicalDevice);

				_other.handle         = Null<Handle>            ;
				_other.allocator      = Memory::DefaultAllocator;
				_other.app            = nullptr                 ;
				_other.physicalDevice = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const AppInstance* app;

			const PhysicalDevice* physicalDevice;
		};

		/** @} */
	}
}




/*
@file VT_SwapChain.hpp

@brief Vaulted Thermals: Swap Chain

@details
<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_wsi_swapchain">Specification</a>
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@ingroup APISpec_Window_System_Integration_WSI

		@brief A queue of images that can be presented to a surface.

		@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#_wsi_swapchain">Specification</a>
		*/
		struct Swapchain
		{
			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSwapchainKHR">Specification</a> 
			*/
			using Handle = VkSwapchainKHR;

			using ECreateFlag = ESwapchainCreateFlag;

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkSwapchainCreateFlagsKHR">Specification</a> 
			*/
			using CreateFlags = Bitmask<ESwapchainCreateFlag, VkSwapchainCreateFlagsKHR >;

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateInfoKHR.html">Specification</a> 
			*/
			struct CreateInfo : V0::VKStruct_Base<VkSwapchainCreateInfoKHR, EStructureType::SwapChain_CreateInfo_KHR>
			{
				EType                 SType                 = STypeEnum;
				const void*                 Next                  = nullptr  ;
				CreateFlags           Flags                ;
				Surface::Handle       Surface              ;
				uint32                MinImageCount        ;
				EFormat               ImageFormat          ;
				EColorSpace           ImageColorSpace      ;
				Extent2D              ImageExtent          ;
				uint32                ImageArrayLayers     ;
				Image::UsageFlags	    ImageUsage           ;
				ESharingMode          ImageSharingMode     ;
				uint32                QueueFamilyIndexCount = 0        ;
				const uint32*               QueueFamilyIndices    = nullptr  ;
				ESurfaceTransformFlag PreTransform         ;
				ECompositeAlpha       CompositeAlpha       ;
				EPresentationMode     PresentationMode     ;
				Bool                  Clipped              ;
				Handle                OldSwapchain         ;
			};

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkPresentInfoKHR">Specification</a>
			*/
			struct PresentationInfo : V0::VKStruct_Base<VkPresentInfoKHR, EStructureType::PresentInfo_KHR>
			{
				EType              SType              = STypeEnum;
				const void*              Next               = nullptr  ;
				uint32             WaitSemaphoreCount = 0        ;
				const Semaphore::Handle* WaitSemaphores     = nullptr  ;
				uint32             SwapchainCount     = 0        ;
				const Handle*            Swapchains         = nullptr  ;
				const uint32*            ImageIndices       = nullptr  ;
				EResult*           Results            = nullptr  ;
			};

			/**
			* @ingroup APISpec_Window_System_Integration_WSI
			* 
			* @brief Acquire an available presentable image to use, and retrieve the index of that image.
			* 
			* @details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkAcquireNextImageKHR">Specification</a>
			*/
			static EResult AcquireNextImage
			(
				LogicalDevice::Handle _device    ,
				Handle                _swapchain ,
				uInt64                _timeout   ,
				Semaphore::Handle     _semaphore ,
				Fence::Handle         _fence     ,
				uint32&               _imageIndex
			)
			{
				return EResult(vkAcquireNextImageKHR(_device, _swapchain, _timeout, _semaphore, _fence, &_imageIndex));
			}

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief Create a swapchain.
			* 
			@details If the oldSwapchain parameter of pCreateInfo is a valid swapchain, which has exclusive full-screen access, that access is released from oldSwapchain.
			If the command succeeds in this case, the newly created swapchain will automatically acquire exclusive full-screen access from oldSwapchain.
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateSwapchainKHR">Specification</a> 
			*/
			static EResult Create
			(
				LogicalDevice::Handle        _deviceHandle,
				const CreateInfo&                  _info        ,
				const Memory::AllocationCallbacks* _allocator   ,
				Handle&                      _swapChain
			)
			{
				return EResult(vkCreateSwapchainKHR(_deviceHandle, _info, *_allocator, &_swapChain));
			};

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief Destroy a swapchain object.

			@details
			The application must not destroy a swapchain until after completion of all outstanding operations on images that were acquired from the swapchain. 
			swapchain and all associated VkImage handles are destroyed, and must not be acquired or used any more by the application.
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroySwapchainKHR">Specification</a> 
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _swapChainToDestroy, const Memory::AllocationCallbacks* _allocator)
			{
				vkDestroySwapchainKHR(_deviceHandle, _swapChainToDestroy, *_allocator);
			}

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief Query a swapchains status when rendering to a shared presentable image.

			@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetSwapchainStatusKHR">Specification</a> 
			*/
			static EResult GetStatus(LogicalDevice::Handle _device, Handle _swapchain)
			{
				return EResult(vkGetSwapchainStatusKHR(_device, _swapchain));
			}

			/**
			@ingroup APISpec_Window_System_Integration_WSI

			@brief Obtain the array of presentable images associated with a swapchain.

			@details
			If pSwapchainImages is NULL, then the number of presentable images for swapchain is returned in pSwapchainImageCount. 
			Otherwise, pSwapchainImageCount must point to a variable set by the user to the number of elements in the pSwapchainImages array, 
			and on return the variable is overwritten with the number of structures actually written to pSwapchainImages.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkGetSwapchainImagesKHR">Specification</a>
			*/
			static EResult QueryImages(LogicalDevice::Handle _deviceHandle, Handle _swapChain, uint32& _numImages, Image::Handle* _imagesContainer)
			{
				return EResult(vkGetSwapchainImagesKHR(_deviceHandle, _swapChain, &_numImages, _imagesContainer));
			}
		};

		/** @} */
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief A queue of images that can be presented to a surface.
		*/
		struct Swapchain : V1::Swapchain
		{
			using Parent = V1::Swapchain;

			/**
			@brief Create a swapchain (Default Allocator).
			*/
			static EResult Create
			(
				LogicalDevice::Handle _deviceHandle,
				const CreateInfo&           _info        ,
				Handle&               _swapChain
			)
			{
				return Parent::Create(_deviceHandle, _info, Memory::DefaultAllocator, _swapChain);
			}

			using Parent::Create;

			/**
			@brief Destroy a swapchain (Default Allocator).
			*/
			static void Destroy(LogicalDevice::Handle _deviceHandle, Handle _swapChainToDestroy)
			{
				Parent::Destroy(_deviceHandle, _swapChainToDestroy, Memory::DefaultAllocator);
			}

			using Parent::Destroy;

			/**
			@brief Provides all presentable images with the swapchain.
			*/
			static EResult GetImages
			(
				LogicalDevice::Handle        _deviceHandle,
				Handle                       _swapChain   ,
				DynamicArray<Image::Handle>* _images
			)
			{
				uint32 numImages;

				EResult result = QueryImages(_deviceHandle, _swapChain, numImages, nullptr);

				if (result != EResult::Success) return result;

				_images->resize(numImages);

				result = QueryImages(_deviceHandle, _swapChain, numImages, _images->data());

				return result;
			}
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@brief A queue of images that can be presented to a surface.

		@details
		This object represents a device created object on the host. As such ownership is tied to this host object.
		Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
		*/
		class Swapchain : public V2::Swapchain
		{
		public:

			using Parent = V2::Swapchain;

			/**
			@brief Default constructor.
			*/
			Swapchain() : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(nullptr)
			{}

			/**
			@brief Specifies the logical device.
			*/
			Swapchain(const LogicalDevice& _device) : handle(Null<Handle>), allocator(Memory::DefaultAllocator), device(&_device)
			{}

			/**
			@brief Specifies the logical device and allocator.
			*/
			Swapchain(const LogicalDevice& _device, const Memory::AllocationCallbacks& _allocator) : handle(Null<Handle>), allocator(&_allocator), device(&_device)
			{}

			/**
			@brief Performs a move operation to transfer ownership of the device object to this host object.
			*/
			Swapchain(Swapchain&& _other) noexcept :
				handle(std::move(_other.handle)), allocator(std::move(_other.allocator)), device(std::move(_other.device))
			{
				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;
			}

			/**
			@brief Destroy a swapchain if the handle is null.
			*/
			~Swapchain()
			{
				if (handle != Null<Handle>) Destroy();
			}

			/**
			@brief Acquire an available presentable image to use, and retrieve the index of that image.
			*/
			EResult AcquireNextImage
			(
				uInt64                _timeout   ,
				Semaphore::Handle     _semaphore ,
				Fence::Handle         _fence     ,
				uint32&               _imageIndex
			)
			{
				return Parent::AcquireNextImage(*device, handle, _timeout, _semaphore, _fence, _imageIndex);
			}

			/**
			@brief Create a swapchain with the specified create info.
			*/
			EResult Create(const CreateInfo& _info)
			{
				if (device == nullptr) return EResult::Not_Ready;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a swapchain with the specified logical device and create info.
			*/
			EResult Create(const LogicalDevice& _deviceHandle, const CreateInfo& _info)
			{
				device = &_deviceHandle;

				return Parent::Create(*device, _info, handle);
			}

			/**
			@brief Create a swapchain with the specified logical device, create info, and allocator.
			*/
			EResult Create(const LogicalDevice& _deviceHandle, const CreateInfo& _info, const Memory::AllocationCallbacks& _allocator)
			{
				device    = &_deviceHandle;
				allocator = &_allocator   ;

				return Parent::Create(*device, _info, allocator, handle);
			}

			/**
			@brief Destroy a swapchain.
			*/
			void Destroy()
			{
				Parent::Destroy(*device, handle);

				handle = Null<Handle>;
				device = nullptr     ;
			}

			/**
			@brief Gets the available swapchain images and stores them in the provided dynamic array container.
			*/
			EResult GetImages(DynamicArray<Image>& _images)
			{
				uint32 numImages;

				EResult result = QueryImages(numImages, nullptr);

				if (result != EResult::Success) return result;

				_images.resize(numImages);	DynamicArray<Image::Handle> handles(numImages);

				result = QueryImages(numImages, handles.data());

				for (DeviceSize index = 0; index < numImages; index++)
				{
					_images[index].Assign(*device, handles[index]);
				}

				return result;
			}

			/**
			@brief Obtain the array of presentable images associated with a swapchain.
			*/
			EResult QueryImages(uint32& _numImages, Image::Handle* _imagesContainer)
			{
				return Parent::QueryImages(*device, handle, _numImages, _imagesContainer);
			}

			/**
			@brief Implicit conversion to give a reference to its handle.
			*/
			operator Handle&()
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a readonly reference to its handle.
			*/
			operator const Handle&() const
			{
				return handle;
			}

			/**
			@brief Implicit conversion to give a pointer to its handle.
			*/
			operator const Handle*() const
			{
				return &handle;
			}

			/**
			@brief Checks to see if its the same object by checking to see if its the same handle.
			*/
			bool operator== (const Swapchain& _other) const
			{
				return handle == _other.handle;
			}

			/**
			@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
			*/
			Swapchain& operator= (Swapchain&& _other) noexcept
			{
				if (this == &_other)
					return *this;

				handle    = std::move(_other.handle   );
				allocator = std::move(_other.allocator);
				device    = std::move(_other.device   );

				_other.handle    = Null<Handle>            ;
				_other.allocator = Memory::DefaultAllocator;
				_other.device    = nullptr                 ;

				return *this;
			}

		protected:

			Handle handle;

			const Memory::AllocationCallbacks* allocator;

			const LogicalDevice* device;
		};

		/** @} */
	}
}




/*!
@file VT_Debug.hpp

@brief Vaulted Thermals: Debug

@details
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V1
	{
		/**
		@addtogroup Vault_1
		@{
		*/

		/**
		@brief Debug Utilities: Flexible utilities for debugging an application.

		@details
		<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#debugging-debug-utils">Specification</a> 

		@ingroup APISpec_Debugging
		*/
		struct DebugUtils
		{
			/** 
			@brief Used in conjunction with labeling queues, and commands.

			@details 
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsLabelEXT">Specification</a> 

			@ingroup APISpec_Debugging
			*/
			struct Label : V0::VKStruct_Base<VkDebugUtilsLabelEXT, EStructureType::DebugUtils_Label_EXT>
			{
				EType   SType    = STypeEnum;
				const void*   Next     = nullptr  ;
				const char*   Name     = nullptr  ;
				float32 Color[4];
			};

			/** 
			@brief Used for annotating objects with user defined information.

			@details
			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsObjectNameInfoEXT">Specification</a> 

			@ingroup APISpec_Debugging 
			*/
			struct ObjectInfo : V0::VKStruct_Base<VkDebugUtilsObjectNameInfoEXT, EStructureType::DebugUtils_ObjectName_Info_EXT>
			{
				EType       SType  = STypeEnum;
				const void*       Next   = nullptr  ;
				EObjectType Type  ;
				uInt64      Handle;
				const char*       Name   = nullptr  ;
			};

			/**
			@brief 
			Vulkan allows an application to register multiple callbacks with any Vulkan component wishing to report debug information. 
			Some callbacks may log the information to a file, others may cause a debug break point or other application defined behavior. 

			@details 
			The debug messenger will provide detailed feedback on the application's use
			of Vulkan when events of interest occur. When an event of interest does
			occur, the debug messenger will submit a debug message to the debug callback
			that was provided during its creation. Additionally, the debug messenger is
			responsible with filtering out debug messages that the callback is not
			interested in and will only provide desired debug messages.

			<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#debugging-debug-utils">Specification</a>

			@ingroup APISpec_Debugging
			*/
			struct Messenger
			{
			public:
				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessengerEXT">Specification</a> @ingroup APISpec_Debugging */
				using Handle = VkDebugUtilsMessengerEXT;

				using CreateFlags = Bitmask<EUndefined, Flags>;   ///< Reserved for future use.

				using EServerity   = EDebugUtils_MessageSeverity;
				using EMessageType = EDebugUtils_MessageType    ;

				/** 
				@ingroup APISpec_Debugging
				@brief Pointer to the create debug messenger function.

				@details
				The create messenger function is not provided automatically from the Vulkan API and must be
				retrieved with AppInstance's GetProcedureAddress function.
				*/ 
				using FPtr_Create = PFN_vkCreateDebugUtilsMessengerEXT;

				/**
				@ingroup APISpec_Debugging
				@brief Pointer to the destroy debug messenger function.

				@details
				The destroy messenger function is not provided automatically from the Vulkan API and must be
				retrieved with AppInstance's GetProcedureAddress function.
				*/
				using FPtr_Destroy = PFN_vkDestroyDebugUtilsMessengerEXT;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessageSeverityFlagsEXT">Specification</a>  
				@ingroup APISpec_Debugging 
				*/
				using ServerityFlags = Bitmask<EServerity, VkDebugUtilsMessageSeverityFlagsEXT>;

				/** 
				@brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessageTypeFlagsEXT">Specification</a>  
				@ingorup APISpec_Debugging 
				*/
				using TypeFlags = Bitmask<EMessageType, VkDebugUtilsMessageTypeFlagsEXT>;

				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessengerCallbackDataEXT">Specification</a> @ingroup APISpec_Debugging */
				struct CallbackData : V0::VKStruct_Base<VkDebugUtilsMessengerCallbackDataEXT, EStructureType::DebugUtils_MessengerCallback_Data_EXT>
				{
					using FlagsMask = Bitmask<EUndefined, Flags>;

					EType       SType                = STypeEnum;
					const void*       Next                 = nullptr  ;
					FlagsMask   Flags               ;
					const char*       MesssageIDName       = nullptr  ;
					sint32      MessageIDNumber      = 0        ;
					const char*       Message              = nullptr  ;
					uint32      QueueLabelCount      = 0        ;
					const Label*      QueueLabels          = nullptr  ;
					uint32      CMDBufferLabel_Count = 0        ;
					const Label*      CMDBufferLabels      = nullptr  ;
					uint32      ObjectCount          = 0        ;
					const ObjectInfo* Objects              = nullptr  ;
				};

				/** 
				@brief The prototype for the CreateInfo::UserCallback function implemented by the application.

				@details <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#PFN_vkDebugUtilsMessengerCallbackEXT">Specification</a> 

				@ingroup APISpec_Debugging
				*/
				struct CallbackDelegate
				{
					using Delegate = PFN_vkDebugUtilsMessengerCallbackEXT;

					using VT_Type = VK_FPtr<Bool, EServerity, EMessageType, TypeFlags, const CallbackData*, void* >;

					template<typename FuncType>
					void operator=(FuncType _function) 
					{
						Callback = reinterpret_cast<Delegate>(_function);
					}

					Delegate Callback;
				};

				/** @brief <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VkDebugUtilsMessengerCreateInfoEXT">Specification</a> */
				struct CreateInfo : V0::VKStruct_Base<VkDebugUtilsMessengerCreateInfoEXT, EStructureType::DebugUtils_Messenger_CreateInfo_EXT>
				{ 
					EType            SType        = STypeEnum;
					const void*            Next         = nullptr  ;
					CreateFlags      Flags       ;
					ServerityFlags   Serverity   ;
					TypeFlags        Type        ;
					CallbackDelegate UserCallback;
					void*            UserData     = nullptr  ;
				};

				/**
				* @brief Creates a debug messenger. 

				@details
				<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkCreateDebugUtilsMessengerEXT">Specification</a> 
				* 
				* \param _appInstance
				* \param _createSpec
				* \param _allocator
				* \param _messenger
				* \return 
				*/
				static EResult Create
				(
					AppInstance::Handle          _appInstance,
					const CreateInfo&                  _createSpec ,
					const Memory::AllocationCallbacks* _allocator  ,
					Handle&                      _messenger
				)
				{
					static FPtr_Create delegate = nullptr;

					if (delegate == nullptr) delegate = AppInstance::GetProcedureAddress<FPtr_Create>(_appInstance, "vkCreateDebugUtilsMessengerEXT");

					if (delegate != nullptr)
					{
						return EResult
						(
							delegate
							(
							_appInstance,
							(const VkDebugUtilsMessengerCreateInfoEXT*)(&_createSpec),
							(const VkAllocationCallbacks*             )( _allocator ),
							(      VkDebugUtilsMessengerEXT*          )(&_messenger )
						)
						);
					}
					else
					{
						return EResult::Error_ExtensionNotPresent;
					}
				}

				/**
				* @brief Destroys a debug messenger. 

				@details
				<a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#vkDestroyDebugUtilsMessengerEXT">Specification</a> .
				* 
				* \param _appInstance
				* \param _messenger
				* \param _allocator
				*/
				static void Destroy
				(
					AppInstance::Handle          _appInstance,
					Handle                       _messenger  ,
					const Memory::AllocationCallbacks* _allocator
				)
				{
					static FPtr_Destroy delegate = nullptr;

					if (delegate == nullptr) delegate = AppInstance::GetProcedureAddress<FPtr_Destroy>(_appInstance, "vkDestroyDebugUtilsMessengerEXT");

					if (delegate != nullptr)
					{
						delegate(_appInstance, _messenger, *_allocator);
					}
				}
			}; 

			/** @} */
		};
	}

	namespace V2
	{
		/**
		@addtogroup Vault_2
		@{
		*/

		/**
		@brief Debug Utilities: Flexible utilities for debugging an application.

		@ingroup APISpec_Debugging
		*/
		struct DebugUtils : public V1::DebugUtils 
		{
			using Parent = V1::DebugUtils;

			/**
			@brief 
			Vulkan allows an application to register multiple callbacks with any Vulkan component wishing to report debug information.
			Some callbacks may log the information to a file, others may cause a debug break point or other application defined behavior.
			*/
			struct Messenger : public Parent::Messenger
			{
				using Parent = Parent::Messenger;

				/**
				@brief Create a debug messenger with the default memory allocator.
				*/
				static EResult Create
				(
					AppInstance::Handle _appInstance,
					const CreateInfo&         _createSpec ,
					Handle&             _messenger
				)
				{
					return Parent::Create(_appInstance, _createSpec, Memory::DefaultAllocator,_messenger);
				}

				using Parent::Create;

				/**
				@brief Destroy a debug messenger that used the default memory allocator.
				*/
				static void Destroy(AppInstance::Handle _appInstance, Handle _messenger)
				{
					Parent::Destroy(_appInstance, _messenger, Memory::DefaultAllocator);
				}

				using Parent::Destroy;
			};
		};

		/** @} */
	}

	namespace V3
	{
		/**
		@addtogroup Vault_3
		@{
		*/

		/**
		@ingroup APISpec_Debugging
		@brief Debug Utilities: Flexible utilities for debugging an application.

		@details
		Currently only defines the object-oriented version of the Debug messenger.
		*/
		struct DebugUtils : public V2::DebugUtils 
		{
			using Parent = V2::DebugUtils;

			/**
			@brief 
			Vulkan allows an application to register multiple callbacks with any Vulkan component wishing to report debug information.
			Some callbacks may log the information to a file, others may cause a debug break point or other application defined behavior.

			@details
			This object represents a device created object on the host. As such ownership is tied to this host object.
			Due to this design, the object has no copy-construction allowed. Instead, default move constructor and assignment has been defined.
			*/
			class Messenger : public Parent::Messenger
			{
			public:

				using Parent = V2::DebugUtils::Messenger;

				/**
				@brief Default constructor.
				*/
				Messenger() : handle(Null<Handle>), app(nullptr), allocator(Memory::DefaultAllocator)
				{}

				/**
				@brief Default constructor with app instance specified.
				*/
				Messenger(const AppInstance& _appInstance) : handle(Null<Handle>), app(&_appInstance), allocator(Memory::DefaultAllocator)
				{}

				/**
				@brief Default constructor with app instance and allocator specified.
				*/
				Messenger(const AppInstance& _appInstance, const Memory::AllocationCallbacks& _allocator) :
					handle(Null<Handle>), app(&_appInstance), allocator(&_allocator)
				{}

				/**
				@brief Performs a move operation to transfer ownership of the device object to this host object.
				*/
				Messenger(Messenger&& _other) noexcept :
					handle(std::move(_other.handle)), app(std::move(_other.app)), allocator(std::move(_other.allocator))
				{
					_other.handle    = Null<Handle>            ;
					_other.app       = nullptr                 ;
					_other.allocator = Memory::DefaultAllocator;
				}

				/**
				@brief If the handle is found to not be null, this device will attempt to destroy the device object that corresponds to it.
				*/
				~Messenger()
				{
					if (handle != Null<Handle>) Destroy();
				}

				/**
				@brief Create a debug messenger.
				*/
				EResult Create(const CreateInfo& _createSpec)
				{
					if (app == nullptr) return EResult::Not_Ready;

					return Parent::Create(*app, _createSpec, handle);
				}

				/**
				@brief Create a debug messenger. (Specify app instance)
				*/
				EResult Create(const AppInstance& _appInstance, const CreateInfo& _createSpec)
				{
					app = &_appInstance;

					return Parent::Create(*app, _createSpec, handle);
				}

				/**
				@brief Create a debug messenger. (Specify app instance and allocator)
				*/
				EResult Create(const AppInstance& _appInstance, const CreateInfo& _createSpec, const Memory::AllocationCallbacks& _allocator)
				{
					app       = &_appInstance;
					allocator = &_allocator  ;

					return Parent::Create(*app, _createSpec, allocator, handle);
				}

				/**
				@brief Destroy a debug messenger.	
				*/
				void Destroy()
				{
					Parent::Destroy(*app, handle, allocator);

					handle    = Null<Handle>            ;
					app       = nullptr                 ;
					allocator = Memory::DefaultAllocator;
				}

				/**
				@brief Implicit conversion to give a reference to its handle.
				*/
				operator Handle&()
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a readonly reference to its handle.
				*/
				operator const Handle&() const
				{
					return handle;
				}

				/**
				@brief Implicit conversion to give a pointer to its handle.
				*/
				operator const Handle*() const
				{
					return &handle;
				}

				/**
				@brief Checks to see if its the same object by checking to see if its the same handle.
				*/
				bool operator== (const Messenger& _other) const
				{
					return handle == _other.handle;
				}

				/**
				@brief Performs a move assignment operation to transfer ownership of the device object to this host object.
				*/
				Messenger& operator= (Messenger&& _other) noexcept
				{
					if (this == &_other)
						return *this;

					handle    = std::move(_other.handle   );
					app       = std::move(_other.app      );
					allocator = std::move(_other.allocator);

					_other.handle    = Null<Handle>            ;
					_other.app       = nullptr                 ;
					_other.allocator = Memory::DefaultAllocator;

					return *this;
				}

			protected:

				Handle handle;

				const AppInstance* app;

				const Memory::AllocationCallbacks* allocator;
			};
		};

		/** @} */
	}
}



#ifdef VT_Open_Vault_4

/*!
@file VT_GPU_Comms.hpp

@brief Vaulted Thermals: GPU Communication

@details
*/



#ifndef VT_Option__Use_Long_Namespace
namespace VT
#else
namespace VaultedThermals
#endif
{
	namespace V4
	{
		/**
		@addtogroup Vault_4
		@{
		*/

		enum class EGPU_Engage
		{
			Single,
			Multi
		};

		/**
		* While this option has been defined here, currently this bootstrapped backend only supports
		* engaging a single GPU...
		*/
	#ifndef VT_Option_AllowMultiGPUEngagement
		constexpr EGPU_Engage GPU_Engagement = EGPU_Engage::Single;
	#else
		constexpr EGPU_Engage GPU_Engagement = EGPU_Engage::Multi;
	#endif

		using V3::DebugUtils;
		using V3::LayerAndExtensionProperties;

		using LayerAndExtensionList = DynamicArray<LayerAndExtensionProperties>;

		class PhysicalDevice : public V3::PhysicalDevice
		{
		public:



		protected:

		};

		using PhysicalDeviceList = DynamicArray<PhysicalDevice>;

		struct DebugUtils : public V3::DebugUtils
		{
			using Parent = V3::DebugUtils;

			class Messenger : public Parent::Messenger
			{
			public:
				using Parent = V3::DebugUtils::Messenger;

			protected:
			};
		};

		class AppInstance : public V3::AppInstance
		{
		public:


		};

		class LogicalDevice : public V3::LogicalDevice
		{
		public:

			const PhysicalDevice& GetPhysicalDevice() const
			{
				return *static_cast<const PhysicalDevice*>(physicalDevice);
			}

		protected:


		};

		using LogicalDeviceList = DynamicArray<LogicalDevice>;


		namespace Backend
		{
			template<EGPU_Engage>
			class GPU_Comms_Maker;

			template<>
			class GPU_Comms_Maker<EGPU_Engage::Single>
			{
			public:

				// Initialization and Cease (Startup/Shutdown)

				static void Initalize();

				static void Cease();



				static AppInstance::Handle GetAppHandle()
				{
					return app.GetHandle();
				}

				static const LogicalDevice& GetEngagedDevice()
				{
					return *engagedDevice;
				}

				static const PhysicalDevice& GetEngagedPhysicalGPU()
				{
					return engagedDevice->GetPhysicalDevice();
				}

			private:

				static void AcquirePhysicalDevices();

				static void EngageMostSuitableDevice();

				static void GenerateLogicalDevices();

				static AppInstance app;

				static LayerAndExtensionList layersAndExtensions;
				static Deque<RoCStr>         desiredLayers;
				static Deque<RoCStr>         desiredExtensions;
				static Deque<RoCStr>         desriedDeviceExts;

				static V3::DebugUtils::Messenger messenger;

				static PhysicalDeviceList physicalGPUs;
				static LogicalDeviceList  logicalGPUs;

				static LogicalDevice* engagedDevice;
			};
		}

		using GPU_Comms = Backend::GPU_Comms_Maker<GPU_Engagement>;

		/** @} */
	}
}




/*!
@file VT_GPU.hpp

@brief Vaulted Thermals: GPU Backend (Bootstrap)

@details
*/



#pragma once



#include "VTGPU_Comms.hpp"



/**
@brief Implementation for V4 (must be dumped into a cpp file...)
*/
#ifdef VT_V4_Setup_Implementation



#  ifndef VT_Option__Use_Long_Namespace
namespace VT
#  else
namespace VaultedThermals
#  endif
{
	namespace V4
	{
		/**
		@addtogroup Vault_4
		@{
		*/
	#pragma region GPU_Comms

		AppInstance GPU_Comms::app;

		LayerAndExtensionList GPU_Comms::layersAndExtensions;
		Deque<RoCStr>         GPU_Comms::desiredLayers      ;
		Deque<RoCStr>         GPU_Comms::desiredExtensions  ;
		Deque<RoCStr>         GPU_Comms::desriedDeviceExts  ;

		V3::DebugUtils::Messenger GPU_Comms::messenger;

		PhysicalDeviceList GPU_Comms::physicalGPUs;
		LogicalDeviceList  GPU_Comms::logicalGPUs ;

		LogicalDevice* GPU_Comms::engagedDevice;

	#pragma endregion GPU_Comms

		/** @} */
	}
}



#endif   // VT_V4_Setup_Implementation



#endif	 // VT_Open_Vault_4
